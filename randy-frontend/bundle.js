(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.liquid = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
(function (process,Buffer,__dirname){(function (){

var Module = (function() {
  var _scriptDir = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : undefined;
  return (
function(Module) {
  Module = Module || {};

var Module=typeof Module!=="undefined"?Module:{};var moduleOverrides={};var key;for(key in Module){if(Module.hasOwnProperty(key)){moduleOverrides[key]=Module[key]}}Module["arguments"]=[];Module["thisProgram"]="./this.program";Module["quit"]=(function(status,toThrow){throw toThrow});Module["preRun"]=[];Module["postRun"]=[];var ENVIRONMENT_IS_WEB=false;var ENVIRONMENT_IS_WORKER=false;var ENVIRONMENT_IS_NODE=false;var ENVIRONMENT_IS_SHELL=false;ENVIRONMENT_IS_WEB=typeof window==="object";ENVIRONMENT_IS_WORKER=typeof importScripts==="function";ENVIRONMENT_IS_NODE=typeof process==="object"&&typeof require==="function"&&!ENVIRONMENT_IS_WEB&&!ENVIRONMENT_IS_WORKER;ENVIRONMENT_IS_SHELL=!ENVIRONMENT_IS_WEB&&!ENVIRONMENT_IS_NODE&&!ENVIRONMENT_IS_WORKER;var scriptDirectory="";function locateFile(path){if(Module["locateFile"]){return Module["locateFile"](path,scriptDirectory)}else{return scriptDirectory+path}}if(ENVIRONMENT_IS_NODE){scriptDirectory=__dirname+"/";var nodeFS;var nodePath;Module["read"]=function shell_read(filename,binary){var ret;ret=tryParseAsDataURI(filename);if(!ret){if(!nodeFS)nodeFS=require("fs");if(!nodePath)nodePath=require("path");filename=nodePath["normalize"](filename);ret=nodeFS["readFileSync"](filename)}return binary?ret:ret.toString()};Module["readBinary"]=function readBinary(filename){var ret=Module["read"](filename,true);if(!ret.buffer){ret=new Uint8Array(ret)}assert(ret.buffer);return ret};if(process["argv"].length>1){Module["thisProgram"]=process["argv"][1].replace(/\\/g,"/")}Module["arguments"]=process["argv"].slice(2);process["on"]("uncaughtException",(function(ex){if(!(ex instanceof ExitStatus)){throw ex}}));process["on"]("unhandledRejection",(function(reason,p){process["exit"](1)}));Module["quit"]=(function(status){process["exit"](status)});Module["inspect"]=(function(){return"[Emscripten Module object]"})}else if(ENVIRONMENT_IS_SHELL){if(typeof read!="undefined"){Module["read"]=function shell_read(f){var data=tryParseAsDataURI(f);if(data){return intArrayToString(data)}return read(f)}}Module["readBinary"]=function readBinary(f){var data;data=tryParseAsDataURI(f);if(data){return data}if(typeof readbuffer==="function"){return new Uint8Array(readbuffer(f))}data=read(f,"binary");assert(typeof data==="object");return data};if(typeof scriptArgs!="undefined"){Module["arguments"]=scriptArgs}else if(typeof arguments!="undefined"){Module["arguments"]=arguments}if(typeof quit==="function"){Module["quit"]=(function(status){quit(status)})}}else if(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER){if(ENVIRONMENT_IS_WEB){if(document.currentScript){scriptDirectory=document.currentScript.src}}else{scriptDirectory=self.location.href}if(_scriptDir){scriptDirectory=_scriptDir}if(scriptDirectory.indexOf("blob:")!==0){scriptDirectory=scriptDirectory.split("/").slice(0,-1).join("/")+"/"}else{scriptDirectory=""}Module["read"]=function shell_read(url){try{var xhr=new XMLHttpRequest;xhr.open("GET",url,false);xhr.send(null);return xhr.responseText}catch(err){var data=tryParseAsDataURI(url);if(data){return intArrayToString(data)}throw err}};if(ENVIRONMENT_IS_WORKER){Module["readBinary"]=function readBinary(url){try{var xhr=new XMLHttpRequest;xhr.open("GET",url,false);xhr.responseType="arraybuffer";xhr.send(null);return new Uint8Array(xhr.response)}catch(err){var data=tryParseAsDataURI(url);if(data){return data}throw err}}}Module["readAsync"]=function readAsync(url,onload,onerror){var xhr=new XMLHttpRequest;xhr.open("GET",url,true);xhr.responseType="arraybuffer";xhr.onload=function xhr_onload(){if(xhr.status==200||xhr.status==0&&xhr.response){onload(xhr.response);return}var data=tryParseAsDataURI(url);if(data){onload(data.buffer);return}onerror()};xhr.onerror=onerror;xhr.send(null)};Module["setWindowTitle"]=(function(title){document.title=title})}else{}var out=Module["print"]||(typeof console!=="undefined"?console.log.bind(console):typeof print!=="undefined"?print:null);var err=Module["printErr"]||(typeof printErr!=="undefined"?printErr:typeof console!=="undefined"&&console.warn.bind(console)||out);for(key in moduleOverrides){if(moduleOverrides.hasOwnProperty(key)){Module[key]=moduleOverrides[key]}}moduleOverrides=undefined;var STACK_ALIGN=16;function staticAlloc(size){var ret=STATICTOP;STATICTOP=STATICTOP+size+15&-16;return ret}function alignMemory(size,factor){if(!factor)factor=STACK_ALIGN;var ret=size=Math.ceil(size/factor)*factor;return ret}var asm2wasmImports={"f64-rem":(function(x,y){return x%y}),"debugger":(function(){debugger})};var functionPointers=new Array(0);var GLOBAL_BASE=1024;var ABORT=0;var EXITSTATUS=0;function assert(condition,text){if(!condition){abort("Assertion failed: "+text)}}function getCFunc(ident){var func=Module["_"+ident];assert(func,"Cannot call unknown function "+ident+", make sure it is exported");return func}var JSfuncs={"stackSave":(function(){stackSave()}),"stackRestore":(function(){stackRestore()}),"arrayToC":(function(arr){var ret=stackAlloc(arr.length);writeArrayToMemory(arr,ret);return ret}),"stringToC":(function(str){var ret=0;if(str!==null&&str!==undefined&&str!==0){var len=(str.length<<2)+1;ret=stackAlloc(len);stringToUTF8(str,ret,len)}return ret})};var toC={"string":JSfuncs["stringToC"],"array":JSfuncs["arrayToC"]};function ccall(ident,returnType,argTypes,args,opts){function convertReturnValue(ret){if(returnType==="string")return Pointer_stringify(ret);if(returnType==="boolean")return Boolean(ret);return ret}var func=getCFunc(ident);var cArgs=[];var stack=0;if(args){for(var i=0;i<args.length;i++){var converter=toC[argTypes[i]];if(converter){if(stack===0)stack=stackSave();cArgs[i]=converter(args[i])}else{cArgs[i]=args[i]}}}var ret=func.apply(null,cArgs);ret=convertReturnValue(ret);if(stack!==0)stackRestore(stack);return ret}function setValue(ptr,value,type,noSafe){type=type||"i8";if(type.charAt(type.length-1)==="*")type="i32";switch(type){case"i1":HEAP8[ptr>>0]=value;break;case"i8":HEAP8[ptr>>0]=value;break;case"i16":HEAP16[ptr>>1]=value;break;case"i32":HEAP32[ptr>>2]=value;break;case"i64":tempI64=[value>>>0,(tempDouble=value,+Math_abs(tempDouble)>=1?tempDouble>0?(Math_min(+Math_floor(tempDouble/4294967296),4294967295)|0)>>>0:~~+Math_ceil((tempDouble- +(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[ptr>>2]=tempI64[0],HEAP32[ptr+4>>2]=tempI64[1];break;case"float":HEAPF32[ptr>>2]=value;break;case"double":HEAPF64[ptr>>3]=value;break;default:abort("invalid type for setValue: "+type)}}function getValue(ptr,type,noSafe){type=type||"i8";if(type.charAt(type.length-1)==="*")type="i32";switch(type){case"i1":return HEAP8[ptr>>0];case"i8":return HEAP8[ptr>>0];case"i16":return HEAP16[ptr>>1];case"i32":return HEAP32[ptr>>2];case"i64":return HEAP32[ptr>>2];case"float":return HEAPF32[ptr>>2];case"double":return HEAPF64[ptr>>3];default:abort("invalid type for getValue: "+type)}return null}function Pointer_stringify(ptr,length){if(length===0||!ptr)return"";var hasUtf=0;var t;var i=0;while(1){t=HEAPU8[ptr+i>>0];hasUtf|=t;if(t==0&&!length)break;i++;if(length&&i==length)break}if(!length)length=i;var ret="";if(hasUtf<128){var MAX_CHUNK=1024;var curr;while(length>0){curr=String.fromCharCode.apply(String,HEAPU8.subarray(ptr,ptr+Math.min(length,MAX_CHUNK)));ret=ret?ret+curr:curr;ptr+=MAX_CHUNK;length-=MAX_CHUNK}return ret}return UTF8ToString(ptr)}var UTF8Decoder=typeof TextDecoder!=="undefined"?new TextDecoder("utf8"):undefined;function UTF8ArrayToString(u8Array,idx){var endPtr=idx;while(u8Array[endPtr])++endPtr;if(endPtr-idx>16&&u8Array.subarray&&UTF8Decoder){return UTF8Decoder.decode(u8Array.subarray(idx,endPtr))}else{var u0,u1,u2,u3,u4,u5;var str="";while(1){u0=u8Array[idx++];if(!u0)return str;if(!(u0&128)){str+=String.fromCharCode(u0);continue}u1=u8Array[idx++]&63;if((u0&224)==192){str+=String.fromCharCode((u0&31)<<6|u1);continue}u2=u8Array[idx++]&63;if((u0&240)==224){u0=(u0&15)<<12|u1<<6|u2}else{u3=u8Array[idx++]&63;if((u0&248)==240){u0=(u0&7)<<18|u1<<12|u2<<6|u3}else{u4=u8Array[idx++]&63;if((u0&252)==248){u0=(u0&3)<<24|u1<<18|u2<<12|u3<<6|u4}else{u5=u8Array[idx++]&63;u0=(u0&1)<<30|u1<<24|u2<<18|u3<<12|u4<<6|u5}}}if(u0<65536){str+=String.fromCharCode(u0)}else{var ch=u0-65536;str+=String.fromCharCode(55296|ch>>10,56320|ch&1023)}}}}function UTF8ToString(ptr){return UTF8ArrayToString(HEAPU8,ptr)}function stringToUTF8Array(str,outU8Array,outIdx,maxBytesToWrite){if(!(maxBytesToWrite>0))return 0;var startIdx=outIdx;var endIdx=outIdx+maxBytesToWrite-1;for(var i=0;i<str.length;++i){var u=str.charCodeAt(i);if(u>=55296&&u<=57343){var u1=str.charCodeAt(++i);u=65536+((u&1023)<<10)|u1&1023}if(u<=127){if(outIdx>=endIdx)break;outU8Array[outIdx++]=u}else if(u<=2047){if(outIdx+1>=endIdx)break;outU8Array[outIdx++]=192|u>>6;outU8Array[outIdx++]=128|u&63}else if(u<=65535){if(outIdx+2>=endIdx)break;outU8Array[outIdx++]=224|u>>12;outU8Array[outIdx++]=128|u>>6&63;outU8Array[outIdx++]=128|u&63}else if(u<=2097151){if(outIdx+3>=endIdx)break;outU8Array[outIdx++]=240|u>>18;outU8Array[outIdx++]=128|u>>12&63;outU8Array[outIdx++]=128|u>>6&63;outU8Array[outIdx++]=128|u&63}else if(u<=67108863){if(outIdx+4>=endIdx)break;outU8Array[outIdx++]=248|u>>24;outU8Array[outIdx++]=128|u>>18&63;outU8Array[outIdx++]=128|u>>12&63;outU8Array[outIdx++]=128|u>>6&63;outU8Array[outIdx++]=128|u&63}else{if(outIdx+5>=endIdx)break;outU8Array[outIdx++]=252|u>>30;outU8Array[outIdx++]=128|u>>24&63;outU8Array[outIdx++]=128|u>>18&63;outU8Array[outIdx++]=128|u>>12&63;outU8Array[outIdx++]=128|u>>6&63;outU8Array[outIdx++]=128|u&63}}outU8Array[outIdx]=0;return outIdx-startIdx}function stringToUTF8(str,outPtr,maxBytesToWrite){return stringToUTF8Array(str,HEAPU8,outPtr,maxBytesToWrite)}var UTF16Decoder=typeof TextDecoder!=="undefined"?new TextDecoder("utf-16le"):undefined;var WASM_PAGE_SIZE=65536;var ASMJS_PAGE_SIZE=16777216;var MIN_TOTAL_MEMORY=16777216;function alignUp(x,multiple){if(x%multiple>0){x+=multiple-x%multiple}return x}var buffer,HEAP8,HEAPU8,HEAP16,HEAPU16,HEAP32,HEAPU32,HEAPF32,HEAPF64;function updateGlobalBuffer(buf){Module["buffer"]=buffer=buf}function updateGlobalBufferViews(){Module["HEAP8"]=HEAP8=new Int8Array(buffer);Module["HEAP16"]=HEAP16=new Int16Array(buffer);Module["HEAP32"]=HEAP32=new Int32Array(buffer);Module["HEAPU8"]=HEAPU8=new Uint8Array(buffer);Module["HEAPU16"]=HEAPU16=new Uint16Array(buffer);Module["HEAPU32"]=HEAPU32=new Uint32Array(buffer);Module["HEAPF32"]=HEAPF32=new Float32Array(buffer);Module["HEAPF64"]=HEAPF64=new Float64Array(buffer)}var STATIC_BASE,STATICTOP,staticSealed;var STACK_BASE,STACKTOP,STACK_MAX;var DYNAMIC_BASE,DYNAMICTOP_PTR;STATIC_BASE=STATICTOP=STACK_BASE=STACKTOP=STACK_MAX=DYNAMIC_BASE=DYNAMICTOP_PTR=0;staticSealed=false;function abortOnCannotGrowMemory(){abort("Cannot enlarge memory arrays. Either (1) compile with  -s TOTAL_MEMORY=X  with X higher than the current value "+TOTAL_MEMORY+", (2) compile with  -s ALLOW_MEMORY_GROWTH=1  which allows increasing the size at runtime, or (3) if you want malloc to return NULL (0) instead of this abort, compile with  -s ABORTING_MALLOC=0 ")}if(!Module["reallocBuffer"])Module["reallocBuffer"]=(function(size){var ret;try{if(ArrayBuffer.transfer){ret=ArrayBuffer.transfer(buffer,size)}else{var oldHEAP8=HEAP8;ret=new ArrayBuffer(size);var temp=new Int8Array(ret);temp.set(oldHEAP8)}}catch(e){return false}var success=_emscripten_replace_memory(ret);if(!success)return false;return ret});function enlargeMemory(){var PAGE_MULTIPLE=Module["usingWasm"]?WASM_PAGE_SIZE:ASMJS_PAGE_SIZE;var LIMIT=2147483648-PAGE_MULTIPLE;if(HEAP32[DYNAMICTOP_PTR>>2]>LIMIT){return false}var OLD_TOTAL_MEMORY=TOTAL_MEMORY;TOTAL_MEMORY=Math.max(TOTAL_MEMORY,MIN_TOTAL_MEMORY);while(TOTAL_MEMORY<HEAP32[DYNAMICTOP_PTR>>2]){if(TOTAL_MEMORY<=536870912){TOTAL_MEMORY=alignUp(2*TOTAL_MEMORY,PAGE_MULTIPLE)}else{TOTAL_MEMORY=Math.min(alignUp((3*TOTAL_MEMORY+2147483648)/4,PAGE_MULTIPLE),LIMIT)}}var replacement=Module["reallocBuffer"](TOTAL_MEMORY);if(!replacement||replacement.byteLength!=TOTAL_MEMORY){TOTAL_MEMORY=OLD_TOTAL_MEMORY;return false}updateGlobalBuffer(replacement);updateGlobalBufferViews();return true}var byteLength;try{byteLength=Function.prototype.call.bind(Object.getOwnPropertyDescriptor(ArrayBuffer.prototype,"byteLength").get);byteLength(new ArrayBuffer(4))}catch(e){byteLength=(function(buffer){return buffer.byteLength})}var TOTAL_STACK=Module["TOTAL_STACK"]||5242880;var TOTAL_MEMORY=Module["TOTAL_MEMORY"]||16777216;if(TOTAL_MEMORY<TOTAL_STACK)err("TOTAL_MEMORY should be larger than TOTAL_STACK, was "+TOTAL_MEMORY+"! (TOTAL_STACK="+TOTAL_STACK+")");if(Module["buffer"]){buffer=Module["buffer"]}else{if(typeof WebAssembly==="object"&&typeof WebAssembly.Memory==="function"){Module["wasmMemory"]=new WebAssembly.Memory({"initial":TOTAL_MEMORY/WASM_PAGE_SIZE});buffer=Module["wasmMemory"].buffer}else{buffer=new ArrayBuffer(TOTAL_MEMORY)}Module["buffer"]=buffer}updateGlobalBufferViews();function getTotalMemory(){return TOTAL_MEMORY}function callRuntimeCallbacks(callbacks){while(callbacks.length>0){var callback=callbacks.shift();if(typeof callback=="function"){callback();continue}var func=callback.func;if(typeof func==="number"){if(callback.arg===undefined){Module["dynCall_v"](func)}else{Module["dynCall_vi"](func,callback.arg)}}else{func(callback.arg===undefined?null:callback.arg)}}}var __ATPRERUN__=[];var __ATINIT__=[];var __ATMAIN__=[];var __ATPOSTRUN__=[];var runtimeInitialized=false;function preRun(){if(Module["preRun"]){if(typeof Module["preRun"]=="function")Module["preRun"]=[Module["preRun"]];while(Module["preRun"].length){addOnPreRun(Module["preRun"].shift())}}callRuntimeCallbacks(__ATPRERUN__)}function ensureInitRuntime(){if(runtimeInitialized)return;runtimeInitialized=true;callRuntimeCallbacks(__ATINIT__)}function preMain(){callRuntimeCallbacks(__ATMAIN__)}function postRun(){if(Module["postRun"]){if(typeof Module["postRun"]=="function")Module["postRun"]=[Module["postRun"]];while(Module["postRun"].length){addOnPostRun(Module["postRun"].shift())}}callRuntimeCallbacks(__ATPOSTRUN__)}function addOnPreRun(cb){__ATPRERUN__.unshift(cb)}function addOnPostRun(cb){__ATPOSTRUN__.unshift(cb)}function writeArrayToMemory(array,buffer){HEAP8.set(array,buffer)}var Math_abs=Math.abs;var Math_ceil=Math.ceil;var Math_floor=Math.floor;var Math_min=Math.min;var runDependencies=0;var runDependencyWatcher=null;var dependenciesFulfilled=null;function addRunDependency(id){runDependencies++;if(Module["monitorRunDependencies"]){Module["monitorRunDependencies"](runDependencies)}}function removeRunDependency(id){runDependencies--;if(Module["monitorRunDependencies"]){Module["monitorRunDependencies"](runDependencies)}if(runDependencies==0){if(runDependencyWatcher!==null){clearInterval(runDependencyWatcher);runDependencyWatcher=null}if(dependenciesFulfilled){var callback=dependenciesFulfilled;dependenciesFulfilled=null;callback()}}}Module["preloadedImages"]={};Module["preloadedAudios"]={};var dataURIPrefix="data:application/octet-stream;base64,";function isDataURI(filename){return String.prototype.startsWith?filename.startsWith(dataURIPrefix):filename.indexOf(dataURIPrefix)===0}function integrateWasmJS(){var wasmTextFile="";var wasmBinaryFile="data:application/octet-stream;base64,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DCACIAIQDCACIAIQDCACIAIQDCACIAIQDCACIAIQDCACIAIQDCACIAIQDCACIAIQDCACIAIQDCACIAIQDCACIAIQDCACIAIQDCACIAIQDCACIAIQDCACIAIQDCACIAIQDCACIAIQDCACIAIQDCACIAIQDCACIAIQDCACIAIQDCACIAIQDCACIAIQDCACIAIQDCACIAIQDCACIAIQDCACIAIQDCACIAIQDCACIAIQDCACIAIQDCACIAIQDCACIAIQDCACIAIQDCACIAIQDCACIAIgBRAPIARB+ABqIgkgAikCADcCACAJIAIpAgg3AgggCSACKQIQNwIQIAkgAikCGDcCGCAJIAIpAiA3AiBBACEGA0AgCSAJEAwgBkEBaiIGQdgARw0ACyAJIAkgAhAPIAMgCSkCADcCACADIAkpAgg3AgggAyAJKQIQNwIQIAMgCSkCGDcCGCADIAkpAiA3AiAgAyADEAwgAyADEAwgAyADEAwgAyADEAwgAyADEAwgAyADEAwgAyADEAwgAyADEAwgAyADEAwgAyADEAwgAyADEAwgAyADEAwgAyADEAwgAyADEAwgAyADEAwgAyADEAwgAyADEAwgAyADEAwgAyADEAwgAyADEAwgAyADEAwgAyADEAwgAyADEAwgAyADEAwgAyADEAwgAyADEAwgAyADEAwgAyADEAwgAyADEAwgAyADEAwgAyADEAwgAyADEAwgAyADEAwgAyADEAwgAyADEAwgAyADEAwgAyADEAwgAyADEAwgAyADEAwgAyADEAwgAyADEAwgAyADEAwgAyADEAwgAyADEAwgAyADIAUQDyAIIAMpAgA3AgAgCCADKQIINwIIIAggAykCEDcCECAIIAMpAhg3AhggCCADKQIgNwIgIAggCBAMIAggCBAMIAggCBAMIAggCCAKEA8gBCAIKQIANwIAIAQgCCkCCDcCCCAEIAgpAhA3AhAgBCAIKQIYNwIYIAQgCCkCIDcCICAEIAQQDCAEIAQQDCAEIAQQDCAEIAQQDCAEIAQQDCAEIAQQDCAEIAQQDCAEIAQQDCAEIAQQDCAEIAQQDCAEIAQQDCAEIAQQDCAEIAQQDCAEIAQQDCAEIAQQDCAEIAQQDCAEIAQQDCAEIAQQDCAEIAQQDCAEIAQQDCAEIAQQDCAEIAQQDCAEIAQQDCAEIAQgBxAPIAQg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ISIgFCgCAEEGbCEjIBUoAgBBBmwhJCAWKAIAQQZsISUgFygCAEEGbCEmIAIgAigCAEEGbEG84f//ACApa2o2AgAgBiAeQfz9//8AIAFrajYCACAQIB9B/P///wAgB2tqNgIAIBEgIEH8////ACAYa2o2AgAgEiAhQfz///8AIBlrajYCACATICJB/P///wAgGmtqNgIAIBQgI0H8////ACAba2o2AgAgFSAkQfz///8AIBxrajYCACAWICVB/P///wAgHWtqNgIAIBcgJkH8//8HIAVrajYCACAAQShqIgEgBCACEA8gASABKAIAQZrS/78BIAMoAgBrajYCACAAQSxqIgEgASgCAEH6/P+/ASAna2o2AgAgAEEwaiIBIAEoAgBB+v//vwEgCGtqNgIAIABBNGoiASABKAIAQfr//78BIAlrajYCACAAQThqIgEgASgCAEH6//+/ASAKa2o2AgAgAEE8aiIBIAEoAgBB+v//vwEgC2tqNgIAIABBQGsiASABKAIAQfr//78BIAxrajYCACAAQcQAaiIBIAEoAgBB+v//vwEgDWtqNgIAIABByABqIgEgASgCAEH6//+/ASAOa2o2AgAgAEHMAGoiACAAKAIAQfr//wsgD2tqNgIAIAMkBAuYAgEEfyAAIAJqIQQgAUH/AXEhASACQcMATgRAA0AgAEEDcQRAIAAgAToAACAAQQFqIQAMAQsLIARBfHEiBUFAaiEGIAEgAUEIdHIgAUEQdHIgAUEYdHIhAwNAIAAgBkwEQCAAIAM2AgAgACADNgIEIAAgAzYCCCAAIAM2AgwgACADNgIQIAAgAzYCFCAAIAM2AhggACADNgIcIAAgAzYCICAAIAM2AiQgACADNgIoIAAgAzYCLCAAIAM2AjAgACADNgI0IAAgAzYCOCAAIAM2AjwgAEFAayEADAELCwNAIAAgBUgEQCAAIAM2AgAgAEEEaiEADAELCwsDQCAAIARIBEAgACABOgAAIABBAWohAAwBCwsgBCACawvcGwEqfwJAIwQhFSMEQcADaiQEIAIoAlAhBCABQfgAaiIsKAIABEAgACAENgJ4IAAgAikCADcCACAAIAIpAgg3AgggACACKQIQNwIQIAAgAikCGDcCGCAAIAIpAiA3AiAgAEEoaiIDIAJBKGoiASkCADcCACADIAEpAgg3AgggAyABKQIQNwIQIAMgASkCGDcCGCADIAEpAiA3AiAgAEEBNgJQIABB1ABqIgBCADcCACAAQgA3AgggAEIANwIQIABCADcCGCAAQQA2AiAMAQsgBARAIAMEQCADQQE2AgAgA0EEaiICQgA3AgAgAkIANwIIIAJCADcCECACQgA3AhggAkEANgIgCyAAIAEpAgA3AgAgACABKQIINwIIIAAgASkCEDcCECAAIAEpAhg3AhggACABKQIgNwIgIAAgASkCKDcCKCAAIAEpAjA3AjAgACABKQI4NwI4IABBQGsgAUFAaykCADcCACAAIAEpAkg3AkggACABKQJQNwJQIAAgASkCWDcCWCAAIAEpAmA3AmAgACABKQJoNwJoIAAgASkCcDcCcCAAIAEoAng2AngMAQsgFUH4AGohFiAVQdAAaiEmIBVBKGohCiAAQfgAaiInQQA2AgAgFSIEQZADaiIoIAFB0ABqIikQDCAEQegCaiIIIAEpAgA3AgAgCCABKQIINwIIIAggASkCEDcCECAIIAEpAhg3AhggCCABKQIgNwIgIAhBJGoiGygCACIdQRZ2IgdB0QdsIAgoAgBqIR4gB0EGdCAIQQRqIhIoAgBqIB5BGnZqIhdBGnYgCEEIaiIYKAIAaiIZQRp2IAhBDGoiBSgCAGoiBkEadiAIQRBqIg0oAgBqIhNBGnYgCEEUaiIUKAIAaiILQRp2IAhBGGoiDigCAGoiD0EadiAIQRxqIhAoAgBqIhFBGnYgCEEgaiIHKAIAaiEfIAggHkH///8fcSItNgIAIBIgF0H///8fcSIMNgIAIBggGUH///8fcSIgNgIAIAUgBkH///8fcSIhNgIAIA0gE0H///8fcSIiNgIAIBQgC0H///8fcSIjNgIAIA4gD0H///8fcSIkNgIAIBAgEUH///8fcSIlNgIAIAcgH0H///8fcSIeNgIAIBsgH0EadiAdQf///wFxaiIfNgIAIARBwAJqIhogAiAoEA8gBEGYAmoiCSABQShqIhwpAgA3AgAgCSAcKQIINwIIIAkgHCkCEDcCECAJIBwpAhg3AhggCSAcKQIgNwIgIAlBJGoiKigCACIbQRZ2IgdB0QdsIAkoAgBqIQ0gB0EGdCAJQQRqIh0oAgBqIA1BGnZqIhNBGnYgCUEIaiISKAIAaiIUQRp2IAlBDGoiFygCAGoiC0EadiAJQRBqIhgoAgBqIg5BGnYgCUEUaiIZKAIAaiIPQRp2IAlBGGoiBSgCAGoiEEEadiAJQRxqIgYoAgBqIhFBGnYgCUEgaiIHKAIAaiErIAkgDUH///8fcSINNgIAIB0gE0H///8fcSITNgIAIBIgFEH///8fcSIUNgIAIBcgC0H///8fcSILNgIAIBggDkH///8fcSIONgIAIBkgD0H///8fcSIPNgIAIAUgEEH///8fcSIQNgIAIAYgEUH///8fcSIRNgIAIAcgK0H///8fcSIHNgIAICogK0EadiAbQf///wFxajYCACAEQfABaiIGIAJBKGogKBAPIAYgBiApEA8gBEHIAWoiBSAaKAIAQbzh//8AIC1rajYCACAFIBooAgRB/P3//wAgDGtqNgIEIAUgGigCCEH8////ACAga2o2AgggBSAaKAIMQfz///8AICFrajYCDCAFIBooAhBB/P///wAgImtqNgIQIAUgGigCFEH8////ACAja2o2AhQgBSAaKAIYQfz///8AICRrajYCGCAFIBooAhxB/P///wAgJWtqNgIcIAUgGigCIEH8////ACAea2o2AiAgBSAaKAIkQfz//wcgH2tqNgIkQfz//wcgKigCAGshAiAEQaABaiIMIAYoAgBBvOH//wAgDWtqNgIAIAwgBigCBEH8/f//ACATa2o2AgQgDCAGKAIIQfz///8AIBRrajYCCCAMIAYoAgxB/P///wAgC2tqNgIMIAwgBigCEEH8////ACAOa2o2AhAgDCAGKAIUQfz///8AIA9rajYCFCAMIAYoAhhB/P///wAgEGtqNgIYIAwgBigCHEH8////ACARa2o2AhwgDCAGKAIgQfz///8AIAdrajYCICAMIAYoAiQgAmo2AiQgBRAjRQRAIBYgDBAMICYgBRAMIAogBSAmEA8gAwRAIAMgBSkCADcCACADIAUpAgg3AgggAyAFKQIQNwIQIAMgBSkCGDcCGCADIAUpAiA3AiALIABB0ABqICkgBRAPIAQgCCAmEA8gACAEKQIANwIAIAAgBCkCCDcCCCAAIAQpAhA3AhAgACAEKQIYNwIYIAAgBCkCIDcCIEH4+///ASAKQQRqIiAoAgAgAEEEaiIdKAIAQQF0amshC0H4////ASAKQQhqIiEoAgAgAEEIaiISKAIAQQF0amshDkH4////ASAKQQxqIiIoAgAgAEEMaiIXKAIAQQF0amshD0H4////ASAKQRBqIiMoAgAgAEEQaiIYKAIAQQF0amshEEH4////ASAKQRRqIiQoAgAgAEEUaiIZKAIAQQF0amshEUH4////ASAKQRhqIiUoAgAgAEEYaiIFKAIAQQF0amshB0H4////ASAKQRxqIh4oAgAgAEEcaiIGKAIAQQF0amshA0H4////ASAKQSBqIh8oAgAgAEEgaiINKAIAQQF0amshAkH4//8PIApBJGoiGygCACAAQSRqIhMoAgBBAXRqayEBIAAgFigCAEH4wv//ASAKKAIAIAAoAgBBAXRqa2oiFDYCACAdIBYoAgQgC2oiCzYCACASIBYoAgggDmoiDjYCACAXIBYoAgwgD2oiDzYCACAYIBYoAhAgEGoiEDYCACAZIBYoAhQgEWoiETYCACAFIBYoAhggB2oiBzYCACAGIBYoAhwgA2oiAzYCACANIBYoAiAgAmoiAjYCACATIBYoAiQgAWoiATYCACAAQShqIhIgBCgCAEG0pP//AiAUa2o2AgAgAEEsaiIXIAQoAgRB9Pn//wIgC2tqNgIAIABBMGoiGCAEKAIIQfT///8CIA5rajYCACAAQTRqIhkgBCgCDEH0////AiAPa2o2AgAgAEE4aiIFIAQoAhBB9P///wIgEGtqNgIAIABBPGoiBiAEKAIUQfT///8CIBFrajYCACAAQUBrIg0gBCgCGEH0////AiAHa2o2AgAgAEHEAGoiEyAEKAIcQfT///8CIANrajYCACAAQcgAaiIUIAQoAiBB9P///wIgAmtqNgIAIABBzABqIgsgBCgCJEH0//8XIAFrajYCACASIBIgDBAPIAogCiAJEA8gCkG84f//ACAKKAIAayIONgIAICBB/P3//wAgICgCAGsiDzYCACAhQfz///8AICEoAgBrIhA2AgAgIkH8////ACAiKAIAayIRNgIAICNB/P///wAgIygCAGsiBzYCACAkQfz///8AICQoAgBrIgQ2AgAgJUH8////ACAlKAIAayIDNgIAIB5B/P///wAgHigCAGsiAjYCACAfQfz///8AIB8oAgBrIgE2AgAgG0H8//8HIBsoAgBrIgA2AgAgEiASKAIAIA5qNgIAIBcgFygCACAPajYCACAYIBgoAgAgEGo2AgAgGSAZKAIAIBFqNgIAIAUgBSgCACAHajYCACAGIAYoAgAgBGo2AgAgDSANKAIAIANqNgIAIBMgEygCACACajYCACAUIBQoAgAgAWo2AgAgCyALKAIAIABqNgIADAELIAwQI0UEQCADBEAgA0IANwIAIANCADcCCCADQgA3AhAgA0IANwIYIANCADcCIAsgJ0EBNgIAIABCADcCACAAQgA3AgggAEIANwIQIABCADcCGCAAQgA3AiAgAEIANwIoIABCADcCMCAAQgA3AjggAEFAa0IANwIAIABCADcCSCAAQgA3AlAgAEIANwJYIABCADcCYCAAQgA3AmggAEIANwJwDAELICwoAgAEQCAnQQE2AgAgA0UEQCAVJAQPCyADQQE2AgAgA0EEaiIAQgA3AgAgAEIANwIIIABCADcCECAAQgA3AhggAEEANgIgBSADBEAgAyAcKQIANwIAIAMgHCkCCDcCCCADIBwpAhA3AhAgAyAcKQIYNwIYIAMgHCkCIDcCICADQSRqIhIoAgAiF0EWdiICQdEHbCADKAIAaiEbIAJBBnQgA0EEaiIYKAIAaiAbQRp2aiIZQRp2IANBCGoiBSgCAGoiBkEadiADQQxqIg0oAgBqIhNBGnYgA0EQaiIUKAIAaiILQRp2IANBFGoiDigCAGoiD0EadiADQRhqIhAoAgBqIhFBGnYgA0EcaiIHKAIAaiIEQRp2IANBIGoiAigCAGohHSADIBtBAXRB/v//P3E2AgAgGCAZQQF0Qf7//z9xNgIAIAUgBkEBdEH+//8/cTYCACANIBNBAXRB/v//P3E2AgAgFCALQQF0Qf7//z9xNgIAIA4gD0EBdEH+//8/cTYCACAQIBFBAXRB/v//P3E2AgAgByAEQQF0Qf7//z9xNgIAIAIgHUEBdEH+//8/cTYCACASIB1BGnYgF0H///8BcWpBAXQ2AgALIAAgARAdCyAVJAQPCyAVJAQLyw0BC38jBCEMIwRB4ANqJAQgDEHQAGohAyAMQShqIQggDCIEQbgDaiILIAEQDCALIAsgARAPIARBkANqIgogCxAMIAogCiABEA8gBEHoAmoiBiAKKQIANwIAIAYgCikCCDcCCCAGIAopAhA3AhAgBiAKKQIYNwIYIAYgCikCIDcCICAGIAYQDCAGIAYQDCAGIAYQDCAGIAYgChAPIARBwAJqIgIgBikCADcCACACIAYpAgg3AgggAiAGKQIQNwIQIAIgBikCGDcCGCACIAYpAiA3AiAgAiACEAwgAiACEAwgAiACEAwgAiACIAoQDyAEQZgCaiIGIAIpAgA3AgAgBiACKQIINwIIIAYgAikCEDcCECAGIAIpAhg3AhggBiACKQIgNwIgIAYgBhAMIAYgBhAMIAYgBiALEA8gBEHwAWoiByAGKQIANwIAIAcgBikCCDcCCCAHIAYpAhA3AhAgByAGKQIYNwIYIAcgBikCIDcCICAHIAcQDCAHIAcQDCAHIAcQDCAHIAcQDCAHIAcQDCAHIAcQDCAHIAcQDCAHIAcQDCAHIAcQDCAHIAcQDCAHIAcQDCAHIAcgBhAPIARByAFqIgUgBykCADcCACAFIAcpAgg3AgggBSAHKQIQNwIQIAUgBykCGDcCGCAFIAcpAiA3AiAgBSAFEAwgBSAFEAwgBSAFEAwgBSAFEAwgBSAFEAwgBSAFEAwgBSAFEAwgBSAFEAwgBSAFEAwgBSAFEAwgBSAFEAwgBSAFEAwgBSAFEAwgBSAFEAwgBSAFEAwgBSAFEAwgBSAFEAwgBSAFEAwgBSAFEAwgBSAFEAwgBSAFEAwgBSAFEAwgBSAFIAcQDyAEQaABaiICIAUpAgA3AgAgAiAFKQIINwIIIAIgBSkCEDcCECACIAUpAhg3AhggAiAFKQIgNwIgIAIgAhAMIAIgAhAMIAIgAhAMIAIgAhAMIAIgAhAMIAIgAhAMIAIgAhAMIAIgAhAMIAIgAhAMIAIgAhAMIAIgAhAMIAIgAhAMIAIgAhAMIAIgAhAMIAIgAhAMIAIgAhAMIAIgAhAMIAIgAhAMIAIgAhAMIAIgAhAMIAIgAhAMIAIgAhAMIAIgAhAMIAIgAhAMIAIgAhAMIAIgAhAMIAIgAhAMIAIgAhAMIAIgAhAMIAIgAhAMIAIgAhAMIAIgAhAMIAIgAhAMIAIgAhAMIAIgAhAMIAIgAhAMIAIgAhAMIAIgAhAMIAIgAhAMIAIgAhAMIAIgAhAMIAIgAhAMIAIgAhAMIAIgAhAMIAIgAiAFEA8gBEH4AGoiCSACKQIANwIAIAkgAikCCDcCCCAJIAIpAhA3AhAgCSACKQIYNwIYIAkgAikCIDcCIEEAIQYDQCAJIAkQDCAGQQFqIgZB2ABHDQALIAkgCSACEA8gAyAJKQIANwIAIAMgCSkCCDcCCCADIAkpAhA3AhAgAyAJKQIYNwIYIAMgCSkCIDcCICADIAMQDCADIAMQDCADIAMQDCADIAMQDCADIAMQDCADIAMQDCADIAMQDCADIAMQDCADIAMQDCADIAMQDCADIAMQDCADIAMQDCADIAMQDCADIAMQDCADIAMQDCADIAMQDCADIAMQDCADIAMQDCADIAMQDCADIAMQDCADIAMQDCADIAMQDCADIAMQDCADIAMQDCADIAMQDCADIAMQDCADIAMQDCADIAMQDCADIAMQDCADIAMQDCADIAMQDCADIAMQDCADIAMQDCADIAMQDCADIAMQDCADIAMQDCADIAMQDCADIAMQDCADIAMQDCADIAMQDCADIAMQDCADIAMQDCADIAMQDCADIAMQDCADIAMgBRAPIAggAykCADcCACAIIAMpAgg3AgggCCADKQIQNwIQIAggAykCGDcCGCAIIAMpAiA3AiAgCCAIEAwgCCAIEAwgCCAIEAwgCCAIIAoQDyAEIAgpAgA3AgAgBCAIKQIINwIIIAQgCCkCEDcCECAEIAgpAhg3AhggBCAIKQIgNwIgIAQgBBAMIAQgBBAMIAQgBBAMIAQgBBAMIAQgBBAMIAQgBBAMIAQgBBAMIAQgBBAMIAQgBBAMIAQgBBAMIAQgBBAMIAQgBBAMIAQgBBAMIAQgBBAMIAQgBBAMIAQgBBAMIAQgBBAMIAQgBBAMIAQgBBAMIAQgBBAMIAQgBBAMIAQgBBAMIAQgBBAMIAQgBCAHEA8gBCAEEAwgBCAEEAwgBCAEEAwgBCAEEAwgBCAEEAwgBCAEIAEQDyAEIAQQDCAEIAQQDCAEIAQQDCAEIAQgCxAPIAQgBBAMIAQgBBAMIAAgASAEEA8gDCQEC5wEAQJ/IAAgAUEkaiIDKAIAQQ52OgAAIAAgAygCAEEGdjoAASAAIAFBIGoiAigCAEEYdkEDcSADKAIAQQJ0cjoAAiAAIAIoAgBBEHY6AAMgACACKAIAQQh2OgAEIAAgAigCADoABSAAIAFBHGoiAigCAEESdjoABiAAIAIoAgBBCnY6AAcgACACKAIAQQJ2OgAIIAAgAUEYaiIDKAIAQRR2QT9xIAIoAgBBBnRyOgAJIAAgAygCAEEMdjoACiAAIAMoAgBBBHY6AAsgACABQRRqIgIoAgBBFnZBD3EgAygCAEEEdHI6AAwgACACKAIAQQ52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H0EANgIAIAdBDGoiICgCABANIQ4gIEEANgIAIAdBEGoiISgCABANIQQgIUEANgIAIAdBFGoiIygCABANIQUgI0EANgIAIAdBGGoiFCgCABANIQMgFEEANgIAIAdBHGoiHSgCABANIQIgHUEANgIAIAggEjYCACAIQQRqIiwgCTYCACAIQQhqIi0gDTYCACAIQQxqIi4gDjYCACAIQRBqIi8gBDYCACAIQRRqIjAgBTYCACAIQRhqIjEgAzYCACAIQRxqIisgAjYCACAHQeQAaiEPIAdBxAFqIhEoAgAiAkE/cSEFIBEgAkEgajYCACAHQYQBaiEGAkACQEHAACAFayIEQSBLBEAgCCECIAUhA0EgIQUMAQUgBiAFaiAIIAQQERogCCAEaiEDIA8gBhAQQSAgBGsiAkHAAEkEfyACIQUgAwUgBUGgf2oiBUEGdkEBdCEOIARBQGohBANAIAYgAykAADcAACAGIAMpAAg3AAggBiADKQAQNwAQIAYgAykAGDcAGCAGIAMpACA3ACAgBiADKQAoNwAoIAYgAykAMDcAMCAGIAMpADg3ADggA0FAayEDIA8gBhAQIAJBQGoiAkHAAE8NAAsgBUE/cSEFIAggDkEEakEFdGogBGoLIQIgBQRAQQAhAwwCCwsMAQsgBiADaiACIAUQERoLIAogESgCACICQR12QRh0NgIAIAogAkELdEGAgPwHcSACQRt0ciACQQV2QYD+A3FyIAJBFXZB/wFxcjYCBCARQTcgAmtBP3FBAWoiAyACajYCAAJAAkAgA0HAACACQT9xIgJrIgVJBEBBgAghBQwBBSAGIAJqQYAIIAUQERogBUGACGohAiAPIAYQECADIAVrIgNBwABPBEADQCAGIAIpAAA3AAAgBiACKQAINwAIIAYgAikAEDcAECAGIAIpABg3ABggBiACKQAgNwAgIAYgAikAKDcAKCAGIAIpADA3ADAgBiACKQA4NwA4IAJBQGshAiAPIAYQECADQUBqIgNBwABPDQALCyADBEAgAiEFQQAhAgwCCwsMAQsgBiACaiAFIAMQERoLIBEoAgAiAkE/cSEFIBEgAkEIajYCAAJAAkBBwAAgBWsiA0EISwRAIAohAkEIIQMMAQUgBiAFaiAKIAMQERogCiADaiECIA8gBhAQQQggA2siA0HAAE8EQANAIAYgAikAADcAACAGIAIpAAg3AAggBiACKQAQNwAQIAYgAikAGDcAGCAGIAIpACA3ACAgBiACKQAoNwAoIAYgAikAMDcAMCAGIAIpADg3ADggAkFAayECIA8gBhAQIANBQGoiA0HAAE8NAAsLIAMEQEEAIQUMAgsLDAELIAYgBWogAiADEBEaCyAPKAIAEA0hEiAPQQA2AgAgB0HoAGoiGCgCABANIQkgGEEANgIAIAdB7ABqIhooAgAQDSENIBpBADYCACAHQfAAaiIbKAIAEA0hDiAbQQA2AgAgB0H0AGoiHCgCABANIQQgHEEANgIAIAdB+ABqIhUoAgAQDSEFIBVBADYCACAHQfwAaiIXKAIAEA0hAyAXQQA2AgAgB0GAAWoiGSgCABANIQIgGUEANgIAIAAgEjYAICAAIAk2ACQgACANNgAoIAAgDjYALCAAIAQ2ADAgACAFNgA0IAAgAzYAOCAAIAI2ADwgByATECQgECgCACICQT9xIQQgECACQSBqNgIAIAdBIGohCQJAAkBBwAAgBGsiAkEgSwRAIAAhAiAEIQVBICEDDAEFIAkgBGogACACEBEaIAAgAmohBSAHIAkQEEEgIAJrIgNBwABJBH8gBQUgAEHkAGogBEGgf2oiDUFAcSIOQRxyIARraiE1IAMhAiAFIQMDQCAJIAMpAAA3AAAgCSADKQAINwAIIAkgAykAEDcAECAJIAMpABg3ABggCSADKQAgNwAgIAkgAykAKDcAKCAJIAMpADA3ADAgCSADKQA4NwA4IANBQGshAyAHIAkQECACQUBqIgJBwABPDQALIA0gDmshAyA1CyECIAMEQEEAIQUMAgsLDAELIAkgBWogAiADEBEaCyAKIBAoAgAiAkEddkEYdDYCACAKIAJBC3RBgID8B3EgAkEbdHIgAkEFdkGA/gNxciACQRV2Qf8BcXI2AgQgEEE3IAJrQT9xQQFqIgMgAmo2AgAgB0EgaiEEAkACQCADQcAAIAJBP3EiAmsiBUkEQEGACCEFDAEFIAQgAmpBgAggBRARGiAFQYAIaiECIAcgBBAQIAMgBWsiA0HAAE8EQANAIAQgAikAADcAACAEIAIpAAg3AAggBCACKQAQNwAQIAQgAikAGDcAGCAEIAIpACA3ACAgBCACKQAoNwAoIAQgAikAMDcAMCAEIAIpADg3ADggAkFAayECIAcgBBAQIANBQGoiA0HAAE8NAAsLIAMEQCACIQVBACECDAILCwwBCyAEIAJqIAUgAxARGgsgECgCACICQT9xIQUgECACQQhqNgIAIAdBIGohBAJAAkBBwAAgBWsiA0EISwRAIAohAkEIIQMMAQUgBCAFaiAKIAMQERogCiADaiECIAcgBBAQQQggA2siA0HAAE8EQANAIAQgAikAADcAACAEIAIpAAg3AAggBCACKQAQNwAQIAQgAikAGDcAGCAEIAIpACA3ACAgBCACKQAoNwAoIAQgAikAMDcAMCAEIAIpADg3ADggAkFAayECIAcgBBAQIANBQGoiA0HAAE8NAAsLIAMEQEEAIQUMAgsLDAELIAQgBWogAiADEBEaCyAHKAIAEA0hEiAHQQA2AgAgHigCABANIQkgHkEANgIAIB8oAgAQDSENIB9BADYCACAgKAIAEA0hDiAgQQA2AgAgISgCABANIQQgIUEANgIAICMoAgAQDSEFICNBADYCACAUKAIAEA0hAyAUQQA2AgAgHSgCABANIQIgHUEANgIAIAggEjYCACAsIAk2AgAgLSANNgIAIC4gDjYCACAvIAQ2AgAgMCAFNgIAIDEgAzYCACArIAI2AgAgESgCACICQT9xIQUgESACQSBqNgIAAkACQEHAACAFayIEQSBLBEAgCCECIAUhA0EgIQUMAQUgBiAFaiAIIAQQERogCCAEaiEDIA8gBhAQQSAgBGsiAkHAAEkEfyACIQUgAwUgBUGgf2oiBUEGdkEBdCEOIARBQGohBANAIAYgAykAADcAACAGIAMpAAg3AAggBiADKQAQNwAQIAYgAykAGDcAGCAGIAMpACA3ACAgBiADKQAoNwAoIAYgAykAMDcAMCAGIAMpADg3ADggA0FAayEDIA8gBhAQIAJBQGoiAkHAAE8NAAsgBUE/cSEFIAggDkEEakEFdGogBGoLIQIgBQRAQQAhAwwCCwsMAQsgBiADaiACIAUQERoLIAogESgCACICQR12QRh0NgIAIAogAkELdEGAgPwHcSACQRt0ciACQQV2QYD+A3FyIAJBFXZB/wFxcjYCBCARQTcgAmtBP3FBAWoiAyACajYCAAJAAkAgA0HAACACQT9xIgJrIgVJBEBBgAghBQwBBSAGIAJqQYAIIAUQERogBUGACGohAiAPIAYQECADIAVrIgNBwABPBEADQCAGIAIpAAA3AAAgBiACKQAINwAIIAYgAikAEDcAECAGIAIpABg3ABggBiACKQAgNwAgIAYgAikAKDcAKCAGIAIpADA3ADAgBiACKQA4NwA4IAJBQGshAiAPIAYQECADQUBqIgNBwABPDQALCyADBEAgAiEFQQAhAgwCCwsMAQsgBiACaiAFIAMQERoLIBEoAgAiAkE/cSEFIBEgAkEIajYCAAJAAkBBwAAgBWsiA0EISwRAIAohAkEIIQMMAQUgBiAFaiAKIAMQERogCiADaiECIA8gBhAQQQggA2siA0HAAE8EQANAIAYgAikAADcAACAGIAIpAAg3AAggBiACKQAQNwAQIAYgAikAGDcAGCAGIAIpACA3ACAgBiACKQAoNwAoIAYgAikAMDcAMCAGIAIpADg3ADggAkFAayECIA8gBhAQIANBQGoiA0HAAE8NAAsLIAMEQEEAIQUMAgsLDAELIAYgBWogAiADEBEaCyAPKAIAEA0hEiAPQQA2AgAgGCgCABANIQkgGEEANgIAIBooAgAQDSENIBpBADYCACAbKAIAEA0hDiAbQQA2AgAgHCgCABANIQQgHEEANgIAIBUoAgAQDSEFIBVBADYCACAXKAIAEA0hAiAXQQA2AgAgGSgCABANIQMgACASNgAAIABBBGoiFyAJNgAAIABBCGoiGSANNgAAIABBDGoiEiAONgAAIABBEGoiCSAENgAAIABBFGoiDSAFNgAAIABBGGoiBCACNgAAIABBHGoiAiADNgAAIBMhFSAAIQUgCCETIAAhDiACIRogFyEbIBkhHCASIRcgCSEZIA0hEiAEIQkgCAUgAEEgaiEVIAAhBSAIIRMgACEOIAhBHGohKyAAQRxqIRogCEEEaiEsIABBBGohGyAIQQhqIS0gAEEIaiEcIAhBDGohLiAAQQxqIRcgCEEQaiEvIABBEGohGSAIQRRqITAgAEEUaiESIAhBGGohMSAAQRhqIQkgCAshAyAHQSBqIQsCfyAKQQRqITcgB0EEaiEGIAdBCGohDyAHQQxqIRAgB0EQaiERIAdBFGohHiAHQRhqIR8gB0EcaiEgIAdBxAFqISIgB0GEAWohDCAKQQRqISMgB0HkAGohFiAHQegAaiElIAdB7ABqISYgB0HwAGohJyAHQfQAaiEoIAdB+ABqISkgB0H8AGohKiAHQYABaiEhIABBgAFqIRggByAVECQgB0HgAGoiFCgCACICQT9xIQ0gFCACQSBqNgIAAkACQEHAACANayICQSBLBEAgDSEEQSAhAgwBBSALIA1qIAUgAhARGiAAIAJqIQQgByALEBBBICACayICQcAASQR/IAQFIBggDUGgf2oiGEFAcSIVIA1raiE2IAIhACAEIQIDQCALIAIpAAA3AAAgCyACKQAINwAIIAsgAikAEDcAECALIAIpABg3ABggCyACKQAgNwAgIAsgAikAKDcAKCALIAIpADA3ADAgCyACKQA4NwA4IAJBQGshAiAHIAsQECAAQUBqIgBBwABPDQALIBggFWshAiA2CyEAIAIEQEEAIQQMAgsLDAELIAsgBGogACACEBEaCyAKIBQoAgAiAEEddkEYdDYCACA3CyAAQQt0QYCA/AdxIABBG3RyIABBBXZBgP4DcXIgAEEVdkH/AXFyNgIAIBRBNyAAa0E/cUEBaiICIABqNgIAAkACQCACQcAAIABBP3EiAGsiBEkEQEGACCEEDAEFIAsgAGpBgAggBBARGiAEQYAIaiEAIAcgCxAQIAIgBGsiAkHAAE8EQANAIAsgACkAADcAACALIAApAAg3AAggCyAAKQAQNwAQIAsgACkAGDcAGCALIAApACA3ACAgCyAAKQAoNwAoIAsgACkAMDcAMCALIAApADg3ADggAEFAayEAIAcgCxAQIAJBQGoiAkHAAE8NAAsLIAIEQCAAIQRBACEADAILCwwBCyALIABqIAQgAhARGgsgFCgCACIAQT9xIQQgFCAAQQhqNgIAAkACQEHAACAEayICQQhLBEAgCiEAQQghAgwBBSALIARqIAogAhARGiAKIAJqIQAgByALEBBBCCACayICQcAATwRAA0AgCyAAKQAANwAAIAsgACkACDcACCALIAApABA3ABAgCyAAKQAYNwAYIAsgACkAIDcAICALIAApACg3ACggCyAAKQAwNwAwIAsgACkAODcAOCAAQUBrIQAgByALEBAgAkFAaiICQcAATw0ACwsgAgRAQQAhBAwCCwsMAQsgCyAEaiAAIAIQERoLIAcoAgAQDSEUIAdBADYCACAGKAIAEA0hHSAGQQA2AgAgDygCABANIRggD0EANgIAIBAoAgAQDSEVIBBBADYCACARKAIAEA0hDSARQQA2AgAgHigCABANIQQgHkEANgIAIB8oAgAQDSECIB9BADYCACAgKAIAEA0hACAgQQA2AgAgEyAUNgIAICwgHTYCACAtIBg2AgAgLiAVNgIAIC8gDTYCACAwIAQ2AgAgMSACNgIAICsgADYCACAiKAIAIgBBP3EhBCAiIABBIGo2AgACQAJAQcAAIARrIgBBIEsEQCADIQAgBCECQSAhCAwBBSAMIARqIAMgABARGiAIIABqIQIgFiAMEBBBICAAayIAQcAASQR/IAAhCCACBSAIQYABaiAEQaB/aiINQUBxIhMgBGtqITggAiEIA0AgDCAIKQAANwAAIAwgCCkACDcACCAMIAgpABA3ABAgDCAIKQAYNwAYIAwgCCkAIDcAICAMIAgpACg3ACggDCAIKQAwNwAwIAwgCCkAODcAOCAIQUBrIQggFiAMEBAgAEFAaiIAQcAATw0ACyANIBNrIQggOAshACAIBEBBACECDAILCwwBCyAMIAJqIAAgCBARGgsgCiAiKAIAIgBBHXZBGHQ2AgAgIyAAQQt0QYCA/AdxIABBG3RyIABBBXZBgP4DcXIgAEEVdkH/AXFyNgIAICJBNyAAa0E/cUEBaiIIIABqNgIAAkACQCAIQcAAIABBP3EiAGsiAkkEQEGACCECDAEFIAwgAGpBgAggAhARGiACQYAIaiEAIBYgDBAQIAggAmsiCEHAAE8EQANAIAwgACkAADcAACAMIAApAAg3AAggDCAAKQAQNwAQIAwgACkAGDcAGCAMIAApACA3ACAgDCAAKQAoNwAoIAwgACkAMDcAMCAMIAApADg3ADggAEFAayEAIBYgDBAQIAhBQGoiCEHAAE8NAAsLIAgEQCAAIQJBACEADAILCwwBCyAMIABqIAIgCBARGgsgIigCACIAQT9xIQggIiAAQQhqNgIAQcAAIAhrIgJBCEsEQCAKIQAgCCEKQQghCAUgDCAIaiAKIAIQERogCiACaiEAIBYgDBAQQQggAmsiCEHAAE8EQANAIAwgACkAADcAACAMIAApAAg3AAggDCAAKQAQNwAQIAwgACkAGDcAGCAMIAApACA3ACAgDCAAKQAoNwAoIAwgACkAMDcAMCAMIAApADg3ADggAEFAayEAIBYgDBAQIAhBQGoiCEHAAE8NAAsLIAgEf0EABSAWKAIAEA0hDSAWQQA2AgAgJSgCABANIRMgJUEANgIAICYoAgAQDSEEICZBADYCACAnKAIAEA0hAyAnQQA2AgAgKCgCABANIQIgKEEANgIAICkoAgAQDSEKIClBADYCACAqKAIAEA0hCCAqQQA2AgAgISgCABANIQAgDiANNgAAIBsgEzYAACAcIAQ2AAAgFyADNgAAIBkgAjYAACASIAo2AAAgCSAINgAAIBogADYAACABIAUpAAA3AAAgASAFKQAINwAIIAEgBSkAEDcAECABIAUpABg3ABggMkEBNgIAICQkBA8LIQoLIAwgCmogACAIEBEaIBYoAgAQDSENIBZBADYCACAlKAIAEA0hEyAlQQA2AgAgJigCABANIQQgJkEANgIAICcoAgAQDSEDICdBADYCACAoKAIAEA0hAiAoQQA2AgAgKSgCABANIQogKUEANgIAICooAgAQDSEIICpBADYCACAhKAIAEA0hACAOIA02AAAgGyATNgAAIBwgBDYAACAXIAM2AAAgGSACNgAAIBIgCjYAACAJIAg2AAAgGiAANgAAIAEgBSkAADcAACABIAUpAAg3AAggASAFKQAQNwAQIAEgBSkAGDcAGCAyQQE2AgAgJCQECycBAn8jBCEDIwRBEGokBCADIAI2AgAgACABIAMQhQEhBCADJAQgBAuDAQICfwF+IACnIQIgAEL/////D1YEQANAIAFBf2oiASAAIABCCoAiBEIKfn2nQf8BcUEwcjoAACAAQv////+fAVYEQCAEIQAMAQsLIASnIQILIAIEQANAIAFBf2oiASACIAJBCm4iA0EKbGtBMHI6AAAgAkEKTwRAIAMhAgwBCwsLIAEL1RIBIH8CQCMEIQQjBEHgA2okBCABQfgAaiIZKAIABEAgACACKQIANwIAIAAgAikCCDcCCCAAIAIpAhA3AhAgACACKQIYNwIYIAAgAikCIDcCICAAIAIpAig3AiggACACKQIwNwIwIAAgAikCODcCOCAAQUBrIAJBQGspAgA3AgAgACACKQJINwJIIAAgAikCUDcCUCAAIAIpAlg3AlggACACKQJgNwJgIAAgAikCaDcCaCAAIAIpAnA3AnAgACACKAJ4NgJ4DAELIAIoAngEQCAAIAEpAgA3AgAgACABKQIINwIIIAAgASkCEDcCECAAIAEpAhg3AhggACABKQIgNwIgIAAgASkCKDcCKCAAIAEpAjA3AjAgACABKQI4NwI4IABBQGsgAUFAaykCADcCACAAIAEpAkg3AkggACABKQJQNwJQIAAgASkCWDcCWCAAIAEpAmA3AmAgACABKQJoNwJoIAAgASkCcDcCcCAAIAEoAng2AngMAQsgBEH4AGohDiAEQdAAaiEUIARBKGohCCAEIQUgAEH4AGoiFkEANgIAIARBuANqIgsgAkHQAGoiFxAMIARBkANqIgwgAUHQAGoiGBAMIARB6AJqIgcgASALEA8gBEHAAmoiCSACIAwQDyAEQZgCaiIKIAFBKGogCxAPIAogCiAXEA8gBEHwAWoiAyACQShqIAwQDyADIAMgGBAPQfz9//8AIAcoAgRrIRVB/P///wAgBygCCGshD0H8////ACAHKAIMayEQQfz///8AIAcoAhBrIRFB/P///wAgBygCFGshEkH8////ACAHKAIYayETQfz///8AIAcoAhxrIQtB/P///wAgBygCIGshDEH8//8HIAcoAiRrIQIgBEHIAWoiBiAJKAIAQbzh//8AIAcoAgBrajYCACAGIAkoAgQgFWo2AgQgBiAJKAIIIA9qNgIIIAYgCSgCDCAQajYCDCAGIAkoAhAgEWo2AhAgBiAJKAIUIBJqNgIUIAYgCSgCGCATajYCGCAGIAkoAhwgC2o2AhwgBiAJKAIgIAxqNgIgIAYgCSgCJCACajYCJEH8/f//ACAKKAIEayEVQfz///8AIAooAghrIQ9B/P///wAgCigCDGshEEH8////ACAKKAIQayERQfz///8AIAooAhRrIRJB/P///wAgCigCGGshE0H8////ACAKKAIcayELQfz///8AIAooAiBrIQxB/P//ByAKKAIkayECIARBoAFqIg0gAygCAEG84f//ACAKKAIAa2o2AgAgDSADKAIEIBVqNgIEIA0gAygCCCAPajYCCCANIAMoAgwgEGo2AgwgDSADKAIQIBFqNgIQIA0gAygCFCASajYCFCANIAMoAhggE2o2AhggDSADKAIcIAtqNgIcIA0gAygCICAMajYCICANIAMoAiQgAmo2AiQgBhAjRQRAIA4gDRAMIBQgBhAMIAggBiAUEA8gBiAGIBcQDyAAQdAAaiAYIAYQDyAFIAcgFBAPIAAgBSkCADcCACAAIAUpAgg3AgggACAFKQIQNwIQIAAgBSkCGDcCGCAAIAUpAiA3AiBB+Pv//wEgCEEEaiIaKAIAIABBBGoiBigCAEEBdGprIQ9B+P///wEgCEEIaiIbKAIAIABBCGoiAygCAEEBdGprIRBB+P///wEgCEEMaiIcKAIAIABBDGoiBygCAEEBdGprIRFB+P///wEgCEEQaiIdKAIAIABBEGoiCSgCAEEBdGprIRJB+P///wEgCEEUaiIeKAIAIABBFGoiFCgCAEEBdGprIRNB+P///wEgCEEYaiIfKAIAIABBGGoiFigCAEEBdGprIQtB+P///wEgCEEcaiIgKAIAIABBHGoiFygCAEEBdGprIQxB+P///wEgCEEgaiIhKAIAIABBIGoiGCgCAEEBdGprIQJB+P//DyAIQSRqIiIoAgAgAEEkaiIZKAIAQQF0amshASAAIA4oAgBB+ML//wEgCCgCACAAKAIAQQF0amtqIhU2AgAgBiAOKAIEIA9qIg82AgAgAyAOKAIIIBBqIhA2AgAgByAOKAIMIBFqIhE2AgAgCSAOKAIQIBJqIhI2AgAgFCAOKAIUIBNqIhM2AgAgFiAOKAIYIAtqIgs2AgAgFyAOKAIcIAxqIgw2AgAgGCAOKAIgIAJqIgI2AgAgGSAOKAIkIAFqIgE2AgAgAEEoaiIDIAUoAgBBtKT//wIgFWtqNgIAIABBLGoiByAFKAIEQfT5//8CIA9rajYCACAAQTBqIgkgBSgCCEH0////AiAQa2o2AgAgAEE0aiIUIAUoAgxB9P///wIgEWtqNgIAIABBOGoiFiAFKAIQQfT///8CIBJrajYCACAAQTxqIhcgBSgCFEH0////AiATa2o2AgAgAEFAayIYIAUoAhhB9P///wIgC2tqNgIAIABBxABqIhkgBSgCHEH0////AiAMa2o2AgAgAEHIAGoiFSAFKAIgQfT///8CIAJrajYCACAAQcwAaiIPIAUoAiRB9P//FyABa2o2AgAgAyADIA0QDyAIIAggChAPIAhBvOH//wAgCCgCAGsiEDYCACAaQfz9//8AIBooAgBrIhE2AgAgG0H8////ACAbKAIAayISNgIAIBxB/P///wAgHCgCAGsiEzYCACAdQfz///8AIB0oAgBrIgs2AgAgHkH8////ACAeKAIAayIMNgIAIB9B/P///wAgHygCAGsiBTYCACAgQfz///8AICAoAgBrIgI2AgAgIUH8////ACAhKAIAayIBNgIAICJB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H3EgEEEUdnJrNgIAIA1B/P///wAgBkESdEGAgPAfcSAFQQ52cms2AgAgCUH8////ACAUQRh0QYCAgBhxIAZBCHZyazYCACAlQfz///8AIBRBAnZB////H3FrNgIAICNB/P///wAgE0EEdEHw//8fcSAUQRx2cms2AgAgBEH8////ACAMQQp0QYD4/x9xIBNBFnZyazYCACABQfz///8AICRBEHRBgID8H3EgDEEQdnJrNgIAIBVB/P//ByAkQQp2azYCACAIIAhBkJ8EEA8gACAAIAgQIiAmJAQLrwMBAX8gACABQRxqIgIoAgBBGHY6AAAgACACKAIAQRB2OgABIAAgAigCAEEIdjoAAiAAIAIoAgA6AAMgACABQRhqIgIoAgBBGHY6AAQgACACKAIAQRB2OgAFIAAgAigCAEEIdjoABiAAIAIoAgA6AAcgACABQRRqIgIoAgBBGHY6AAggACACKAIAQRB2OgAJIAAgAigCAEEIdjoACiAAIAIoAgA6AAsgACABQRBqIgIoAgBBGHY6AAwgACACKAIAQRB2OgANIAAgAigCAEEIdjoADiAAIAIoAgA6AA8gACABQQxqIgIoAgBBGHY6ABAgACACKAIAQRB2OgARIAAgAigCAEEIdjoAEiAAIAIoAgA6ABMgACABQQhqIgIoAgBBGHY6ABQgACACKAIAQRB2OgAVIAAgAigCAEEIdjoAFiAAIAIoAgA6ABcgACABQQRqIgIoAgBBGHY6ABggACACKAIAQRB2OgAZIAAgAigCAEEIdjoAGiAAIAIoAgA6ABsgACABKAIAQRh2OgAcIAAgASgCAEEQdjoAHSAAIAEoAgBBCHY6AB4gACABKAIAOgAfCwoAIABBUGpBCkkLigUCEX8BfiMEIQwjBEEgaiQEIABBAEGEBBAeGiAMIgMgASkCADcCACADIAEpAgg3AgggAyABKQIQNwIQIAMgASkCGDcCGCADQRxqIgUoAgAiBEF/SgR/QQEFIAMgAygCACIGIARyIANBBGoiBygCACIJciADQQhqIggoAgAiCnIgA0EMaiILKAIAIg1yIANBEGoiDigCACIPciADQRRqIhAoAgAiEXIgA0EYaiISKAIAIhNyQQBHQR90QR91IgEgBkF/c61CwoLZgQ18IhSncTYCACAHIAEgCUF/c61CjL3J/gt8IBRCIIh8IhSn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cyAVQbvAovp6S3EgFnIiFUEBcyADQYy9yf57SXEgC3JBf3MiCyADQYy9yf57S3EgFXIgCyAgQcCC2YF9S3FyIDVCIIinaiIDQb/9pv4CbK18Ijo+AgAgECA0Qv////8PgyADQfPCtoEEbK18IDpCIIh8IjQ+AgAgDiA3Qv////8PgyADQcS/3YUFbK18IDRCIIh8IjQ+AgAgDyA4Qv////8PgyADQZnGxKoEbK18IDRCIIh8IjQ+AgAgFCA5Qv////8PgyADrXwgNEIgiHwiND4CACAbIDRCIIggM0L/////D4N8IjM+AgAgISAzQiCIIDZC/////w+DfCIzPgIAIB4gM0IgiKcgNadqNgIAIA1ByAhqIgMgDUFAayANQQUQMDYCACANQcwIaiANQcQEaiASQQUQMCISNgIAIAMoAgAiA0EAIANBAEobIRAgBSATIAIgLSgCAEH8AGxqEEIgCUHMBGoiAiAFQeQGaiIDKQIANwIAIAIgAykCCDcCCCACIAMpAhA3AhAgAiADKQIYNwIYIAIgAykCIDcCICAJQfQEaiIDIAVBjAdqIgspAgA3AgAgAyALKQIINwIIIAMgCykCEDcCECADIAspAhg3AhggAyALKQIgNwIgIAlBmAVqIg8oAgAiFEEWdiIOQdEHbCADKAIAaiELIA5BBnQgCUH4BGoiGygCAGogC0EadmoiIUEadiAJQfwEaiIeKAIAaiIVQRp2IAlBgAVqIhYoAgBqIhdBGnYgCUGEBWoiHygCAGoiIEEadiAJQYgFaiIiKAIAaiIaQRp2IAlBjAVqIh0oAgBqIidBGnYgCUGQBWoiKCgCAGoiKUEadiAJQZQFaiIIKAIAaiEOIAMgC0H///8fcTYCACAbICFB////H3E2AgAgHiAVQf///x9xNgIAIBYgF0H///8fcTYCACAfICBB////H3E2AgAgIiAaQf///x9xNgIAIB0gJ0H///8fcTYCACAoIClB////H3E2AgAgCCAOQf///x9xNgIAIA8gDkEadiAUQf///wFxajYCACAjIAVBtAdqIgMpAgA3AgAgIyADKQIINwIIICMgAykCEDcCECAjIAMpAhg3AhggIyADKQIgNwIgIAlBADYCnAUgByATQZgCaiIDKQIANwIAIAcgAykCCDcCCCAHIAMpAhA3AhAgByADKQIYNwIYIAcgAykCIDcCICAGIAcQDCAMIAYgBxAPIAlB+ANqIAVB6AVqIAYQDyAJQaAEaiAFQZAGaiAMEA8gCSAFKALgBjYCyAQgByAHIBNB8AFqEA8gBiAHEAwgDCAGIAcQDyAJQaQDaiAFQewEaiAGEA8gCUHMA2ogBUGUBWogDBAPIAkgBSgC5AU2AvQDIAcgByATQcgBahAPIAYgBxAMIAwgBiAHEA8gCUHQAmogBUHwA2ogBhAPIAlB+AJqIAVBmARqIAwQDyAJIAUoAugENgKgAyAHIAcgE0GgAWoQDyAGIAcQDCAMIAYgBxAPIAlB/AFqIAVB9AJqIAYQDyAJQaQCaiAFQZwDaiAMEA8gCSAFKALsAzYCzAIgByAHIBNB+ABqEA8gBiAHEAwgDCAGIAcQDyAJQagBaiAFQfgBaiAGEA8gCUHQAWogBUGgAmogDBAPIAkgBSgC8AI2AvgBIAcgByATQdAAahAPIAYgBxAMIAwgBiAHEA8gCUHUAGogBUH8AGogBhAPIAlB/ABqIAVBpAFqIAwQDyAJIAUoAvQBNgKkASAHIAcgE0EoahAPIAYgBxAMIAwgBiAHEA8gCSAFIAYQDyAJQShqIAVBKGogDBAPIAkgBSgCeDYCUCARIAkpAwA3AwAgESAJKQMINwMIIBEgCSkDEDcDECARIAkpAxg3AxggESAJKQMgNwMgIBEgCSkDKDcDKCARIAkpAzA3AzAgESAJKQM4NwM4IBFBQGsgCUFAaykDADcDACARIAkpA0g3A0ggESAJKAJQNgJQIBEgEUGQnwQQDyARQdQAaiIDIAlB1ABqIgcpAgA3AgAgAyAHKQIINwIIIAMgBykCEDcCECADIAcpAhg3AhggAyAHKQIgNwIgIAMgBykCKDcCKCADIAcpAjA3AjAgAyAHKQI4NwI4IANBQGsgB0FAaykCADcCACADIAcpAkg3AkggAyAHKAJQNgJQIAMgA0GQnwQQDyARQagBaiIDIAlBqAFqIgcpAwA3AwAgAyAHKQMINwMIIAMgBykDEDcDECADIAcpAxg3AxggAyAHKQMgNwMgIAMgBykDKDcDKCADIAcpAzA3AzAgAyAHKQM4NwM4IANBQGsgB0FAaykDADcDACADIAcpA0g3A0ggAyAHKAJQNgJQIAMgA0GQnwQQDyARQfwBaiIDIAlB/AFqIgcpAgA3AgAgAyAHKQIINwIIIAMgBykCEDcCECADIAcpAhg3AhggAyAHKQIgNwIgIAMgBykCKDcCKCADIAcpAjA3AjAgAyAHKQI4NwI4IANBQGsgB0FAaykCADcCACADIAcpAkg3AkggAyAHKAJQNgJQIAMgA0GQnwQQDyARQdACaiIDIAlB0AJqIgcpAwA3AwAgAyAHKQMINwMIIAMgBykDEDcDECADIAcpAxg3AxggAyAHKQMgNwMgIAMgBykDKDcDKCADIAcpAzA3AzAgAyAHKQM4NwM4IANBQGsgB0FAaykDADcDACADIAcpA0g3A0ggAyAHKAJQNgJQIAMgA0GQnwQQDyARQaQDaiIDIAlBpANqIgcpAgA3AgAgAyAHKQIINwIIIAMgBykCEDcCECADIAcpAhg3AhggAyAHKQIgNwIgIAMgBykCKDcCKCADIAcpAjA3AjAgAyAHKQI4NwI4IANBQGsgB0FAaykCADcCACADIAcpAkg3AkggAyAHKAJQNgJQIAMgA0GQnwQQDyARQfgDaiIDIAlB+ANqIgcpAwA3AwAgAyAHKQMINwMIIAMgBykDEDcDECADIAcpAxg3AxggAyAHKQMgNwMgIAMgBykDKDcDKCADIAcpAzA3AzAgAyAHKQM4NwM4IANBQGsgB0FAaykDADcDACADIAcpA0g3A0ggAyAHKAJQNgJQIAMgA0GQnwQQDyARQcwEaiIDIAIpAgA3AgAgAyACKQIINwIIIAMgAikCEDcCECADIAIpAhg3AhggAyACKQIgNwIgIAMgAikCKDcCKCADIAIpAjA3AjAgAyACKQI4NwI4IANBQGsgAkFAaykCADcCACADIAIpAkg3AkggAyACKAJQNgJQIAMgA0GQnwQQD0EBIR1BACEnIBIgECASIBBKGwwBCyAjQQE2AgAgI0EEaiICQgA3AgAgAkIANwIIIAJCADcCECACQgA3AhggAkEANgIgQQAhHUEBISdBAAshAiAEBH8gGCAEKAIANgIAIBggBCgCBDYCBCAYIAQoAgg2AgggGCAEKAIMNgIMIBhBEGoiA0IANwIAIANCADcCCCAZIAQoAhA2AgAgGSAEKAIUNgIEIBkgBCgCGDYCCCAZIAQoAhw2AgwgGUEQaiIDQgA3AgAgA0IANwIIIDEgGEEPEDAhAyAyIBlBDxAwIgQhKCAEIAMgAiADIAJKGyICIAQgAkob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OCgCACI+QRZ2Ig9B0QdsICcoAgBqITkgD0EGdCBAKAIAaiA5QRp2aiItQRp2IEEoAgBqIi5BGnYgMigCAGoiL0EadiAzKAIAaiIjQRp2IDQoAgBqIitBGnYgNSgCAGoiHEEadiA2KAIAaiIPQRp2IDcoAgBqITogJ0G84f//ACA5Qf///x9xazYCACBAQfz9//8AIC1B////H3FrNgIAIEFB/P///wAgLkH///8fcWs2AgAgMkH8////ACAvQf///x9xazYCACAzQfz///8AICNB////H3FrNgIAIDRB/P///wAgK0H///8fcWs2AgAgNUH8////ACAcQf///x9xazYCACA2Qfz///8AIA9B////H3FrNgIAIDdB/P///wAgOkH///8fcWs2AgAgOEH8//8HIDpBGnYgPkH///8BcWprNgIACyAiKAIAIg9BP3EhHCAiIA9BAWo2AgACQAJAQcAAIBxrIg9BAUsEQEEBIQ8MAQUgHSAcaiAIIA8QERogCCAPaiEIIBcgHRAQQQEgD2siD0HAAE8EQANAIB0gCCkAADcAACAdIAgpAAg3AAggHSAIKQAQNwAQIB0gCCkAGDcAGCAdIAgpACA3ACAgHSAIKQAoNwAoIB0gCCkAMDcAMCAdIAgpADg3ADggCEFAayEIIBcgHRAQIA9BQGoiD0HAAE8NAAsLIA8EQEEAIRwMAgsLDAELIB0gHGogCCAPEBEaCyAiKAIAIghBP3EhHCAiIAhBIGo2AgACQAJAQcAAIBxrIg9BIEsEQCApIQhBICEPDAEFIB0gHGogKSAPEBEaICkgD2ohCCAXIB0QEEEgIA9rIg9BwABPBEADQCAdIAgpAAA3AAAgHSAIKQAINwAIIB0gCCkAEDcAECAdIAgpABg3ABggHSAIKQAgNwAgIB0gCCkAKDcAKCAdIAgpADA3ADAgHSAIKQA4NwA4IAhBQGshCCAXIB0QECAPQUBqIg9BwABPDQALCyAPBEBBACEcDAILCwwBCyAdIBxqIAggDxARGgsgKCAYQfwAbGogPygCADYCeCAoIBhB/ABsaiIIIB8pAgA3AgAgCCAfKQIINwIIIAggHykCEDcCECAIIB8pAhg3AhggCCAfKQIgNwIgICggGEH8AGxqQShqIgggJykCADcCACAIICcpAgg3AgggCCAnKQIQNwIQIAggJykCGDcCGCAIICcpAiA3AiAgKCAYQfwAbGpBATYCUCAoIBhB/ABsakHUAGoiCEIANwIAIAhCADcCCCAIQgA3AhAgCEIANwIYIAhBADYCICAbIBsgH0EAEB8gLCATQSBqIg82AgAgOyASQQJ0aigCACAYaiEIIBJBAWoiEyAWSQRAIAghGCATIRIgDyETDAIFIAghEyAPIQgMBAsACwsMAgshEwsgG0HMAGoicCgCACIvQRZ2Ig9B0QdsIBtBKGoicSgCAGohLSAPQQZ0IBtBLGoicigCAGogLUEadmoiI0EadiAbQTBqInMoAgBqIitBGnYgG0E0aiJ0KAIAaiIpQRp2IBtBOGoidSgCAGoiHEEadiAbQTxqInYoAgBqIhhBGnYgG0FAayJ3KAIAaiISQRp2IBtBxABqIngoAgBqIg9BGnYgG0HIAGoieSgCAGohLiBxQbzh//8AIC1B////H3FrNgIAIHJB/P3//wAgI0H///8fcWs2AgAgc0H8////ACArQf///x9xazYCACB0Qfz///8AIClB////H3FrNgIAIHVB/P///wAgHEH///8fcWs2AgAgdkH8////ACAYQf///x9xazYCACB3Qfz///8AIBJB////H3FrNgIAIHhB/P///wAgD0H///8fcWs2AgAgeUH8////ACAuQf///x9xazYCACBwQfz//wcgLkEadiAvQf///wFxams2AgAgKCATQfwAbGogGyAJQQAQHyAoIBNB/ABsaigCeA0AICggFSgCACA7IDwgDhA8IDsgFkECdGooAgAiPSATaiETIAogCGohHCAsIAhBIGoiCDYCAAJAIBMEQEEAIQ8CQAJAA0ACQCAZIA9BBXRqIAogCGogMRAVIDEoAgANACAIQSBqIQggD0EBaiIPIBNJDQEMAgsLDAELICwgCDYCAAwCCyAsIAg2AgAMAgsLIAggC0cNACAMBEAgIigCACILQT9xIQggIiALIA1qNgIAQcAAIAhrIgsgDU0EQCAXQSBqIg8gCGogDCALEBEaIAwgC2ohDCAXIA8QECANIAtrIg1BwABJBEBBACEIBQNAIA8gDCkAADcAACAPIAwpAAg3AAggDyAMKQAQNwAQIA8gDCkAGDcAGCAPIAwpACA3ACAgDyAMKQAoNwAoIA8gDCkAMDcAMCAPIAwpADg3ADggDEFAayEMIBcgDxAQIA1BQGoiDUHAAE8NAEEAIQgLCwsgDQRAIBdBIGogCGogDCANEBEaCwsgJCAiKAIAIghBHXZBGHQ2AgAgJCAIQQt0QYCA/AdxIAhBG3RyIAhBBXZBgP4DcXIgCEEVdkH/AXFyNgIEICJBNyAIa0E/cUEBaiILIAhqNgIAIBdBIGohDQJAAkAgC0HAACAIQT9xIghrIgxJBEBBgAghDAwBBSANIAhqQYAIIAwQERogDEGACGohCCAXIA0QECALIAxrIgtBwABPBEADQCANIAgpAAA3AAAgDSAIKQAINwAIIA0gCCkAEDcAECANIAgpABg3ABggDSAIKQAgNwAgIA0gCCkAKDcAKCANIAgpADA3ADAgDSAIKQA4NwA4IAhBQGshCCAXIA0QECALQUBqIgtBwABPDQALCyALBEAgCCEMQQAhCAwCCwsMAQsgDSAIaiAMIAsQERoLICIoAgAiCEE/cSEMICIgCEEIajYCACAXQSBqIQ0CQAJAQcAAIAxrIgtBCEsEQCAkIQhBCCELDAEFIA0gDGogJCALEBEaICQgC2ohCCAXIA0QEEEIIAtrIgtBwABPBEADQCANIAgpAAA3AAAgDSAIKQAINwAIIA0gCCkAEDcAECANIAgpABg3ABggDSAIKQAgNwAgIA0gCCkAKDcAKCANIAgpADA3ADAgDSAIKQA4NwA4IAhBQGshCCAXIA0QECALQUBqIgtBwABPDQALCyALBEBBACEMDAILCwwBCyANIAxqIAggCxARGgsgFygCABANIRggF0EANgIAIEwoAgAQDSESIExBADYCACBNKAIAEA0hEyBNQQA2AgAgTigCABANIQ8gTkEANgIAIE8oAgAQDSENIE9BADYCACBQKAIAEA0hDCBQQQA2AgAgUSgCABANIQsgUUEANgIAIFIoAgAQDSEIIFJBADYCACAQIBg2AgAgUyASNgIAIFQgEzYCACBVIA82AgAgViANNgIAIFcgDDYCACBYIAs2AgAgWSAINgIAIAAgWkEAIAZBAEciABsgHCAZICggOyA8IBBBIBBAIXogACB6QQBHcUUEQCAaJAQgeg8LIAFFDQAgFkECdCEnIENBAEGAIBAeGiAwIB4gQyA7IDwgBiAJIAogJSAOEDsaICBCADcCACAgQgA3AgggIEIANwIQICBCADcCGAJ/IDxBAUYgOygCAEEBRnEEQCAZKAIEIg0gGSgCACIMciAZKAIIIgtyIBkoAgwiCnIgGSgCECIIciAZKAIUIgZyIBkoAhgiBHIgGSgCHCIAckEAR0EfdEEfdSEYIARBf3OtQv////8PfCAGQX9zrUL/////D3wgCEF/c61C/v///w98IApBf3OtQua5u9ULfCALQX9zrUK7wKL6CnwgDEF/c61CwoLZgQ18IoEBQiCIQoy9yf4LhCANQX9zrXwiggFCIIh8IoMBQiCIfCKEAUIgiHwif0IgiHwigAFCIIh8IYYBICAgHigCAK0gGCCBAadxrXwihwGnIg82AgAgIEEEaiINIIcBQiCIIBggggGnca18IB4oAgStfCKBAaciEjYCACAgQQhqIgwgHigCCK0gGCCDAadxrXwggQFCIIh8IoIBpyITNgIAICBBDGoiCyAeKAIMrSCEAacgGHGtfCCCAUIgiHwigwGnIhA2AgAgIEEQaiIKIB4oAhCtIH+nIBhxrXwggwFCIIh8IoQBpyIENgIAICBBFGoiCCAeKAIUrSCAAacgGHGtfCCEAUIgiHwiiAE+AgAgIEEYaiIGIB4oAhitIIYBpyAYca18IIgBQiCIfCKFAT4CACAgIIcBQv////8PgyAEQX5JIIUBIIgBgyAeKAIcrSAAQX9zrUL/////D3wghgFCIIh8pyAYca18IIUBQiCIfCJ/g6dBf0dyIgBBAXMgBEF/RnEiBEEBcyAQQea5u9V7SXEgAHIiAEEBcyAQQea5u9V7S3EgBHIiBEEBcyATQbvAovp6SXEgAHIiAEEBcyATQbvAovp6S3EgBHIiBEEBcyASQYy9yf57SXEgAHJBf3MiACASQYy9yf57S3EgBHIgACAPQcCC2YF9S3FyIH9CIIinaiIAQb/9pv4CbK18IoABPgIAIA0ggQFC/////w+DIABB88K2gQRsrXwggAFCIIh8IoABPgIAIAwgggFC/////w+DIABBxL/dhQVsrXwggAFCIIh8IoABPgIAIAsggwFC/////w+DIABBmcbEqgRsrXwggAFCIIh8IoABPgIAIAoghAFC/////w+DIACtfCCAAUIgiHwigAE+AgAgCCCAAUIgiCCIAUL/////D4N8IoABPgIAIAYggAFCIIgghQFC/////w+DfCKAAT4CACAgIIABQiCIpyB/p2o2AhwgFCBaEEQgJCAgIBQQEiAg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H3RBH3UhIyAPICMgDUF/c61CwoLZgQ18In+ncSIPNgIAICsgIyAlQX9zrUKMvcn+C3wgf0IgiHwif6dxIg02AgAgKSAjIAxBf3OtQrvAovoKfCB/QiCIfCJ/p3EiDDYCACAcICMgC0F/c61C5rm71Qt8IH9CIIh8In+ncSILNgIAIBggCkF/c61C/v///w98IH9CIIh8In+nICNxIgo2AgAgEiAIQX9zrUL/////D3wgf0IgiHwif6cgI3EiCDYCACATIAZBf3OtQv////8PfCB/QiCIfCJ/pyAjcSIGNgIAIBAgAEF/c61C/////w98IH9CIIh8pyAjcSIANgIAICAgISgCAK0gD618In+nIhA2AgAgIEEEaiIPIEYoAgCtIA2tfCB/QiCIfCKHAaciHDYCACAgQQhqIg0gRygCAK0gDK18IIcBQiCIfCKBAaciGDYCACAgQQxqIgwgSCgCAK0gC618IIEBQiCIfCKCAaciEjYCACAgQRBqIgsgSSgCAK0gCq18IIIBQiCIfCKDAaciEzYCACAgQRRqIgogSigCAK0gCK18IIMBQiCIfCKFAT4CACAgQRhqIgggSygCAK0gBq18IIUBQiCIfCKGAT4CACAgIH9C/////w+DIBNBfkkghgEghQGDICwoAgCtIACtfCCGAUIgiHwihAGDp0F/R3IiAEEBcyATQX9GcSIGQQFzIBJB5rm71XtJcSAAciIAQQFzIBJB5rm71XtLcSAGciIGQQFzIBhBu8Ci+npJcSAAciIAQQFzIBhBu8Ci+npLcSAGciIGQQFzIBxBjL3J/ntJcSAAckF/cyIAIBxBjL3J/ntLcSAGciAAIBBBwILZgX1LcXIghAFCIIinaiIAQb/9pv4CbK18In8+AgAgDyCHAUL/////D4MgAEHzwraBBGytfCB/QiCIfCJ/PgIAIA0ggQFC/////w+DIABBxL/dhQVsrXwgf0IgiHwifz4CACAMIIIBQv////8PgyAAQZnGxKoEbK18IH9CIIh8In8+AgAgCyCDAUL/////D4MgAK18IH9CIIh8In8+AgAgCiB/QiCIIIUBQv////8Pg3wifz4CACAIIH9CIIgghgFC/////w+DfCJ/PgIAICAgf0IgiKcghAGnajYCHAJAIARBAEcgBUEARyIAcQRAIAUoAgBFDQEgPARAIBRBBGohTSAU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AAwCCyAEIAxqIBM6AAAgAEEdaiIMIAUoAgBPBEAgDCEADAILIAQgDGogEDoAACAAQR5qIgwgBSgCAE8EQCAMIQAMAgsgBCAMaiAPOgAAIABBH2oiDCAFKAIATwRAIAwhAAwCCyAEIAxqIA06AAAgAEEgaiEACwsgCEEBaiEIIApBAWoiCiAoRw0ACyAGIChqIQYLIAtBAWoiCCA8RwRAIAghCwwBCwsFQQAhAAsgBSAANgIAIENBAEGAIBAeGiAeQQBBgCAQHhogMEEAQYAIEB4aICFCADcCACAhQgA3AgggIUIANwIQICFCADcCGEEADAMLC0EAIABFDQEaIAVBADYCAAtBAAsiAA0AIH4pAwAggAF+IAcpAwB8IYABIAEgGyAgECcgEUIANwMAIBFCADcDCCARQgA3AxAgESCAAUI4iDwAGCARIIABQjCIPAAZIBEggAFCKIg8ABogESCAAUIgiDwAGyARIIABQhiIPAAcIBEggAFCEIg8AB0gESCAAUIIiDwAHiARIIABPAAfICQgEUEAEBUgFCAOICRBwAAQLSAbIBsgFBAsICooAgANACBwKAIAIgpBFnYiAEHRB2wgcSgCAGohDCAAQQZ0IHIoAgBqIAxBGnZqIghBGnYgcygCAGoiB0EadiB0KAIAaiIGQRp2IHUoAgBqIgVBGnYgdigCAGoiBEEadiB3KAIAaiIBQRp2IHgoAgBqIgBBGnYgeSgCAGohCyBxQbzh//8AIAxB////H3FrNgIAIHJB/P3//wAgCEH///8fcWs2AgAgc0H8////ACAHQf///x9xazYCACB0Qfz///8AIAZB////H3FrNgIAIHVB/P///wAgBUH///8fcWs2AgAgdkH8////ACAEQf///x9xazYCACB3Qfz///8AIAFB////H3FrNgIAIHhB/P///wAgAEH///8fcWs2AgAgeUH8////ACALQf///x9xazYCACBwQfz//wcgC0EadiAKQf///wFxams2AgAgGyAbIAlBABAfICooAgBFDQAgAgRAIAIgIBAuCyADBEAgAyCAATcDAAsgGiQEIHoPCyAaJARBAAudBAIFfwJ+AkAgB0HBAEkNACAGIAAoAgAiCGoiCi0AACIJQYABcQ0AAn8gCUEgcSEMIAFBfzYCACACQQA2AgAgCUHAAHEEfyABIAosAABBH3EiCTYC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jQFGBEAgKiQEICAPCwsLICUgLyALajYCAEHAACAvQT9xIgxrIg0gC0sEQCAKIQEgDCENIAshDAUgGkEgaiIVIAxqIAogDRARGiAKIA1qIQEgGiAVEBAgCyANayIMQcAASQRAQQAhDQUDQCAVIAEpAAA3AAAgFSABKQAINwAIIBUgASkAEDcAECAVIAEpABg3ABggFSABKQAgNwAgIBUgASkAKDcAKCAVIAEpADA3ADAgFSABKQA4NwA4IAFBQGshASAaIBUQECAMQUBqIgxBwABPDQBBACENCwsLIAwEQCAaQSBqIA1qIAEgDBARGgsgGSAlKAIAIgFBHXZBGHQ2AgAgGSABQQt0QYCA/AdxIAFBG3RyIAFBBXZBgP4DcXIgAUEVdkH/AXFyNgIEICVBNyABa0E/cUEBaiIMIAFqNgIAIBpBIGohFQJAAkAgDEHAACABQT9xIgFrIg1JBEBBgAghDQwBBSAVIAFqQYAIIA0QERogDUGACGohASAaIBUQECAMIA1rIgxBwABPBEADQCAVIAEpAAA3AAAgFSABKQAINwAIIBUgASkAEDcAECAVIAEpABg3ABggFSABKQAgNwAgIBUgASkAKDcAKCAVIAEpADA3ADAgFSABKQA4NwA4IAFBQGshASAaIBUQECAMQUBqIgxBwABPDQALCyAMBEAgASENQQAhAQwCCwsMAQsgFSABaiANIAwQERoLICUoAgAiAUE/cSENICUgAUEIajYCACAaQSBqIRUCQAJAQcAAIA1rIgxBCEsEQCAZIQFBCCEMDAEFIBUgDWogGSAMEBEaIBkgDGohASAaIBUQEEEIIAxrIgxBwABPBEADQCAVIAEpAAA3AAAgFSABKQAINwAIIBUgASkAEDcAECAVIAEpABg3ABggFSABKQAgNwAgIBUgASkAKDcAKCAVIAEpADA3ADAgFSABKQA4NwA4IAFBQGshASAaIBUQECAMQUBqIgxBwABPDQALCyAMBEBBACENDAILCwwBCyAVIA1qIAEgDBARGgsgGigCABANIREgGkEANgIAIEYoAgAQDSErIEZBADYCACBJKAIAEA0hPyBJQQA2AgAgSigCABANIUAgSkEANgIAIEsoAgAQDSEVIEtBADYCACBMKAIAEA0hDSBMQQA2AgAgTSgCABANIQwgTUEANgIAIE4oAgAQDSEBIE5BADYCACACIBE2AAAgAiArNgAEIAIgPzYACCACIEA2AAwgAiAVNgAQIAIgDTYAFCACIAw2ABggAiABNgAcAkAgdEUEQCAQQQRqIR8gEEEIaiEgIBBBDGohISAQQRBqISIgEEEUaiEjIBBBGGohJSAQQRxqIUkgEEHgAGohLSAQQSBqIRMgC0EgaiFSIAtBIEkhUyAZQQRqIVQgDkEEaiEsIA5BCGohLyAOQQxqITAgDkEQaiExIA5BFGohMiAOQRhqITMgDkEcaiE0IBtBBGohSiAbQQhqIUsgG0EMaiFMIBtBEGohTSAbQRRqIU4gG0EYaiFPIBtBHGohUCAWQfgAaiFVIBRB0ABqIVYgFkHQAGohDyAWQShqIUIgFkHUAGohGiAUQShqIUMgDkEBaiFXIBRBJGohWCAOQQJqIVkgFEEgaiFaIA5BA2ohWyAOQQVqIVwgDkEGaiFdIBRBHGohXiAOQQdqIV8gDkEJaiFgIBRBGGohYSAOQQpqIWIgDkELaiFjIBRBFGohZCAOQQ1qIWUgDkEOaiFmIA5BD2ohZyAUQRBqIWggDkERaiFpIA5BEmohaiAOQRNqIWsgFEEMaiFsIA5BFWohbSAOQRZqIW4gFEEIaiFvIA5BF2ohcCAOQRlqIXEgFEEEaiFyIA5BGmohcyAOQRtqIXQgDkEdaiF1IA5BHmohdiAOQR9qIXcgDkEgaiF4IBBBBGohNSAQQQhqITYgEEEMaiE3IBBBEGohOCAQQRRqITkgEEEYaiE6IBBBHGohUSAQQeAAaiEuIAtBIWoheSALQR9JIXogGUEEaiF7IBBBQGshHCAKQSBqIT8gC0FgaiJAQcAASSF8IBBBIGoiEkEhaiFIIApBH2ohFSALQWFqIg1BwABJIX1BACEXQQAhKwNAAkAgEEHnzKfQBjYCACAfQYXdntt7NgIAICBB8ua74wM2AgAgIUG66r+qejYCACAiQf+kuYgFNgIAICNBjNGV2Hk2AgAgJUGrs4/8ATYCACBJQZmag98FNgIAIB4gFxANIj42AgAgJEEANgIAIBMgAikAADcAACATIAIpAAg3AAggEyACKQAQNwAQIBMgAikAGDcAGCAtIFI2AgAgUwRAIAohAUEgIREgCyEMBSAcIAopAAA3AAAgHCAKKQAINwAIIBwgCikAEDcAECAcIAopABg3ABggECATEBAgfARAID8hAUEAIREgQCEMBSBAIQwgPyEBA0AgEyABKQAANwAAIBMgASkACDcACCATIAEpABA3ABAgEyABKQAYNwAYIBMgASkAIDcAICATIAEpACg3ACggEyABKQAwNwAwIBMgASkAODcAOCABQUBrIQEgECATEBAgDEFAaiIMQcAATw0AC0EAIRELCyAMBEAgEyARaiABIAwQERoLIC0oAgAiAUE/cSERIC0gAUEEajYCAAJAAkBBwAAgEWsiDEEESwRAIB4hAUEEIQwMAQUgEyARaiAeIAwQERogHiAMaiEBIBAgExAQQQQgDGsiDEHAAE8EQANAIBMgASkAADcAACATIAEpAAg3AAggEyABKQAQNwAQIBMgASkAGDcAGCATIAEpACA3ACAgEyABKQAoNwAoIBMgASkAMDcAMCATIAEpADg3ADggAUFAayEBIBAgExAQIAxBQGoiDEHAAE8NAAsLIAwEQEEAIREMAgsLDAELIBMgEWogASAMEBEaCyAtKAIAIgFBP3EhESAtIAFBBGo2AgACQAJAQcAAIBFrIgxBBEsEQCAkIQFBBCEMDAEFIBMgEWogJCAMEBEaICQgDGohASAQIBMQEEEEIAxrIgxBwABPBEADQCATIAEpAAA3AAAgEyABKQAINwAIIBMgASkAEDcAECATIAEpABg3ABggEyABKQAgNwAgIBMgASkAKDcAKCATIAEpADA3ADAgEyABKQA4NwA4IAFBQGshASAQIBMQECAMQUBqIgxBwABPDQALCyAMBEBBACERDAILCwwBCyATIBFqIAEgDBARGgsgGSAtKAIAIgFBHXZBGHQ2AgAgVCABQQt0QYCA/AdxIAFBG3RyIAFBBXZBgP4DcXIgAUEVdkH/AXFyNgIAIC1BNyABa0E/cUEBaiIMIAFqNgIAAkACQCAMQcAAIAFBP3EiAWsiEUkEQEGACCERDAEFIBMgAWpBgAggERARGiARQYAIaiEBIBAgExAQIAwgEWsiDEHAAE8EQANAIBMgASkAADcAACATIAEpAAg3AAggEyABKQAQNwAQIBMgASkAGDcAGCATIAEpACA3ACAgEyABKQAoNwAoIBMgASkAMDcAMCATIAEpADg3ADggAUFAayEBIBAgExAQIAxBQGoiDEHAAE8NAAsLIAwEQCABIRFBACEBDAILCwwBCyATIAFqIBEgDBARGgsg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QT9xIRggLiABQQRqNgIAAkACQEHAACAYayIMQQRLBEAgJCEBQQQhDAwBBSASIBhqICQgDBARGiAkIAxqIQEgECASEBBBBCAMayIMQcAATwRAA0AgEiABKQAANwAAIBIgASkACDcACCASIAEpABA3ABAgEiABKQAYNwAYIBIgASkAIDcAICASIAEpACg3ACggEiABKQAwNwAwIBIgASkAODcAOCABQUBrIQEgECASEBAgDEFAaiIMQcAATw0ACwsgDARAQQAhGAwCCwsMAQsgEiAYaiABIAwQERoLIBkgLigCACIBQR12QRh0NgIAIHsgAUELdEGAgPwHcSABQRt0ciABQQV2QYD+A3FyIAFBFXZB/wFxcjYCACAuQTcgAWtBP3FBAWoiDCABajYCAAJAAkAgDEHAACABQT9xIgFrIhhJBEBBgAghGAwBBSASIAFqQYAIIBgQERogGEGACGohASAQIBIQECAMIBhrIgxBwABPBEADQCASIAEpAAA3AAAgEiABKQAINwAIIBIgASkAEDcAECASIAEpABg3ABggEiABKQAgNwAgIBIgASkAKDcAKCASIAEpADA3ADAgEiABKQA4NwA4IAFBQGshASAQIBIQECAMQUBqIgxBwABPDQALCyAMBEAgASEYQQAhAQwCCwsMAQsgEiABaiAYIAwQERoLIC4oAgAiAUE/cSEYIC4gAUEIajYCAAJAAkBBwAAgGGsiDEEISwRAIBkhAUEIIQwMAQUgEiAYaiAZIAwQERogGSAMaiEBIBAgEhAQQQggDGsiDEHAAE8EQANAIBIgASkAADcAACASIAEpAAg3AAggEiABKQAQNwAQIBIgASkAGDcAGCASIAEpACA3ACAgEiABKQAoNwAoIBIgASkAMDcAMCASIAEpADg3ADggAUFAayEBIBAgEhAQIAxBQGoiDEHAAE8NAAsLIAwEQEEAIRgMAgsLDAELIBIgGGogASAMEBEaCyAQKAIAEA0hRyAQQQA2AgAgNSgCABANISYgNUEANgIAIDYoAgAQDSEnIDZBADYCACA3KAIAEA0hKCA3QQA2AgAgOCgCABANISkgOEEANgIAIDkoAgAQDSEYIDlBADYCACA6KAIAEA0hDCA6QQA2AgAgUSgCABANIQEgDiBHNgIAICwgJjYCACAvICc2AgAgMCAoNgIAIDEgKTYCACAyIBg2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BEADQCALIAopAAA3AAAgCyAKKQAINwAIIAsgCikAEDcAECALIAopABg3ABggCyAKKQAgNwAgIAsgCikAKDcAKCALIAopADA3ADAgCyAKKQA4NwA4IApBQGshCiAPIAsQECAJQUBqIglBwABPDQALCyAJBEBBACEQDAILCwwBCyALIBBqIAogCRARGgsgDygCABANIYABIA9BADYCACAzKAIAEA0hOiAzQQA2AgAgNCgCABANITsgNEEANgIAIDUoAgAQDSE8IDVBADYCACA2KAIAEA0hPSA2QQA2AgAgNygCABANIRAgN0EANgIAIDgoAgAQDSEJIDhBADYCACBGKAIAEA0hCiAOIIABNgIAICwgOjYCACAtIDs2AgAgLiA8NgIAIC8gPTYCACAwIBA2AgAgMSAJNgIAIDIgCjYCACAVIA4gJRAVCwsgDUEBaiEKIBFBAWoiCSA5KAIASQRAIAkhESAKIQ0MAQsLCyAkQQFqIgkgBkkEQCAJISQMAQsLIB0oAgAMAgsCf0EAIYEBIBgkBCCBAQsPBUEACwshACAdIAAgCGo2AgBBwAAgAEE/cSIAayIBIAhNBEAgEkEgaiIDIABqIAcgARARGiAHIAFqIQcgEiADEBAgCCABayIIQcAASQRAQQAhAAUDQCADIAcpAAA3AAAgAyAHKQAINwAIIAMgBykAEDcAECADIAcpABg3ABggAyAHKQAgNwAgIAMgBykAKDcAKCADIAcpADA3ADAgAyAHKQA4NwA4IAdBQGshByASIAMQECAIQUBqIghBwABPDQBBACEACwsLIAgEQCASQSBqIABqIAcgCBARGgsgEyAdKAIAIgBBHXZBGHQ2AgAgEyAAQQt0QYCA/AdxIABBG3RyIABBBXZBgP4DcXIgAEEVdkH/AXFyNgIEIB1BNyAAa0E/cUEBaiIBIABqNgIAIBJBIGohBAJAAkAgAUHAACAAQT9xIgBrIgNJBEBBgAghAwwBBSAEIABqQYAIIAMQERogA0GACGohACASIAQQECABIANrIgFBwABPBEADQCAEIAApAAA3AAAgBCAAKQAINwAIIAQgACkAEDcAECAEIAApABg3ABggBCAAKQAgNwAgIAQgACkAKDcAKCAEIAApADA3ADAgBCAAKQA4NwA4IABBQGshACASIAQQECABQUBqIgFBwABPDQALCyABBEAgACEDQQAhAAwCCwsMAQsgBCAAaiADIAEQERoLIB0oAgAiAEE/cSEDIB0gAEEIajYCACASQSBqIQQCQAJAQcAAIANrIgFBCEsEQCATIQBBCCEBDAEFIAQgA2ogEyABEBEaIBMgAWohACASIAQQEEEIIAFrIgFBwABPBEADQCAEIAApAAA3AAAgBCAAKQAINwAIIAQgACkAEDcAECAEIAApABg3ABggBCAAKQAgNwAgIAQgACkAKDcAKCAEIAApADA3ADAgBCAAKQA4NwA4IABBQGshACASIAQQECABQUBqIgFBwABPDQALCyABBEBBACEDDAILCwwBCyAEIANqIAAgARARGgsgEigCABANIQggEkEANgIAID4oAgAQDSEHID5BADYCACA/KAIAEA0hBiA/QQA2AgAgQCgCABANIQUgQEEANgIAIEEoAgAQDSEEIEFBADYCACBCKAIAEA0hAyBCQQA2AgAgQygCABANIQEgQ0EANgIAIEQoAgAQDSEAIERBADYCACAOIAg2AgAgDiAHNgIEIA4gBjYCCCAOIAU2AgwgDiAENgIQIA4gAzYCFCAOIAE2AhggDiAANgIcIAIgDkEgEDFFIYIBIBgkBCCCAQufFgEufyMEIQgjBEGwBWokBCAIQYAFaiICQbifBCABEA8gCEHYBGoiBiABEAwgBiAGKAIAQQhqIg82AgAgCEHoAmoiBCABIAIQDyAEQbzh//8AIAQoAgBrIgs2AgBB/P3//wAgBEEEaiICKAIAayEDIAIgAzYCAEH8////ACAEQQhqIgIoAgBrIQUgAiAFNgIAQfz///8AIARBDGoiAigCAGshCSACIAk2AgBB/P///wAgBEEQaiICKAIAayEHIAIgBzYCAEH8////ACAEQRRqIgIoAgBrIQogAiAKNgIAQfz///8AIARBGGoiAigCAGshDCACIAw2AgBB/P///wAgBEEcaiICKAIAayENIAIgDTYCAEH8////ACAEQSBqIgIoAgBrIQ4gAiAONgIAQfz//wcgBEEkaiICKAIAayEEIAIgBDYCACAIQbAEaiICQeCfBCAGEA8gAiACKAIAIAtqNgIAIAJBBGoiCyALKAIAIANqNgIAIAJBCGoiAyADKAIAIAVqNgIAIAJBDGoiAyADKAIAIAlqNgIAIAJBEGoiAyADKAIAIAdqNgIAIAJBFGoiAyAD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/x9xIg02AgAgGCAZQf///x9xIh82AgAgGiAbQf///x9xIiA2AgAgBCAFQf///x9xIiE2AgAgDyAVQf///x9xIiI2AgAgECARQf///x9xIiM2AgAgEiATQf///x9xIiQ2AgAgCiAMQf///x9xIiU2AgAgAyAdQf///x9xIhw2AgAgFCAdQRp2IBdB////AXFqIh02AgAgBkGQA2oiFiACICkQDyAGQegCaiIJIAFBKGoiAykCADcCACAJIAMpAgg3AgggCSADKQIQNwIQIAkgAykCGDcCGCAJIAMpAiA3AiAgCUEkaiIqKAIAIhRBFnYiA0HRB2wgCSgCAGohDyADQQZ0IAlBBGoiFygCAGogD0EadmoiFUEadiAJQQhqIhgoAgBqIhBBGnYgCUEMaiIZKAIAaiIRQRp2IAlBEGoiGigCAGoiEkEadiAJQRRqIhsoAgBqIhNBGnYgCUEYaiIEKAIAaiIKQRp2IAlBHGoiBSgCAGoiDEEadiAJQSBqIgMoAgBqISsgCSAPQf///x9xIg82AgAgFyAVQf///x9xIhU2AgAgGCAQQf///x9xIhA2AgAgGSARQf///x9xIhE2AgAgGiASQf///x9xIhI2AgAgGyATQf///x9xIhM2AgAgBCAKQf///x9xIgo2AgAgBSAMQf///x9xIgw2AgAgAyArQf///x9xIgM2AgAgKiArQRp2IBRB////AXFqNgIAIAZBwAJqIgUgAkEoaiApEA8gBSAFICgQDyAGQZgCaiIEIBYoAgBBvOH//wAgDWtqNgIAIAQgFigCBEH8/f//ACAfa2o2AgQgBCAWKAIIQfz///8AICBrajYCCCAEIBYoAgxB/P///wAgIWtqNgIMIAQgFigCEEH8////ACAia2o2AhAgBCAWKAIUQfz///8AICNrajYCFCAEIBYoAhhB/P///wAgJGtqNgIYIAQgFigCHEH8////ACAla2o2AhwgBCAWKAIgQfz///8AIBxrajYCICAEIBYoAiRB/P//ByAda2o2AiRB/P//ByAqKAIAayECIAZB8AFqIg0gBSgCAEG84f//ACAPa2o2AgAgDSAFKAIEQfz9//8AIBVrajYCBCANIAUoAghB/P///wAgEGtqNgIIIA0gBSgCDEH8////ACARa2o2AgwgDSAFKAIQQfz///8AIBJrajYCECANIAUoAhRB/P///wAgE2tqNgIUIA0gBSgCGEH8////ACAKa2o2AhggDSAFKAIcQfz///8AIAxrajYCHCANIAUoAiBB/P///wAgA2tqNgIgIA0gBSgCJCACajYCJCAEECNFBEAgDiANEAwgJiAEEAwgCyAEICYQDyAAQdAAaiIBIB4pAgA3AgAgASAeKQIINwIIIAEgHikCEDcCECABIB4pAhg3AhggASAeKQIgNwIgIAEgASAEEA8gByAIICYQDyAAIAcpAgA3AgAgACAHKQIINwIIIAAgBykCEDcCECAAIAcpAhg3AhggACAHKQIgNwIgQfj7//8BIAtBBGoiHygCACAAQQRqIhQoAgBBAXRqayEQQfj///8BIAtBCGoiICgCACAAQQhqIhcoAgBBAXRqayERQfj///8BIAtBDGoiISgCACAAQQxqIhgoAgBBAXRqayESQfj///8BIAtBEGoiIigCACAAQRBqIhkoAgBBAXRqayETQfj///8BIAtBFGoiIygCACAAQRRqIhooAgBBAXRqayEKQfj///8BIAtBGGoiJCgCACAAQRhqIhsoAgBBAXRqayEMQfj///8BIAtBHGoiJSgCACAAQRxqIgQoAgBBAXRqayEDQfj///8BIAtBIGoiHCgCACAAQSBqIgUoAgBBAXRqayECQfj//w8gC0EkaiIdKAIAIABBJGoiDygCAEEBdGprIQEgACAOKAIAQfjC//8BIAsoAgAgACgCAEEBdGpraiIVNgIAIBQgDigCBCAQaiIQNgIAIBcgDigCCCARaiIRNgIAIBggDigCDCASaiISNgIAIBkgDigCECATaiITNgIAIBogDigCFCAKaiIKNgIAIBsgDigCGCAMaiIMNgIAIAQgDigCHCADaiIDNgIAIAUgDigCICACaiICNgIAIA8gDigCJCABaiIBNgIAIABBKGoiFCAHKAIAQbSk//8CIBVrajYCACAAQSxqIhcgBygCBEH0+f//AiAQa2o2AgAgAEEwaiIYIAcoAghB9P///wIgEWtqNgIAIABBNGoiGSAHKAIMQfT///8CIBJrajYCACAAQThqIhogBygCEEH0////AiATa2o2AgAgAEE8aiIbIAcoAhRB9P///wIgCmtqNgIAIABBQGsiBCAHKAIYQfT///8CIAxrajYCACAAQcQAaiIFIAcoAhxB9P///wIgA2tqNgIAIABByABqIg8gBygCIEH0////AiACa2o2AgAgAEHMAGoiFSAHKAIkQfT//xcgAWtqNgIAIBQgFCANEA8gCyALIAkQDyALQbzh//8AIAsoAgBrIhA2AgAgH0H8/f//ACAfKAIAayIRNgIAICBB/P///wAgICgCAGsiEjYCACAhQfz///8AICEoAgBrIhM2AgAgIkH8////ACAiKAIAayIKNgIAICNB/P///wAgIygCAGsiDDYCACAkQfz///8AICQoAgBrIgM2AgAgJUH8////ACAlKAIAayICNgIAIBxB/P///wAgHCgCAGsiATYCACAdQfz//wcgHSgCAGsiADYCACAUIBQoAgAgEGo2AgAgFyAXKAIAIBFqNgIAIBggGCgCACASajYCACAZIBkoAgAgE2o2AgAgGiAaKAIAIApqNgIAIBsgGygCACAMajYCACAEIAQoAgAgA2o2AgAgBSAFKAIAIAJqNgIAIA8gDygCACABajYCACAVIBUoAgAgAGo2AgAMAQsgDRAjRQRAICdBATYCACAAQgA3AgAgAEIANwIIIABCADcCECAAQgA3AhggAEIANwIgIABCADcCKCAAQgA3AjAgAEIANwI4IABBQGtCADcCACAAQgA3AkggAEIANwJQIABCADcCWCAAQgA3AmAgAEIANwJoIABCADcCcAwBCyAsKAIABEAgJ0EBNgIABSAAIAEQHQsgBiQEDwsgBiQEC9sQAQx/IwQhBCMEQYAEaiQEIARBwAFqIgIgARAOIAQgAiABEBIgBEHgA2oiDSAEEBMgBCACIA0QEiAEQaABaiIJIAQQEyAEIAkgAhASIARBwANqIgYgBBATIAQgBiACEBIgBEGAAWoiDCAEEBMgBCAMIAIQEiAEQeAAaiIKIAQQEyAEIAogAhASIARBQGsiCyAEEBMgBEGgA2oiByALEA4gByAHEA4gBCAHIAoQEiAHIAQQEyAEQYADaiIIIAcQDiAIIAgQDiAEIAggDRASIAggBBATIARB4AJqIgUgCBAOIAUgBRAOIAUgBRAOIAUgBRAOIAUgBRAOIAUgBRAOIAQgBSAHEBIgBSAEEBMgBEHAAmoiAyAFEA4gAyADEA4gAyADEA4gAyADEA4gAyADEA4gAyADEA4gAyADEA4gAyADEA4gAyADEA4gAyADEA4gAyADEA4gAyADEA4gAyADEA4gAyADEA4gBCADIAUQEiADIAQQEyAEQaACaiICIAMQDiACIAIQDiACIAIQDiACIAIQDiACIAIQDiACIAIQDiACIAIQDiACIAIQDiACIAIQDiACIAIQDiACIAIQDiACIAIQDiACIAIQDiACIAIQDiACIAIQDiACIAIQDiACIAIQDiACIAIQDiACIAIQDiACIAIQDiACIAIQDiACIAIQDiACIAIQDiACIAIQDiACIAIQDiACIAIQDiACIAIQDiACIAIQDiAEIAIgAxASIAIgBBATIARBgAJqIgMgAhAOIAMgAxAOIAMgAxAOIAMgAxAOIAMgAxAOIAMgAxAOIAMgAxAOIAMgAxAOIAMgAxAOIAMgAxAOIAMgAxAOIAMgAxAOIAMgAxAOIAMgAxAOIAMgAxAOIAMgAxAOIAMgAxAOIAMgAxAOIAMgAxAOIAMgAxAOIAMgAxAOIAMgAxAOIAMgAxAOIAMgAxAOIAMgAxAOIAMgAxAOIAMgAxAOIAMgAxAOIAMgAxAOIAMgAxAOIAMgAxAOIAMgAxAOIAMgAxAOIAMgAxAOIAMgAxAOIAMgAxAOIAMgAxAOIAMgAxAOIAMgAxAOIAMgAxAOIAMgAxAOIAMgAxAOIAMgAxAOIAMgAxAOIAMgAxAOIAMgAxAOIAMgAxAOIAMgAxAOIAMgAxAOIAMgAxAOIAMgAxAOIAMgAxAOIAMgAxAOIAMgAxAOIAMgAxAOIAMgAxAOIAQgAyACEBIgAyAEEBMgBEHgAWoiAiADEA4gAiACEA4gAiACEA4gAiACEA4gAiACEA4gAiACEA4gAiACEA4gAiACEA4gAiACEA4gAiACEA4gAiACEA4gAiACEA4gAiACEA4gAiACEA4gBCACIAUQEiACIAQQEyACIAIQDiACIAIQDiACIAIQDiAEIAIgCRASIAIgBBATIAIgAhAOIAIgAhAOIAIgAhAOIAIgAhAOIAQgAiAGEBIgAiAEEBMgAiACEA4gAiACEA4gAiACEA4gAiACEA4gBCACIAkQEiACIAQQEyACIAIQDiACIAIQDiACIAIQDiACIAIQDiACIAIQDiAEIAIgChASIAIgBBATIAIgAhAOIAIgAhAOIAIgAhAOIAIgAhAOIAQgAiAKEBIgAiAEEBMgAiACEA4gAiACEA4gAiACEA4gAiACEA4gBCACIAYQEiACIAQQEyACIAIQDiACIAIQDiACIAIQDiACIAIQDiACIAIQDiAEIAIgBhASIAIgBBATIAIgAhAOIAIgAhAOIAIgAhAOIAIgAhAOIAIgAhAOIAIgAhAOIAQgAiALEBIgAiAEEBMgAiACEA4gAiACEA4gAiACEA4gAiACEA4gBCACIAkQEiACIAQQEyACIAIQDiACIAIQDiACIAIQDiAEIAIgBhASIAIgBBATIAIgAhAOIAIgAhAOIAIgAhAOIAIgAhAOIAIgAhAOIAQgAiAMEBIgAiAEEBMgAiACEA4gAiACEA4gAiACEA4gAiACEA4gAiACEA4gAiACEA4gBCACIAkQEiACIAQQEyACIAIQDiACIAIQDiACIAIQDiACIAIQDiACIAIQDiACIAIQDiACIAIQDiACIAIQDiACIAIQDiACIAIQDiAEIAIgBhASIAIgBBATIAIgAhAOIAIgAhAOIAIgAhAOIAIgAhAOIAQgAiAGEBIgAiAEEBMgAiACEA4gAiACEA4gAiACEA4gAiACEA4gAiACEA4gAiACEA4gAiACEA4gAiACEA4gAiACEA4gBCACIAgQEiACIAQQEyACIAIQDiACIAIQDiACIAIQDiACIAIQDiACIAIQDiAEIAIgDBASIAIgBBATIAIgAhAOIAIgAhAOIAIgAhAOIAIgAhAOIAIgAhAOIAIgAhAOIAQgAiAKEBIgAiAEEBMgAiACEA4gAiACEA4gAiACEA4gAiACEA4gBCACIAsQEiACIAQQEyACIAIQDiACIAIQDiACIAIQDiACIAIQDiACIAIQDiAEIAIgDRASIAIgBBATIAIgAhAOIAIgAhAOIAIgAhAOIAIgAhAOIAIgAhAOIAIgAhAOIAQgAiALEBIgAiAEEBMgAiACEA4gAiACEA4gAiACEA4gAiACEA4gAiACEA4gAiACEA4gAiACEA4gAiACEA4gAiACEA4gAiACEA4gBCACIAsQEiACIAQQEyACIAIQDiACIAIQDiACIAIQDiACIAIQDiAEIAIgDBASIAIgBBATIAIgAhAOIAIgAhAOIAIgAhAOIAIgAhAOIAIgAhAOIAIgAhAOIAQgAiABEBIgAiAEEBMgAiACEA4gAiACEA4gAiACEA4gAiACEA4gAiACEA4gAiACEA4gAiACEA4gAiACEA4gBCACIAcQEiAAIAQQEyAEJAQL7xoBUn8jBCEOIwRB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IGo2AgAgCkEgaiEQAkACQEHAACAHayIDQSBLBEAgACEDIAchBkEgIQQMAQUgECAHaiAAIAMQERogACADaiEGIAogEBAQQSAgA2siBEHAAEkEfyAGBSAAQeQAaiAHQaB/aiIOQUBxIgtBHHIgB2tqITkgBCEDIAYhBANAIBAgBCkAADcAACAQIAQpAAg3AAggECAEKQAQNwAQIBAgBCkAGDcAGCAQIAQpACA3ACAgECAEKQAoNwAoIBAgBCkAMDcAMCAQIAQpADg3ADggBEFAayEEIAogEBAQIANBQGoiA0HAAE8NAAsgDiALayEEIDkLIQMgBARAQQAhBgwCCwsMAQsgECAGaiADIAQQERoLIAkgDSgCACIDQR12QRh0NgIAIAkgA0ELdEGAgPwHcSADQRt0ciADQQV2QYD+A3FyIANBFXZB/wFxcjYCBCANQTcgA2tBP3FBAWoiBCADajYCACAKQSBqIQcCQAJAIARBwAAgA0E/cSIDayIGSQRAQYAIIQYMAQUgByADakGACCAGEBEaIAZBgAhqIQMgCiAHEBAgBCAGayIEQcAATwRAA0AgByADKQAANwAAIAcgAykACDcACCAHIAMpABA3ABAgByADKQAYNwAYIAcgAykAIDcAICAHIAMpACg3ACggByADKQAwNwAwIAcgAykAODcAOCADQUBrIQMgCiAHEBAgBEFAaiIEQcAATw0ACwsgBARAIAMhBkEAIQMMAgsLDAELIAcgA2ogBiAEEBEaCyANKAIAIgNBP3EhBiANIANBCGo2AgAgCkEgaiEHAkACQEHAACAGayIEQQhLBEAgCSEDQQghBAwBBSAHIAZqIAkgBBARGiAJIARqIQMgCiAHEBBBCCAEayIEQcAATwRAA0AgByADKQAANwAAIAcgAykACDcACCAHIAMpABA3ABAgByADKQAYNwAYIAcgAykAIDcAICAHIAMpACg3ACggByADKQAwNwAwIAcgAykAODcAOCADQUBrIQMgCiAHEBAgBEFAaiIEQcAATw0ACwsgBARAQQAhBgwCCwsMAQsgByAGaiADIAQQERoLIAooAgAQDSESIApBADYCACAaKAIAEA0hECAaQQA2AgAgGygCABANIQ4gG0EANgIAIBwoAgAQDSELIBxBADYCACAdKAIAEA0hByAdQQA2AgAgHigCABANIQYgHkEANgIA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gAFqIAZrIQYgAyECIAQhAwNAIA4gAykAADcAACAOIAMpAAg3AAggDiADKQAQNwAQIA4gAykAGDcAGCAOIAMpACA3ACAgDiADKQAoNwAoIA4gAykAMDcAMCAOIAMpADg3ADggA0FAayEDIAogDhAQIAJBQGoiAkHAAE8NAAsgASAGaiEBQQAhBCALIAdrCyECCyACBEAgCkEgaiAEaiABIAIQERoLIAkgDSgCACIBQR12QRh0NgIAIAkgAUELdEGAgPwHcSABQRt0ciABQQV2QYD+A3FyIAFBFXZB/wFxcjYCBCANQTcgAWtBP3FBAWoiAiABajYCACAKQSBqIQQCQAJAIAJBwAAgAUE/cSIBayIDSQRAQYAIIQMMAQUgBCABakGACCADEBEaIANBgAhqIQEgCiAEEBAgAiADayICQcAATwRAA0AgBCABKQAANwAAIAQgASkACDcACCAEIAEpABA3ABAgBCABKQAYNwAYIAQgASkAIDcAICAEIAEpACg3ACggBCABKQAwNwAwIAQgASkAODcAOCABQUBrIQEgCiAEEBAgAkFAaiICQcAATw0ACwsgAgRAIAEhA0EAIQEMAgsLDAELIAQgAWogAyACEBEaCyANKAIAIgFBP3EhAyANIAFBCGo2AgAgCkEgaiEEAkACQEHAACADayICQQhLBEAgCSEBQQghAgwBBSAEIANqIAkgAhARGiAJIAJqIQEgCiAEEBBBCCACayICQcAATwRAA0AgBCABKQAANwAAIAQgASkACDcACCAEIAEpABA3ABAgBCABKQAYNwAYIAQgASkAIDcAICAEIAEpACg3ACggBCABKQAwNwAwIAQgASkAODcAOCABQUBrIQEgCiAEEBAgAkFAaiICQcAATw0ACwsgAgRAQQAhAwwCCwsMAQsgBCADaiABIAIQERoLIAooAgAQDSEOIApBADYCACAaKAIAEA0hCyAaQQA2AgAgGygCABANIQcgG0EANgIAIBwoAgAQDSEGIBxBADYCACAdKAIAEA0hBCAdQQA2AgAgHigCABANIQMgHkEANgIAIB8oAgAQDSECIB9BADYCACAgKAIAEA0hASAgQQA2AgAgCCAONgIAICMgCzYCACAkIAc2AgAgJSAGNgIAICYgBDYCACAnIAM2AgAgKCACNgIAICkgATYCACARKAIAIgFBP3EhAyARIAFBIGo2AgACQAJAQcAAIANrIgRBIEsEQCAIIQEgAyECQSAhAwwBBSAFIANqIAggBBARGiAIIARqIQIgDCAFEBBBICAEayIBQcAASQR/IAEhAyACBSADQaB/aiIDQQZ2QQF0IQYgBEFAaiEEA0AgBSACKQAANwAAIAUgAikACDcACCAFIAIpABA3ABAgBSACKQAYNwAYIAUgAikAIDcAICAFIAIpACg3ACggBSACKQAwNwAwIAUgAikAODcAOCACQUBrIQIgDCAFEBAgAUFAaiIBQcAATw0ACyADQT9xIQMgCCAGQQRqQQV0aiAEagshASADBEBBACECDAILCwwBCyAFIAJqIAEgAxARGgsgCSARKAIAIgFBHXZBGHQ2AgAgCSABQQt0QYCA/AdxIAFBG3RyIAFBBXZBgP4DcXIgAUEVdkH/AXFyNgIEIBFBNyABa0E/cUEBaiICIAFqNgIAAkACQCACQcAAIAFBP3EiAWsiA0kEQEGACCEDDAEFIAUgAWpBgAggAxARGiADQYAIaiEBIAwgBRAQIAIgA2siAkHAAE8EQANAIAUgASkAADcAACAFIAEpAAg3AAggBSABKQAQNwAQIAUgASkAGDcAGCAFIAEpACA3ACAgBSABKQAoNwAoIAUgASkAMDcAMCAFIAEpADg3ADggAUFAayEBIAwgBRAQIAJBQGoiAkHAAE8NAAsLIAIEQCABIQNBACEBDAILCwwBCyAFIAFqIAMgAhARGgsgESgCACIBQT9xIQMgESABQQhqNgIAAkACQEHAACADayICQQhLBEAgCSEBQQghAgwBBSAFIANqIAkgAhARGiAJIAJqIQEgDCAFEBBBCCACayICQcAATwRAA0AgBSABKQAANwAAIAUgASkACDcACCAFIAEpABA3ABAgBSABKQAYNwAYIAUgASkAIDcAICAFIAEpACg3ACggBSABKQAwNwAwIAUgASkAODcAOCABQUBrIQEgDCAFEBAgAkFAaiICQcAATw0ACwsgAgRAQQAhAwwCCwsMAQsgBSADaiABIAIQERoLIAwoAgAQDSEOIAxBADYCACATKAIAEA0hCyATQQA2AgAgFCgCABANIQcgFEEANgIAIBUoAgAQDSEGIBVBADYCACAWKAIAEA0hBCAWQQA2AgAgFygCABANIQMgF0EANgIAIBgoAgAQDSECIBhBADYCACAhKAIAEA0hASAhQQA2AgAgLyAONgAAIDAgCzYAACAxIAc2AAAgMiAGNgAAIDMgBDYAACA0IAM2AAAgNSACNgAAIDYgATYAACAKIBkQJCANKAIAIgFBP3EhBCANIAFBIGo2AgAgCkEgaiELAkACQEHAACAEayIBQSBLBEAgACEBIAQhA0EgIQIMAQUgCyAEaiAAIAEQERogACABaiEDIAogCxAQQSAgAWsiAkHAAEkEfyADBSAAQeQAaiAEQaB/aiIHQUBxIgZBHHIgBGtqITwgAiEBIAMhAgNAIAsgAikAADcAACALIAIpAAg3AAggCyACKQAQNwAQIAsgAikAGDcAGCALIAIpACA3ACAgCyACKQAoNwAoIAsgAikAMDcAMCALIAIpADg3ADggAkFAayECIAogCxAQIAFBQGoiAUHAAE8NAAsgByAGayECIDwLIQEgAgRAQQAhAwwCCwsMAQsgCyADaiABIAIQERoLIAkgDSgCACIBQR12QRh0NgIAIAkgAUELdEGAgPwHcSABQRt0ciABQQV2QYD+A3FyIAFBFXZB/wFxcjYCBCANQTcgAWtBP3FBAWoiAiABajYCACAKQSBqIQQCQAJAIAJBwAAgAUE/cSIBayIDSQRAQYAIIQMMAQUgBCABakGACCADEBEaIANBgAhqIQEgCiAEEBAgAiADayICQcAATwRAA0AgBCABKQAANwAAIAQgASkACDcACCAEIAEpABA3ABAgBCABKQAYNwAYIAQgASkAIDcAICAEIAEpACg3ACggBCABKQAwNwAwIAQgASkAODcAOCABQUBrIQEgCiAEEBAgAkFAaiICQcAATw0ACwsgAgRAIAEhA0EAIQEMAgsLDAELIAQgAWogAyACEBEaCyANKAIAIgFBP3EhAyANIAFBCGo2AgAgCkEgaiEEAkACQEHAACADayICQQhLBEAgCSEBQQghAgwBBSAEIANqIAkgAhARGiAJIAJqIQEgCiAEEBBBCCACayICQcAATwRAA0AgBCABKQAANwAAIAQgASkACDcACCAEIAEpABA3ABAgBCABKQAYNwAYIAQgASkAIDcAICAEIAEpACg3ACggBCABKQAwNwAwIAQgASkAODcAOCABQUBrIQEgCiAEEBAgAkFAaiICQcAATw0ACwsgAgRAQQAhAwwCCwsMAQsgBCADaiABIAIQERoLIAoo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NgIAIHFCIIggHiALQQV0akEMaiIhKAIArXwgJSgCDK18InKnIQcgISAHNgIAICUoAhCtIB4gC0EFdGpBEGoiIigCAK18IHJCIIh8InOnIQggIiAINgIAICUoAhStIB4gC0EFdGpBFGoiIygCAK18IHNCIIh8IQMgIyADPgIAICUoAhitIB4gC0EFdGpBGGoiJCgCAK18IANCIIh8IQkgJCAJPgIAIAogbkL/////D4MgCEF+SSAJIAODICUoAhytIB4gC0EFdGpBHGoiCigCAK18IAlCIIh8Im6Dp0F/R3IiGEEBcyAIQX9GcSIIQQFzIAdB5rm71XtJcSAYciIYQQFzIAdB5rm71XtLcSAIciIHQQFzIAZBu8Ci+npJcSAYciIIQQFzIAZBu8Ci+npLcSAHciIGQQFzIAVBjL3J/ntJcSAIckF/cyIHIAVBjL3J/ntLcSAGciAHIA5BwILZgX1LcXIgbkIgiKdqIgVBv/2m/gJsrXwidD4CACAZIHBC/////w+DIAVB88K2gQRsrXwgdEIgiHwicD4CACAfIHFC/////w+DIAVBxL/dhQVsrXwgcEIgiHwicT4CACAhIHJC/////w+DIAVBmcbEqgRsrXwgcUIgiHwicj4CACAiIHNC/////w+DIAWtfCByQiCIfCJzPgIAICMgc0IgiCADQv////8Pg3wiAz4CACAkIANCIIggCUL/////D4N8Igk+AgAgCiAJQiCIpyBup2oiBTYCAEEAIC8oAgANAxpBACAFIHAgdIQgcYQgcoQgc4QgA4QgCYSnckUNAxogASAEaiEfICsEQCAfQQAgKxAeGiAEICtqIQQLICYEQEEAIQggBCEGBSAWQRhqISEgFkEZaiEiIBZBGmohIyAWQRtqISQgFkEcaiEmIBZBHWohGCAWQR5qIRwgFkEfaiEXICpB0ABqISUgKkEoaiEOIBJBAWohGSAQQSRqISsgEkECaiEvIBBBIGohMCASQQNqISwgEkEEaiEtIBJBBWohMSASQQZqITIgEEEcaiEzIBJBB2ohNCASQQhqITUgEkEJaiE2IBBBGGohNyASQQpqITggEkELaiE5IBJBDGohOiAQQRRqITsgEkENaiE8IBJBDmohPSASQQ9qIT4gEEEQaiE/IBJBEGohQCASQRFqIUEgEkESaiFCIBJBE2ohQyAQQQxqIUQg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qQQgACgCrAEgACgCqAFBA3FBCGoRAAAMAQsgAUUEQEGeqQQgACgCrAEgACgCqAFBA3FBCGoRAAAMAQsgAkUEQEGwqQQgACgCrAEgACgCqAFBA3FBCGoRAAAMAQsgBkUgB0EAR3EEQEGEqgQgACgCrAEgACgCqAFBA3FBCGoRAAAMAQsgCEUEQEHSpgQgACgCrAEgACgCqAFBA3FBCGoRAAAMAQsgACgCAEUEQEHFpQQgACgCrAEgACgCqAFBA3FBCGoRAAAMAQsgCUGoAWoiCyADQQFqEBQaIAlB1ABqIgogCykCADcCACAKIAspAgg3AgggCiALKQIQNwIQIAogCykCGDcCGCAKIAspAiA3AiAgCUH4AWoiDSALEAwgCUHQAWoiDCALIA0QDyAKQQA2AlAgDCAMKAIAQQdqNgIAIApBKGoiCyAMEBcaIAMsAABBAXEEQCAKQcwAaiINKAIAIg5BFnYiDEHRB2wgCygCAGohAyAMQQZ0IApBLGoiDygCAGogA0EadmoiEEEadiAKQTBqIhEoAgBqIhJBGnYgCkE0aiITKAIAaiIUQRp2IApBOGoiFSgCAGoiFkEadiAKQTxqIhcoAgBqIhhBGnYgCkFAayIZKAIAaiIaQRp2IApBxABqIhsoAgBqIhxBGnYgCkHIAGoiHSgCAGohDCALQbzh//8AIANB////H3FrNgIAIA9B/P3//wAgEEH///8fcWs2AgAgEUH8////ACASQf///x9xazYCACATQfz///8AIBRB////H3FrNgIAIBVB/P///wAgFkH///8fcWs2AgAgF0H8////ACAYQf///x9xazYCACAZQfz///8AIBpB////H3FrNgIAIBtB/P///wAgHEH///8fcWs2AgAgHUH8////ACAMQf///x9xazYCACANQfz//wcgDEEadiAOQf///wFxams2AgALIAkgCBAUGiAJQShqIAhBIGoQFBogCUEANgJQAn8gAEEAQQBBAEEAQQBBACABIAIgCiAEIAUgBiAHIAkQPSEeIAkkBCAeCw8LIAkkBEEAC8MHARd/AkAjBCEOIwRBoAJqJAQgCEUEQEH8pgQgACgCrAEgACgCqAFBA3FBCGoRAAAMAQsgCUUEQEHCqQQgACgCrAEgACgCqAFBA3FBCGoRAAAMAQsgBkUEQEGeqQQgACgCrAEgACgCqAFB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LUL/////D4MgCUHEv92FBWytfCArQiCIfCIrpyEOIC9C/////w+DIAlBmcbEqgRsrXwgK0IgiHwiK6chDyAwQv////8PgyAJrXwgK0IgiHwiK6chCSArQiCIIDFC/////w+DfCIrpyEcICtCIIggMkL/////D4N8IiunIR0gK0IgiKcgLKdqIR4gAEEBaiIAIARJDQALIBYoAgCtISwgFygCAK0hKyAYKAIArSExIB1Bf3OtQv////8PfCAcQX9zrUL/////D3wgCUF/c61C/v///w98IA9Bf3OtQua5u9ULfCAOQX9zrUK7wKL6CnwgDUF/c61CjL3J/gt8IAhBf3OtQsKC2YENfCItQiCIfCIvQiCIfCIwQiCIfCIyQiCIfCIzQiCIfCI0QiCIfCEuIAYgBigCAK0gHiAdciAcciAJciAPciAOciANciAIckEAR0EfdEEfdSIAIC2nca18Ii2nIg02AgAgFiAsIAAgL6dxrXwgLUIgiHwiL6ciATYCACAXICsgACAwp3GtfCAvQiCIfCIwpyICNgIAIBggMSAypyAAca18IDBCIIh8IjGnIgU2AgAgGSAZKAIArSAzpyAAca18IDFCIIh8IjKnIgg2AgAgGiAaKAIArSA0pyAAca18IDJCIIh8Iiw+AgAgGyAbKAIArSAupyAAca18ICxCIIh8Iis+AgAgBiAtQv////8PgyAIQX5JICsgLIMgIigCAK0gHkF/c61C/////w98IC5CIIh8pyAAca18ICtCIIh8Ii6Dp0F/R3IiAEEBcyAIQX9GcSIIQQFzIAVB5rm71XtJcSAAciIAQQFzIAVB5rm71XtLcSAIciIFQQFzIAJBu8Ci+npJcSAAciIAQQFzIAJBu8Ci+npLcSAFciICQQFzIAFBjL3J/ntJcSAAckF/cyIAIAFBjL3J/ntLcSACciAAIA1BwILZgX1LcXIgLkIgiKdqIgBBv/2m/gJsrXwiLT4CACAWIC9C/////w+DIABB88K2gQRsrXwgLUIgiHwiLT4CACAXIDBC/////w+DIABBxL/dhQVsrXwgLUIgiHwiLT4CACAYIDFC/////w+DIABBmcbEqgRsrXwgLUIgiHwiLT4CACAZIDJC/////w+DIACtfCAtQiCIfCItPgIAIBogLUIgiCAsQv////8Pg3wiLD4CACAbICxCIIggK0L/////D4N8Iiw+AgAgIiAsQiCIpyAup2o2AgAgAyAEQX9qQQJ0aigCACAGEC4gBkIANwIAIAZCADcCCCAGQgA3AhAgBkIANwIYIAwkBEEBDwsgBkIANwIAIAZCADcCCCAGQgA3AhAgBkIANwIYCyAMJARBAAuMDwEdfyMEIRsjBEHQAmokBCABRSACQQBHcQRAQcmnBCAAKAKsASAAKAKoAUEDcUEIahEAACAbJARBAA8LIANFIARBAEdxBEBB5KcEIAAoAqwBIAAoAqgBQQNxQQhqEQAAIBskBEEADwsgG0GgAmohHCAbQfgBaiESIBtB0AFqIQcgGyIGQdQAaiIFQfgAaiIeQQE2AgAgBUIANwIAIAVCADcCCCAFQgA3AhAgBUIANwIYIAVCADcCICAFQgA3AiggBUIANwIwIAVCADcCOCAFQUBrQgA3AgAgBUIANwJIIAVCADcCUCAFQgA3AlggBUIANwJgIAVCADcCaCAFQgA3AnAgBAR/IAZB0ABqIQ0gBkEoaiEQIAZBLGohEyAGQTBqIRQgBkE0aiEVIAZBOGohFiAGQTxqIRcgBkFAayEYIAZBxABqIRkgBkHIAGohCCAGQcwAaiELQQAhAANAIAcgAyAAQQJ0aigCACIJQQFqEBQaIAYgBykCADcCACAGIAcpAgg3AgggBiAHKQIQNwIQIAYgBykCGDcCGCAGIAcpAiA3AiAgHCAHEAwgEiAHIBwQDyANQQA2AgAgEiASKAIAQQdqNgIAIBAgEhAXGiAJLAAAQQFxBEAgCygCACIOQRZ2IgpB0QdsIBAoAgBqIQkgCkEGdCATKAIAaiAJQRp2aiIaQRp2IBQoAgBqIgxBGnYgFSgCAGoiD0EadiAWKAIAaiIRQRp2IBcoAgBqIh1BGnYgGCgCAGoiH0EadiAZKAIAaiIgQRp2IAgoAgBqIQogEEG84f//ACAJQf///x9xazYCACATQfz9//8AIBpB////H3FrNgIAIBRB/P///wAgDEH///8fcWs2AgAgFUH8////ACAPQf///x9xazYCACAWQfz///8AIBFB////H3FrNgIAIBdB/P///wAgHUH///8fcWs2AgAgGEH8////ACAfQf///x9xazYCACAZQfz///8AICBB////H3FrNgIAIAhB/P///wAgCkH///8fcWs2AgAgC0H8//8HIApBGnYgDkH///8BcWprNgIACyAFIAUgBkEAEB8gAEEBaiIAIARHDQALIAVBLGoiDyEDIAVBMGoiACEEIAVBNGoiCyEQIAVBOGoiCSETIAVBPGoiCiEUIAVBQGsiDSEVIAVBxABqIg4hFiAFQcgAaiIaIRcgBUHMAGoiDCEYIAVBKGoiESEZIAAoAgAhCCAJKAIAIQkgCigCACEKIA0oAgAhDSAOKAIAIQ4gGigCACEaIAwoAgAhACARKAIAIQwgDygCACEPIAsoAgAFIAVBLGohAyAFQTBqIQQgBUE0aiEQIAVBOGohEyAFQTxqIRQgBUFAayEVIAVBxABqIRYgBUHIAGohFyAFQcwAaiEYIAVBKGohGUEAIQBBAAshCyAAQRZ2IhFB0QdsIAxqIQwgEUEGdCAPaiAMQRp2aiIPQRp2IAhqIhFBGnYgC2oiC0EadiAJaiIJQRp2IApqIgpBGnYgDWoiDUEadiAOaiIOQRp2IBpqIQggGUG84f//ACAMQf///x9xazYCACADQfz9//8AIA9B////H3FrNgIAIARB/P///wAgEUH///8fcWs2AgAgEEH8////ACALQf///x9xazYCACATQfz///8AIAlB////H3FrNgIAIBRB/P///wAgCkH///8fcWs2AgAgFUH8////ACANQf///x9xazYCACAWQfz///8AIA5B////H3FrNgIAIBdB/P///wAgCEH///8fcWs2AgAgGEH8//8HIAhBGnYgAEH///8BcWprNgIAIAIEQCAGQdAAaiEJIAZBKGohAyAGQSxqIQQgBkEwaiEQIAZBNGohEyAGQThqIRQgBkE8aiEVIAZBQGshFiAGQcQAaiEXIAZByABqIRggBkHMAGohGUEAIQADQCAHIAEgAEECdGooAgAiCEEBahAUGiAGIAcpAgA3AgAgBiAHKQIINwIIIAYgBykCEDcCECAGIAcpAhg3AhggBiAHKQIgNwIgIBwgBxAMIBIgByAcEA8gCUEANgIAIBIgEigCAEEHajYCACADIBIQFxogCCwAAEEBcQRAIBkoAgAiCkEWdiILQdEHbCADKAIAaiEIIAtBBnQgBCgCAGogCEEadmoiDUEadiAQKAIAaiIOQRp2IBMoAgBqIhpBGnYgFCgCAGoiDEEadiAVKAIAaiIPQRp2IBYoAgBqIhFBGnYgFygCAGoiHUEadiAYKAIAaiELIANBvOH//wAgCEH///8fcWs2AgAgBEH8/f//ACANQf///x9xazYCACAQQfz///8AIA5B////H3FrNgIAIBNB/P///wAgGkH///8fcWs2AgAgFEH8////ACAMQf///x9xazYCACAVQfz///8AIA9B////H3FrNgIAIBZB/P///wAgEUH///8fcWs2AgAgF0H8////ACAdQf///x9xazYCACAYQfz///8AIAtB////H3FrNgIAIBlB/P//ByALQRp2IApB////AXFqazYCAAsgBSAFIAZBABAfIABBAWoiACACRw0ACwsgHigCACEhIBskBCAhC0IBA38jBCEDIwRBQGskBEGBBhAZIgQgAyIFIAFBIRBkBEAgBCAAIAUgAkEAQQAQYiEAIAQQGAVBACEACyADJAQgAAvSCgIjfwh+AkAjBCELIwRB0ABqJAQgAUUEQEGZpwQgACgCrAEgACgCqAFBA3FBCGoRAAAMAQsgAkUEQEGrpwQgACgCrAEgACgCqAFBA3FBCGoRAAAMAQsgBCADSwRAQbqnBCAAKAKsASAAKAKoAUEDcUEIahEAAAwBCyALQQhqIQYgCyEeIAtBKGoiBUEEaiEfIAVCADcCACAFQgA3AgggBUIANwIQIAVCADcCGAJAIAMEQCAGQQRqISAgBUEIaiEhIAZBCGohGCAFQQxqISIgBkEMaiEZIAVBEGohIyAGQRBqIRogBUEUaiEkIAZBFGohGyAFQRhqISUgBkEYaiEcIAVBHGohJiAGQRxqIR0CQAJAA0ACQCAGIAIgDUECdGooAgAgHhAVIB4oAgANACAGKAIAIQAgICgCACEKIA0gBEkEQCAYKAIAIRMgGSgCACEUIBooAgAhFSAbKAIAIRYgHCgCACEXIB0oAgAhCQUgBiAKIAByIBgoAgAiE3IgGSgCACIUciAaKAIAIhVyIBsoAgAiFnIgHCgCACIXciAdKAIAIidyQQBHQR90QR91IgkgAEF/c61CwoLZgQ18IiincSIANgIAICAgCSAKQX9zrUKMvcn+C3wgKEIgiHwiKKdxIgo2AgAgGCAJIBNBf3OtQrvAovoKfCAoQiCIfCIop3EiEzYCACAZIAkgFEF/c61C5rm71Qt8IChCIIh8IiincSIUNgIAIBogFUF/c61C/v///w98IChCIIh8IiinIAlxIhU2AgAgGyAWQX9zrUL/////D3wgKEIgiHwiKKcgCXEiFjYCACAcIBdBf3OtQv////8PfCAoQiCIfCIopyAJcSIXNgIAIB0gJ0F/c61C/////w98IChCIIh8pyAJcSIJNgIACyAArSAHrXwiKUIgiCAIrXwgCq18IiqnIQAgKkIgiCAMrXwgE618IiunIQogFK0gDq18ICtCIIh8IiynIQcgFa0gD618ICxCIIh8Ii2nIQggCa0gEq18IBetIBGtfCAWrSAQrXwgLUIgiHwiLkIgiHwiL0IgiHwhKCApQv////8PgyAIQX5JIC8gLoMgKIOnQX9HciIMQQFzIAhBf0ZxIghBAXMgB0HmubvVe0lxIAxyIgxBAXMgB0HmubvVe0txIAhyIgdBAXMgCkG7wKL6eklxIAxyIghBAXMgCkG7wKL6ektxIAdyIgpBAXMgAEGMvcn+e0lxIAhyQX9zIgcgAEGMvcn+e0txIApyIAcgKadBwILZgX1LcXIgKEIgiKdqIgBBv/2m/gJsrXwiKachByAqQv////8PgyAAQfPCtoEEbK18IClCIIh8IimnIQggK0L/////D4MgAEHEv92FBWytfCApQiCIfCIppyEMICxC/////w+DIABBmcbEqgRsrXwgKUIgiHwiKachDiAtQv////8PgyAArXwgKUIgiHwiKachDyApQiCIIC5C/////w+DfCIppyEQIClCIIggL0L/////D4N8IimnIREgKUIgiKcgKKdqIRIgDUEBaiINIANJDQEMAgsLDAELIAUgBzYCACAfIAg2AgAgISAMNgIAICIgDjYCACAjIA82AgAgJCAQNgIAICUgETYCACAmIBI2AgAMAgsgBSAHNgIAIB8gCDYCACAhIAw2AgAgIiAONgIAICMgDzYCACAkIBA2AgAgJSARNgIAICYgEjYCAAwCCwsgASAFEC4gBUIANwIAIAVCADcCCCAFQgA3AhAgBUIANwIYIAZCADcCACAGQgA3AgggBkIANwIQIAZCADcCGCALJARBAQ8LIAskBEEAC+sGAQd/AkAjBCEJIwRBoARqJAQgAEEIaiILKAIARQRAQfmlBCAAKAKsASAAKAKoAUEDcUEIahEAAAwBCyABRQRAQfymBCAAKAKsASAAKAKoAUEDcUEIahEAAAwBCyACRQRAQYunBCAAKAKsASAAKAKoAUEDcUEIahEAAAwBCyAERQRAQdKmBCAAKAKsASAAKAKoAUEDcUEIahEAAAwBCyAJIgBB8ANqIQcgAEH0AmohCiAAQaQBaiEFIABB0ABqIQYgAEGgAmoiCCAEEBQaIAhBKGogBEEgahAUGiAIQQA2AlAgAEEwaiIEIAIgAEEoaiICEBUgAigCAARAQQAhAAUgCyAFIAQQJyAAQgA3AwAgAEIANwMIIABCADcDECAAIANCOIg8ABggACADQjCIPAAZIAAgA0IoiDwAGiAAIANCIIg8ABsgACADQhiIPAAcIAAgA0IQiDwAHSAAIANCCIg8AB4gACADPAAfIAcgAEEAEBUgCiAIIAdBwAAQLSAFIAUgChAsIAUoAngEf0EABSAGQQA2AlAgBUHQAGoiCCAIECAgACAIEAwgByAIIAAQDyAFIAUgABAPIAVBKGoiAiACIAcQDyAIQQE2AgAgBUHUAGoiB0IANwIAIAdCADcCCCAHQgA3AhAgB0IANwIYIAdBADYCICAGIAUpAgA3AgAgBiAFKQIINwIIIAYgBSkCEDcCECAGIAUpAhg3AhggBiAFKQIgNwIgIAZBKGoiByACKQIANwIAIAcgAikCCDcCCCAHIAIpAhA3AhAgByACKQIYNwIYIAcgAikCIDcCICAGEBYgAUEBaiAGECEgASAAIAcQF0EJczoAAEEBCyEAIAVCADcCACAFQgA3AgggBUIANwIQIAVCADcCGCAFQgA3AiAgBUIANwIoIAVCADcCMCAFQgA3AjggBUFAa0IANwIAIAVCADcCSCAFQgA3AlAgBUIANwJYIAVCADcCYCAFQgA3AmggBUIANwJwIAVBADYCeCAGQgA3AgAgBkIANwIIIAZCADcCECAGQgA3AhggBkIANwIgIAZCADcCKCAGQgA3AjAgBkIANwI4IAZBQGtCADcCACAGQgA3AkggBkEANgJQCyAEQgA3AgAgBEIANwIIIARCADcCECAEQgA3AhggCSQEIAAPCyAJJARBAAv7BAEVfyMEIQUjBEHQAWokBCABRQRAQZilBCAAKAKsASAAKAKoAUEDcUEIahEAACAFJARBAA8LIAJFBEBB/KYEIAAoAqwBIAAoAqgBQQNxQQhqEQAAIAUkBEEADwsgBUHYAGoiAyACQQFqEBQaIAUiACADKQIANwIAIAAgAykCCDcCCCAAIAMpAhA3AhAgACADKQIYNwIYIAAgAykCIDcCICAAQagBaiIGIAMQDCAAQYABaiIEIAMgBhAPIABBADYCUCAEIAQoAgBBB2o2AgAgAEEoaiIDIAQQFxogAiwAAEEBcQRAIABBzABqIgcoAgAiCEEWdiIEQdEHbCADKAIAaiECIARBBnQgAEEsaiIJKAIAaiACQRp2aiIKQRp2IABBMGoiCygCAGoiDEEadiAAQTRqIg0oAgBqIg5BGnYgAEE4aiIPKAIAaiIQQRp2IABBPGoiESgCAGoiEkEadiAAQUBrIhMoAgBqIhRBGnYgAEHEAGoiFSgCAGoiFkEadiAAQcgAaiIXKAIAaiEEIANBvOH//wAgAkH///8fcWs2AgAgCUH8/f//ACAKQf///x9xazYCACALQfz///8AIAxB////H3FrNgIAIA1B/P///wAgDkH///8fcWs2AgAgD0H8////ACAQQf///x9xazYCACARQfz///8AIBJB////H3FrNgIAIBNB/P///wAgFEH///8fcWs2AgAgFUH8////ACAWQf///x9xazYCACAXQfz///8AIARB////H3FrNgIAIAdB/P//ByAEQRp2IAhB////AXFqazYCAAsgASAGIAMQF0EJczoAACAAEBwgAUEBaiAAECEgBSQEQQELjQUBFX8CQCMEIQQjBEHQAWokBCABRQRAQfymBCAAKAKsASAAKAKoAUEDcUEIahEAAAwBCyACRQRAQfikBCAAKAKsASAAKAKoAUEDcUEIahEAAAwBCyACLAAAQf4BcUEIRw0AIARB2ABqIgMgAkEBahAURQ0AIAQiACADKQIANwIAIAAgAykCCDcCCCAAIAMpAhA3AhAgACADKQIYNwIYIAAgAykCIDcCICAAQagBaiIGIAMQDCAAQYABaiIFIAMgBhAPIABBADYCUCAFIAUoAgBBB2o2AgAgAEEoaiIDIAUQF0UNACACLAAAQQFxBEAgAEHMAGoiBygCACIIQRZ2IgVB0QdsIAMoAgBqIQIgBUEGdCAAQSxqIgkoAgBqIAJBGnZqIgpBGnYgAEEwaiILKAIAaiIMQRp2IABBNGoiDSgCAGoiDkEadiAAQThqIg8oAgBqIhBBGnYgAEE8aiIRKAIAaiISQRp2IABBQGsiEygCAGoiFEEadiAAQcQAaiIVKAIAaiIWQRp2IABByABqIhcoAgBqIQUgA0G84f//ACACQf///x9xazYCACAJQfz9//8AIApB////H3FrNgIAIAtB/P///wAgDEH///8fcWs2AgAgDUH8////ACAOQf///x9xazYCACAPQfz///8AIBBB////H3FrNgIAIBFB/P///wAgEkH///8fcWs2AgAgE0H8////ACAUQf///x9xazYCACAVQfz///8AIBZB////H3FrNgIAIBdB/P///wAgBUH///8fcWs2AgAgB0H8//8HIAVBGnYgCEH///8BcWprNgIACyAAEBYgAUEBaiAAECEgASAGIAMQF0EJczoAACAEJARBAQ8LIAQkBEEAC5YBACABRQRAQdKmBCAAKAKsASAAKAKoAUEDcUEIahEAAEEADwsgAkUEQEHepgQgACgCrAEgACgCqAFBA3FBCGoRAABBAA8LIANFBEBB7KYEIAAoAqwBIAAoAqgBQQNxQQhqEQAAQQAPCyAAKAIIBH8gACABIAIgAxBfBUH5pQQgACgCrAEgACgCqAFBA3FBCGoRAABBAAsLxAsBHX8jBCEKIwRB0ANqJAQgCkEgaiEIIApBsAFqIQUgCkGsAWohBiAKQYADaiIRQQRqIgRCADcCACAEQgA3AgggBEIANwIQIARCADcCGCAEQQA2AiAgEUEENgIAIANBAEciBwRAIAggAyAGEBUgBigCAEUhAyAAQQhqIAUgCBAnBUEBIQMLIApByABqIgRB58yn0AY2AgAgBEEEaiILQYXdntt7NgIAIARBCGoiDEHy5rvjAzYCACAEQQxqIg1Buuq/qno2AgAgBEEQaiIOQf+kuYgFNgIAIARBFGoiD0GM0ZXYeTYCACAEQRhqIhJBq7OP/AE2AgAgBEEcaiIUQZmag98FNgIAIARBIGoiE0HAiAQpAgA3AgAgE0HIiAQpAgA3AgggBEEwaiIJIAIpAAA3AAAgCSACKQAINwAIIAkgAikAEDcAECAJIAIpABg3ABggCEEANgIAIAhBBGoiG0GAgISAeDYCACAEQoABNwJQIARB4ABqIhxBwAA2AgAgBCAIKQMANwJYIAQgExAQIAQoAgAQDSEGIARBADYCACALKAIAEA0hECALQQA2AgAgDCgCABANIRUgDEEANgIAIA0oAgAQDSEWIA1BADYCACAOKAIAEA0hFyAOQQA2AgAgDygCABANIRggD0EANgIAIBIoAgAQDSEZIBJBADYCACAUKAIAEA0hGiAUQQA2AgAgCiIAIAY2AgAgAEEEaiIdIBA2AgAgAEEIaiIeIBU2AgAgAEEMaiIVIBY2AgAgAEEQaiIWIBc2AgAgAEEUaiIXIBg2AgAgAEEYaiIYIBk2AgAgAEEcaiIZIBo2AgACfyARIAAQFCEfIABBrAJqIgYgERBBIAcEQCAFIAUgBhAiBSAFIAYoAlA2AnggBSAGKQIANwIAIAUgBikCCDcCCCAFIAYpAhA3AhAgBSAGKQIYNwIYIAUgBikCIDcCICAFQShqIgcgBkEoaiIQKQIANwIAIAcgECkCCDcCCCAHIBApAhA3AhAgByAQKQIYNwIYIAcgECkCIDcCICAFQQE2AlAgBUHUAGoiB0IANwIAIAdCADcCCCAHQgA3AhAgB0IANwIYIAdBADYCIAsgBEHnzKfQBjYCACALQYXdntt7NgIAIAxB8ua74wM2AgAgDUG66r+qejYCACAOQf+kuYgFNgIAIA9BjNGV2Hk2AgAgEkGrs4/8ATYCACAUQZmag98FNgIAIBNB4IgEKQIANwIAIBNB6IgEKQIANwIIIAkgAikAADcAACAJIAIpAAg3AAggCSACKQAQNwAQIAkgAikAGDcAGCAIQQA2AgAgG0GAgISAeDYCACAEQoABNwJQIBxBwAA2AgAgBCAIKQMANwJYIAQgExAQIAQoAgAQDSECIARBADYCACALKAIAEA0hBCALQQA2AgAgDCgCABANIQkgDEEANgIAIA0oAgAQDSELIA1BADYCACAOKAIAEA0hDCAOQQA2AgAgDygCABANIQ0gD0EANgIAIBIoAgAQDSEOIBJBADYCACAUKAIAEA0hDyAAIAI2AgAgHSAENgIAIB4gCTYCACAVIAs2AgAgFiAMNgIAIBcgDTYCACAYIA42AgAgGSAPNgIAIB8LIANxIBEgABAUcSEgIAYgERBBIAUgBSAGECIgBiAFKAJ4NgJQIAVB0ABqIgIgAhAgIAggAhAMIApBqANqIgQgAiAIEA8gBSAFIAgQDyAFQShqIgAgACAEEA8gAkEBNgIAIAVB1ABqIgJCADcCACACQgA3AgggAkIANwIQIAJCADcCGCACQQA2AiAgBiAFKQIANwIAIAYgBSkCCDcCCCAGIAUpAhA3AhAgBiAFKQIYNwIYIAYgBSkCIDcCICAGQShqIgIgACkCADcCACACIAApAgg3AgggAiAAKQIQNwIQIAIgACkCGDcCGCACIAApAiA3AiAgBhAcIAIQHCABIAYQISABQSBqIAIQISAKJAQgIAulAQEDfyMEIQMjBEGAAWokBCABRQRAQZilBCAAKAKsASAAKAKoAUEDcUEIahEAACADJARBAA8LIANB2ABqIQUgAyEEIAIEfyAEIAIQFBogBEEoaiIAIAJBIGoQFBogBEEANgJQIAEgBSAAEBdBC3M6AAAgBBAcIAFBAWogBBAhIAMkBEEBBUHSpgQgACgCrAEgACgCqAFBA3FBCGoRAAAgAyQEQQALC4kFARR/AkAjBCEEIwRB0AFqJAQgAUUEQEHSpgQgACgCrAEgACgCqAFBA3FBCGoRAAAMAQsgAkUEQEH4pAQgACgCrAEgACgCqAFBA3FBCGoRAAAMAQsgAiwAAEH+AXFBCkcNACAEQdgAaiIDIAJBAWoQFEUNACAEIgAgAykCADcCACAAIAMpAgg3AgggACADKQIQNwIQIAAgAykCGDcCGCAAIAMpAiA3AiAgAEGoAWoiBiADEAwgAEGAAWoiBSADIAYQDyAAQQA2AlAgBSAFKAIAQQdqNgIAIABBKGoiAyAFEBdFDQAgAiwAAEEBcQRAIABBzABqIgYoAgAiB0EWdiIFQdEHbCADKAIAaiECIAVBBnQgAEEsaiIIKAIAaiACQRp2aiIJQRp2IABBMGoiCigCAGoiC0EadiAAQTRqIgwoAgBqIg1BGnYgAEE4aiIOKAIAaiIPQRp2IABBPGoiECgCAGoiEUEadiAAQUBrIhIoAgBqIhNBGnYgAEHEAGoiFCgCAGoiFUEadiAAQcgAaiIWKAIAaiEFIANBvOH//wAgAkH///8fcWs2AgAgCEH8/f//ACAJQf///x9xazYCACAKQfz///8AIAtB////H3FrNgIAIAxB/P///wAgDUH///8fcWs2AgAgDkH8////ACAPQf///x9xazYCACAQQfz///8AIBFB////H3FrNgIAIBJB/P///wAgE0H///8fcWs2AgAgFEH8////ACAVQf///x9xazYCACAWQfz///8AIAVB////H3FrNgIAIAZB/P//ByAFQRp2IAdB////AXFqazYCAAsgABAcIAMQHCABIAAQISABQSBqIAMQISAEJARBAQ8LIAQkBEEAC+QR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AigCACIAQQFxQQBHcwRAIAJBvOH//wAgAGs2AgAgBEEsaiIAQfz9//8AIAAoAgBrNgIAIARBMGoiAEH8////ACAAKAIAazYCACAEQTRqIgBB/P///wAgACgCAGs2AgAgBEE4aiIAQfz///8AIAAoAgBrNgIAIARBPGoiAEH8////ACAAKAIAazYCACAEQUBrIgBB/P///wAgACgCAGs2AgAgBEHEAGoiAEH8////ACAAKAIAazYCACAEQcgAaiIAQfz///8AIAAoAgBrNgIAIARBzABqIgBB/P//ByAAKAIAazYCAAtBAQVBAAsFQQALIQAMAQsCQAJAAkAgAiwAAEEEaw4EAAEAAAELDAELDAILAn8gCiACQQFqEBQEfyAJIAJBIWoQFAR/IARBADYCUCAEIAopAgA3AgAgBCAKKQIINwIIIAQgCikCEDcCECAEIAopAhg3AhggBCAKKQIgNwIgIARBKGoiAyAJKQIANwIAIAMgCSkCCDcCCCADIAkpAhA3AhAgAyAJKQIYNwIYIAMgCSkCIDcCICACLAAAIgBB/gFxQQZGBEBBACAAQQdGIAkoAgBBAXFBAEdzDQMaCyAFIAMQDCAHIAQQDCAHIAcgBBAPIAcoAgBBB2ogBygCJCINQRZ2IgBB0QdsaiELIABBBnQgBygCBGogC0EadmoiDkEadiAHKAIIaiIPQRp2IAcoAgxqIhBBGnYgBygCEGoiEUEadiAHKAIUaiISQRp2IAcoAhhqIhNBGnYgBygCHGoiFEEadiAHKAIgaiEMIAUoAgQhFSAFKAIIIRYgBSgCDCEXIAUoAhAhByAFKAIUIQkgBSgCGCEKIAUoAhwhA0H8////ACAFKAIgayECIAUoAiQhACAGQbzh//8AIAUoAgBrIAtB////H3FqNgIAIAZB/P3//wAgFWsgDkH///8fcWo2AgQgBkH8////ACAWayAPQf///x9xajYCCCAGQfz///8AIBdrIBBB////H3FqNgIMIAZB/P///wAgB2sgEUH///8fcWo2AhAgBkH8////ACAJayASQf///x9xajYCFCAGQfz///8AIAprIBNB////H3FqNgIYIAZB/P///wAgA2sgFEH///8fcWo2AhwgBiACIAxB////H3FqNgIgIAYgDUH///8BcUH8//8HaiAAayAMQRp2ajYCJCAGECMFQQAL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AEHgiQQLqA5JbGxlZ2FsIGJ5dGUgc2VxdWVuY2UARG9tYWluIGVycm9yAFJlc3VsdCBub3QgcmVwcmVzZW50YWJsZQBOb3QgYSB0dHkAUGVybWlzc2lvbiBkZW5pZWQAT3BlcmF0aW9uIG5vdCBwZXJtaXR0ZWQATm8gc3VjaCBmaWxlIG9yIGRpcmVjdG9yeQBObyBzdWNoIHByb2Nlc3MARmlsZSBleGlzdHMAVmFsdWUgdG9vIGxhcmdlIGZvciBkYXRhIHR5cGUATm8gc3BhY2UgbGVmdCBvbiBkZXZpY2UAT3V0IG9mIG1lbW9yeQBSZXNvdXJjZSBidXN5AEludGVycnVwdGVkIHN5c3RlbSBjYWxsAFJlc291cmNlIHRlbXBvcmFyaWx5IHVuYXZhaWxhYmxlAEludmFsaWQgc2VlawBDcm9zcy1kZXZpY2UgbGluawBSZWFkLW9ubHkgZmlsZSBzeXN0ZW0ARGlyZWN0b3J5IG5vdCBlbXB0eQBDb25uZWN0aW9uIHJlc2V0IGJ5IHBlZXIAT3BlcmF0aW9uIHRpbWVkIG91dABDb25uZWN0aW9uIHJlZnVzZWQASG9zdCBpcyBkb3duAEhvc3QgaXMgdW5yZWFjaGFibGUAQWRkcmVzcyBpbiB1c2UAQnJva2VuIHBpcGUASS9PIGVycm9yAE5vIHN1Y2ggZGV2aWNlIG9yIGFkZHJlc3MAQmxvY2sgZGV2aWNlIHJlcXVpcmVkAE5vIHN1Y2ggZGV2aWNlAE5vdCBhIGRpcmVjdG9yeQBJcyBhIGRpcmVjdG9yeQBUZXh0IGZpbGUgYnVzeQBFeGVjIGZvcm1hdCBlcnJvcgBJbnZhbGlkIGFyZ3VtZW50AEFyZ3VtZW50IGxpc3QgdG9vIGxvbmcAU3ltYm9saWMgbGluayBsb29wAEZpbGVuYW1lIHRvbyBsb25nAFRvbyBtYW55IG9wZW4gZmlsZXMgaW4gc3lzdGVtAE5vIGZpbGUgZGVzY3JpcHRvcnMgYXZhaWxhYmxlAEJhZCBmaWxlIGRlc2NyaXB0b3IATm8gY2hpbGQgcHJvY2VzcwBCYWQgYWRkcmVzcwBGaWxlIHRvbyBsYXJnZQBUb28gbWFueSBsaW5rcwBObyBsb2NrcyBhdmFpbGFibGUAUmVzb3VyY2UgZGVhZGxvY2sgd291bGQgb2NjdXIAU3RhdGUgbm90IHJlY292ZXJhYmxlAFByZXZpb3VzIG93bmVyIGRpZWQAT3BlcmF0aW9uIGNhbmNlbGVkAEZ1bmN0aW9uIG5vdCBpbXBsZW1lbnRlZABObyBtZXNzYWdlIG9mIGRlc2lyZWQgdHlwZQBJZGVudGlmaWVyIHJlbW92ZWQARGV2aWNlIG5vdCBhIHN0cmVhbQBObyBkYXRhIGF2YWlsYWJsZQBEZXZpY2UgdGltZW91dABPdXQgb2Ygc3RyZWFtcyByZXNvdXJjZXMATGluayBoYXMgYmVlbiBzZXZlcmVkAFByb3RvY29sIGVycm9yAEJhZCBtZXNzYWdlAEZpbGUgZGVzY3JpcHRvciBpbiBiYWQgc3RhdGUATm90IGEgc29ja2V0AERlc3RpbmF0aW9uIGFkZHJlc3MgcmVxdWlyZWQATWVzc2FnZSB0b28gbGFyZ2UAUHJvdG9jb2wgd3JvbmcgdHlwZSBmb3Igc29ja2V0AFByb3RvY29sIG5vdCBhdmFpbGFibGUAUHJvdG9jb2wgbm90IHN1cHBvcnRlZABTb2NrZXQgdHlwZSBub3Qgc3VwcG9ydGVkAE5vdCBzdXBwb3J0ZWQAUHJvdG9jb2wgZmFtaWx5IG5vdCBzdXBwb3J0ZWQAQWRkcmVzcyBmYW1pbHkgbm90IHN1cHBvcnRlZCBieSBwcm90b2NvbABBZGRyZXNzIG5vdCBhdmFpbGFibGUATmV0d29yayBpcyBkb3duAE5ldHdvcmsgdW5yZWFjaGFibGUAQ29ubmVjdGlvbiByZXNldCBieSBuZXR3b3JrAENvbm5lY3Rpb24gYWJvcnRlZABObyBidWZmZXIgc3BhY2UgYXZhaWxhYmxlAFNvY2tldCBpcyBjb25uZWN0ZWQAU29ja2V0IG5vdCBjb25uZWN0ZWQAQ2Fubm90IHNlbmQgYWZ0ZXIgc29ja2V0IHNodXRkb3duAE9wZXJhdGlvbiBhbHJlYWR5IGluIHByb2dyZXNzAE9wZXJhdGlvbiBpbiBwcm9ncmVzcwBTdGFsZSBmaWxlIGhhbmRsZQBSZW1vdGUgSS9PIGVycm9yAFF1b3RhIGV4Y2VlZGVkAE5vIG1lZGl1bSBmb3VuZABXcm9uZyBtZWRpdW0gdHlwZQBObyBlcnJvciBpbmZvcm1hdGlvbgAAAAAAABEACgAREREAAAAABQAAAAAAAAkAAAAACwBBkJgECyERAA8KERERAwoHAAETCQsLAAAJBgsAAAsABhEAAAAREREAQcGYBAsBCwBBypgECxgRAAoKERERAAoAAAIACQsAAAAJAAsAAAsAQfuYBAsBDABBh5kECxUMAAAAAAwAAAAACQwAAAAAAAwAAAwAQbWZBAsBDgBBwZkECxUNAAAABA0AAAAACQ4AAAAAAA4AAA4AQe+ZBAsBEABB+5kECx4PAAAAAA8AAAAACRAAAAAAABAAABAAABIAAAASEhIAQbKaBAsOEgAAABISEgAAAAAAAAkAQeOaBAsBCwBB75oECxUKAAAAAAoAAAAACQsAAAAAAAsAAAsAQZ2bBAsBDABBqZsECzAMAAAAAAwAAAAACQwAAAAAAAwAAAwAADAxMjM0NTY3ODlBQkNERUYBAAAAAAAAAAIAQYidBAsJAQAAAAAAAAACAEGcnQQLpAGYF/gCxVagAJ+VjQI4t2wD/JsCA8HCoQNcKQYCVrHuAtz5fgKZbx4AuNQQA/4j9AHEmUEBFZoiAbQX/QAqQoQDwL9PAnaVEQOjJncCtg4SAAAAAAAxsNtFmiCT6H/K6HEUiqo9FeuEkuSQbOjNa9SnIdKGMHF/xIqutHEVxgb1nawIEiLE5L8KqX9UbyiIDgHWfkPkw+S/Cql/VG8oiA4B1n5D5ABB0J4EC70BLFaxPajNZddtNHQHxQooiv7///////////////////9yvSMbfJYC33hmgSDqIi4SWmQSiAIcJqXgMFzATK1jU+4BlQEcClsCE1yZANZL1AFJ8JwBOg0NA+p5RAK5QRwAfGUrAlq6HgBS+NUAh+tJA9hHzQJTaFcAbR/GAIvl5QEqDHcDjHzHAwc1qQNKiwIAQPpqAqP1pAHso2YDKbQrArYPYwLF8vIAFYa7AUa+4wODmtQBpUUhAAwQAQAFAEGYoAQLAQEAQbCgBAsLAQAAAAIAAAA9GQEAQcigBAsBAgBB16AECwX//////wBBxKIECwMYGQEAQfyiBAuBC1tsaWJzZWNwMjU2azFdIGludGVybmFsIGNvbnNpc3RlbmN5IGNoZWNrIGZhaWxlZDogJXMKAFtsaWJzZWNwMjU2azFdIGlsbGVnYWwgYXJndW1lbnQ6ICVzCgABSW52YWxpZCBmbGFncwBGb3IgdGhpcyBzYW1wbGUsIHRoaXMgNjMtYnl0ZSBzdHJpbmcgd2lsbCBiZSB1c2VkIGFzIGlucHV0IGRhdGEAc2VsZiB0ZXN0IGZhaWxlZABPdXQgb2YgbWVtb3J5AGN0eCAhPSBzZWNwMjU2azFfY29udGV4dF9ub19wcmVjb21wAHB1YmtleSAhPSBOVUxMAGlucHV0ICE9IE5VTEwAb3V0cHV0bGVuICE9IE5VTEwAb3V0cHV0ICE9IE5VTEwAIXNlY3AyNTZrMV9mZV9pc196ZXJvKCZnZS0+eCkAc2VjcDI1NmsxX2VjbXVsdF9jb250ZXh0X2lzX2J1aWx0KCZjdHgtPmVjbXVsdF9jdHgpAHNlY3AyNTZrMV9lY211bHRfZ2VuX2NvbnRleHRfaXNfYnVpbHQoJmN0eC0+ZWNtdWx0X2dlbl9jdHgpAHBvaW50ICE9IE5VTEwAc2NhbGFyICE9IE5VTEwAZ2VuICE9IE5VTEwAa2V5MzIgIT0gTlVMTABibGluZDMyICE9IE5VTEwAY29tbWl0ICE9IE5VTEwAYmxpbmQgIT0gTlVMTABibGluZF9vdXQgIT0gTlVMTABibGluZHMgIT0gTlVMTABucG9zaXRpdmUgPD0gbgAhcGNudCB8fCAoY29tbWl0cyAhPSBOVUxMKQAhbmNudCB8fCAobmNvbW1pdHMgIT0gTlVMTCkAbl90b3RhbCA9PSAwIHx8IHZhbHVlICE9IE5VTEwAbl90b3RhbCA9PSAwIHx8IGdlbmVyYXRvcl9ibGluZCAhPSBOVUxMAG5fdG90YWwgPT0gMCB8fCBibGluZGluZ19mYWN0b3IgIT0gTlVMTABuX3RvdGFsID4gbl9pbnB1dHMAZXhwICE9IE5VTEwAbWFudGlzc2EgIT0gTlVMTABtaW5fdmFsdWUgIT0gTlVMTABtYXhfdmFsdWUgIT0gTlVMTABwcm9vZiAhPSBOVUxMAG1lc3NhZ2Vfb3V0ICE9IE5VTEwgfHwgb3V0bGVuID09IE5VTEwAbm9uY2UgIT0gTlVMTABleHRyYV9jb21taXQgIT0gTlVMTCB8fCBleHRyYV9jb21taXRfbGVuID09IDAAcGxlbiAhPSBOVUxMAG1lc3NhZ2UgIT0gTlVMTCB8fCBtc2dfbGVuID09IDAAaW5wdXRfaW5kZXggIT0gTlVMTABmaXhlZF9pbnB1dF90YWdzICE9IE5VTEwAZml4ZWRfb3V0cHV0X3RhZyAhPSBOVUxMAHJhbmRvbV9zZWVkMzIgIT0gTlVMTABuX2lucHV0X3RhZ3MgPD0gU0VDUDI1NksxX1NVUkpFQ1RJT05QUk9PRl9NQVhfTl9JTlBVVFMAbl9pbnB1dF90YWdzX3RvX3VzZSA8PSBTRUNQMjU2SzFfU1VSSkVDVElPTlBST09GX01BWF9VU0VEX0lOUFVUUwBuX2lucHV0X3RhZ3NfdG9fdXNlIDw9IG5faW5wdXRfdGFncwBlcGhlbWVyYWxfaW5wdXRfdGFncyAhPSBOVUxMAGVwaGVtZXJhbF9vdXRwdXRfdGFnICE9IE5VTEwAaW5wdXRfYmxpbmRpbmdfa2V5ICE9IE5VTEwAb3V0cHV0X2JsaW5kaW5nX2tleSAhPSBOVUxMAC0rICAgMFgweAAobnVsbCkALTBYKzBYIDBYLTB4KzB4IDB4AGluZgBJTkYAbmFuAE5BTgAu";var asmjsCodeFile="";if(!isDataURI(wasmTextFile)){wasmTextFile=locateFile(wasmTextFile)}if(!isDataURI(wasmBinaryFile)){wasmBinaryFile=locateFile(wasmBinaryFile)}if(!isDataURI(asmjsCodeFile)){asmjsCodeFile=locateFile(asmjsCodeFile)}var wasmPageSize=64*1024;var info={"global":null,"env":null,"asm2wasm":asm2wasmImports,"parent":Module};var exports=null;function mergeMemory(newBuffer){var oldBuffer=Module["buffer"];if(newBuffer.byteLength<oldBuffer.byteLength){err("the new buffer in mergeMemory is smaller than the previous one. in native wasm, we should grow memory here")}var oldView=new Int8Array(oldBuffer);var newView=new Int8Array(newBuffer);newView.set(oldView);updateGlobalBuffer(newBuffer);updateGlobalBufferViews()}function fixImports(imports){return imports}function getBinary(){try{if(Module["wasmBinary"]){return new Uint8Array(Module["wasmBinary"])}var binary=tryParseAsDataURI(wasmBinaryFile);if(binary){return binary}if(Module["readBinary"]){return Module["readBinary"](wasmBinaryFile)}else{throw"both async and sync fetching of the wasm failed"}}catch(err){abort(err)}}function getBinaryPromise(){if(!Module["wasmBinary"]&&(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER)&&typeof fetch==="function"){return fetch(wasmBinaryFile,{credentials:"same-origin"}).then((function(response){if(!response["ok"]){throw"failed to load wasm binary file at '"+wasmBinaryFile+"'"}return response["arrayBuffer"]()})).catch((function(){return getBinary()}))}return new Promise((function(resolve,reject){resolve(getBinary())}))}function doNativeWasm(global,env,providedBuffer){if(typeof WebAssembly!=="object"){err("no native wasm support detected");return false}if(!(Module["wasmMemory"]instanceof WebAssembly.Memory)){err("no native wasm Memory in use");return false}env["memory"]=Module["wasmMemory"];info["global"]={"NaN":NaN,"Infinity":Infinity};info["global.Math"]=Math;info["env"]=env;function receiveInstance(instance,module){exports=instance.exports;if(exports.memory)mergeMemory(exports.memory);Module["asm"]=exports;Module["usingWasm"]=true;removeRunDependency("wasm-instantiate")}addRunDependency("wasm-instantiate");if(Module["instantiateWasm"]){try{return Module["instantiateWasm"](info,receiveInstance)}catch(e){err("Module.instantiateWasm callback failed with error: "+e);return false}}function receiveInstantiatedSource(output){receiveInstance(output["instance"],output["module"])}function instantiateArrayBuffer(receiver){getBinaryPromise().then((function(binary){return WebAssembly.instantiate(binary,info)})).then(receiver).catch((function(reason){err("failed to asynchronously prepare wasm: "+reason);abort(reason)}))}if(!Module["wasmBinary"]&&typeof WebAssembly.instantiateStreaming==="function"&&!isDataURI(wasmBinaryFile)&&typeof fetch==="function"){WebAssembly.instantiateStreaming(fetch(wasmBinaryFile,{credentials:"same-origin"}),info).then(receiveInstantiatedSource).catch((function(reason){err("wasm streaming compile failed: "+reason);err("falling back to ArrayBuffer instantiation");instantiateArrayBuffer(receiveInstantiatedSource)}))}else{instantiateArrayBuffer(receiveInstantiatedSource)}return{}}Module["asmPreload"]=Module["asm"];var asmjsReallocBuffer=Module["reallocBuffer"];var wasmReallocBuffer=(function(size){var PAGE_MULTIPLE=Module["usingWasm"]?WASM_PAGE_SIZE:ASMJS_PAGE_SIZE;size=alignUp(size,PAGE_MULTIPLE);var old=Module["buffer"];var oldSize=old.byteLength;if(Module["usingWasm"]){try{var result=Module["wasmMemory"].grow((size-oldSize)/wasmPageSize);if(result!==(-1|0)){return Module["buffer"]=Module["wasmMemory"].buffer}else{return null}}catch(e){return null}}});Module["reallocBuffer"]=(function(size){if(finalMethod==="asmjs"){return asmjsReallocBuffer(size)}else{return wasmReallocBuffer(size)}});var finalMethod="";Module["asm"]=(function(global,env,providedBuffer){env=fixImports(env);if(!env["table"]){var TABLE_SIZE=Module["wasmTableSize"];if(TABLE_SIZE===undefined)TABLE_SIZE=1024;var MAX_TABLE_SIZE=Module["wasmMaxTableSize"];if(typeof WebAssembly==="object"&&typeof WebAssembly.Table==="function"){if(MAX_TABLE_SIZE!==undefined){env["table"]=new WebAssembly.Table({"initial":TABLE_SIZE,"maximum":MAX_TABLE_SIZE,"element":"anyfunc"})}else{env["table"]=new WebAssembly.Table({"initial":TABLE_SIZE,element:"anyfunc"})}}else{env["table"]=new Array(TABLE_SIZE)}Module["wasmTable"]=env["table"]}if(!env["memoryBase"]){env["memoryBase"]=Module["STATIC_BASE"]}if(!env["tableBase"]){env["tableBase"]=0}var exports;exports=doNativeWasm(global,env,providedBuffer);assert(exports,"no binaryen method succeeded.");return exports})}integrateWasmJS();STATIC_BASE=GLOBAL_BASE;STATICTOP=STATIC_BASE+72e3;__ATINIT__.push();var STATIC_BUMP=72e3;Module["STATIC_BASE"]=STATIC_BASE;Module["STATIC_BUMP"]=STATIC_BUMP;STATICTOP+=16;var SYSCALLS={varargs:0,get:(function(varargs){SYSCALLS.varargs+=4;var ret=HEAP32[SYSCALLS.varargs-4>>2];return ret}),getStr:(function(){var ret=Pointer_stringify(SYSCALLS.get());return ret}),get64:(function(){var low=SYSCALLS.get(),high=SYSCALLS.get();if(low>=0)assert(high===0);else assert(high===-1);return low}),getZero:(function(){assert(SYSCALLS.get()===0)})};function ___syscall140(which,varargs){SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.getStreamFromFD(),offset_high=SYSCALLS.get(),offset_low=SYSCALLS.get(),result=SYSCALLS.get(),whence=SYSCALLS.get();var offset=offset_low;FS.llseek(stream,offset,whence);HEAP32[result>>2]=stream.position;if(stream.getdents&&offset===0&&whence===0)stream.getdents=null;return 0}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return-e.errno}}function ___syscall146(which,varargs){SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.get(),iov=SYSCALLS.get(),iovcnt=SYSCALLS.get();var ret=0;if(!___syscall146.buffers){___syscall146.buffers=[null,[],[]];___syscall146.printChar=(function(stream,curr){var buffer=___syscall146.buffers[stream];assert(buffer);if(curr===0||curr===10){(stream===1?out:err)(UTF8ArrayToString(buffer,0));buffer.length=0}else{buffer.push(curr)}})}for(var i=0;i<iovcnt;i++){var ptr=HEAP32[iov+i*8>>2];var len=HEAP32[iov+(i*8+4)>>2];for(var j=0;j<len;j++){___syscall146.printChar(stream,HEAPU8[ptr+j])}ret+=len}return ret}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return-e.errno}}function ___syscall6(which,varargs){SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.getStreamFromFD();FS.close(stream);return 0}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return-e.errno}}function _abort(){Module["abort"]()}function _llvm_stackrestore(p){var self=_llvm_stacksave;var ret=self.LLVM_SAVEDSTACKS[p];self.LLVM_SAVEDSTACKS.splice(p,1);stackRestore(ret)}function _llvm_stacksave(){var self=_llvm_stacksave;if(!self.LLVM_SAVEDSTACKS){self.LLVM_SAVEDSTACKS=[]}self.LLVM_SAVEDSTACKS.push(stackSave());return self.LLVM_SAVEDSTACKS.length-1}function _emscripten_memcpy_big(dest,src,num){HEAPU8.set(HEAPU8.subarray(src,src+num),dest);return dest}function ___setErrNo(value){if(Module["___errno_location"])HEAP32[Module["___errno_location"]()>>2]=value;return value}DYNAMICTOP_PTR=staticAlloc(4);STACK_BASE=STACKTOP=alignMemory(STATICTOP);STACK_MAX=STACK_BASE+TOTAL_STACK;DYNAMIC_BASE=alignMemory(STACK_MAX);HEAP32[DYNAMICTOP_PTR>>2]=DYNAMIC_BASE;staticSealed=true;var ASSERTIONS=false;function intArrayToString(array){var ret=[];for(var i=0;i<array.length;i++){var chr=array[i];if(chr>255){if(ASSERTIONS){assert(false,"Character code "+chr+" ("+String.fromCharCode(chr)+")  at offset "+i+" not in 0x00-0xFF.")}chr&=255}ret.push(String.fromCharCode(chr))}return ret.join("")}var decodeBase64=typeof atob==="function"?atob:(function(input){var keyStr="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";var output="";var chr1,chr2,chr3;var enc1,enc2,enc3,enc4;var i=0;input=input.replace(/[^A-Za-z0-9\+\/\=]/g,"");do{enc1=keyStr.indexOf(input.charAt(i++));enc2=keyStr.indexOf(input.charAt(i++));enc3=keyStr.indexOf(input.charAt(i++));enc4=keyStr.indexOf(input.charAt(i++));chr1=enc1<<2|enc2>>4;chr2=(enc2&15)<<4|enc3>>2;chr3=(enc3&3)<<6|enc4;output=output+String.fromCharCode(chr1);if(enc3!==64){output=output+String.fromCharCode(chr2)}if(enc4!==64){output=output+String.fromCharCode(chr3)}}while(i<input.length);return output});function intArrayFromBase64(s){if(typeof ENVIRONMENT_IS_NODE==="boolean"&&ENVIRONMENT_IS_NODE){var buf;try{buf=Buffer.from(s,"base64")}catch(_){buf=new Buffer(s,"base64")}return new Uint8Array(buf.buffer,buf.byteOffset,buf.byteLength)}try{var decoded=decodeBase64(s);var bytes=new Uint8Array(decoded.length);for(var i=0;i<decoded.length;++i){bytes[i]=decoded.charCodeAt(i)}return bytes}catch(_){throw new Error("Converting base64 string to bytes failed.")}}function tryParseAsDataURI(filename){if(!isDataURI(filename)){return}return intArrayFromBase64(filename.slice(dataURIPrefix.length))}Module["wasmTableSize"]=12;Module["wasmMaxTableSize"]=12;Module.asmGlobalArg={};Module.asmLibraryArg={"abort":abort,"enlargeMemory":enlargeMemory,"getTotalMemory":getTotalMemory,"abortOnCannotGrowMemory":abortOnCannotGrowMemory,"___setErrNo":___setErrNo,"___syscall140":___syscall140,"___syscall146":___syscall146,"___syscall6":___syscall6,"_abort":_abort,"_emscripten_memcpy_big":_emscripten_memcpy_big,"_llvm_stackrestore":_llvm_stackrestore,"_llvm_stacksave":_llvm_stacksave,"DYNAMICTOP_PTR":DYNAMICTOP_PTR,"STACKTOP":STACKTOP};var asm=Module["asm"](Module.asmGlobalArg,Module.asmLibraryArg,buffer);Module["asm"]=asm;var _ecdh=Module["_ecdh"]=(function(){return Module["asm"]["_ecdh"].apply(null,arguments)});var _emscripten_replace_memory=Module["_emscripten_replace_memory"]=(function(){return Module["asm"]["_emscripten_replace_memory"].apply(null,arguments)});var _free=Module["_free"]=(function(){return Module["asm"]["_free"].apply(null,arguments)});var _generator_generate_blinded=Module["_generator_generate_blinded"]=(function(){return Module["asm"]["_generator_generate_blinded"].apply(null,arguments)});var _generator_parse=Module["_generator_parse"]=(function(){return Module["asm"]["_generator_parse"].apply(null,arguments)});var _generator_serialize=Module["_generator_serialize"]=(function(){return Module["asm"]["_generator_serialize"].apply(null,arguments)});var _malloc=Module["_malloc"]=(function(){return Module["asm"]["_malloc"].apply(null,arguments)});var _pedersen_blind_generator_blind_sum=Module["_pedersen_blind_generator_blind_sum"]=(function(){return Module["asm"]["_pedersen_blind_generator_blind_sum"].apply(null,arguments)});var _pedersen_blind_sum=Module["_pedersen_blind_sum"]=(function(){return Module["asm"]["_pedersen_blind_sum"].apply(null,arguments)});var _pedersen_commit=Module["_pedersen_commit"]=(function(){return Module["asm"]["_pedersen_commit"].apply(null,arguments)});var _pedersen_commitment_parse=Module["_pedersen_commitment_parse"]=(function(){return Module["asm"]["_pedersen_commitment_parse"].apply(null,arguments)});var _pedersen_commitment_serialize=Module["_pedersen_commitment_serialize"]=(function(){return Module["asm"]["_pedersen_commitment_serialize"].apply(null,arguments)});var _pedersen_verify_tally=Module["_pedersen_verify_tally"]=(function(){return Module["asm"]["_pedersen_verify_tally"].apply(null,arguments)});var _rangeproof_info=Module["_rangeproof_info"]=(function(){return Module["asm"]["_rangeproof_info"].apply(null,arguments)});var _rangeproof_rewind=Module["_rangeproof_rewind"]=(function(){return Module["asm"]["_rangeproof_rewind"].apply(null,arguments)});var _rangeproof_sign=Module["_rangeproof_sign"]=(function(){return Module["asm"]["_rangeproof_sign"].apply(null,arguments)});var _rangeproof_verify=Module["_rangeproof_verify"]=(function(){return Module["asm"]["_rangeproof_verify"].apply(null,arguments)});var _surjectionproof_generate=Module["_surjectionproof_generate"]=(function(){return Module["asm"]["_surjectionproof_generate"].apply(null,arguments)});var _surjectionproof_initialize=Module["_surjectionproof_initialize"]=(function(){return Module["asm"]["_surjectionproof_initialize"].apply(null,arguments)});var _surjectionproof_parse=Module["_surjectionproof_parse"]=(function(){return Module["asm"]["_surjectionproof_parse"].apply(null,arguments)});var _surjectionproof_serialize=Module["_surjectionproof_serialize"]=(function(){return Module["asm"]["_surjectionproof_serialize"].apply(null,arguments)});var _surjectionproof_verify=Module["_surjectionproof_verify"]=(function(){return Module["asm"]["_surjectionproof_verify"].apply(null,arguments)});var stackAlloc=Module["stackAlloc"]=(function(){return Module["asm"]["stackAlloc"].apply(null,arguments)});var stackRestore=Module["stackRestore"]=(function(){return Module["asm"]["stackRestore"].apply(null,arguments)});var stackSave=Module["stackSave"]=(function(){return Module["asm"]["stackSave"].apply(null,arguments)});Module["asm"]=asm;Module["ccall"]=ccall;Module["setValue"]=setValue;Module["getValue"]=getValue;Module["then"]=(function(func){if(Module["calledRun"]){func(Module)}else{var old=Module["onRuntimeInitialized"];Module["onRuntimeInitialized"]=(function(){if(old)old();func(Module)})}return Module});function ExitStatus(status){this.name="ExitStatus";this.message="Program terminated with exit("+status+")";this.status=status}ExitStatus.prototype=new Error;ExitStatus.prototype.constructor=ExitStatus;dependenciesFulfilled=function runCaller(){if(!Module["calledRun"])run();if(!Module["calledRun"])dependenciesFulfilled=runCaller};function run(args){args=args||Module["arguments"];if(runDependencies>0){return}preRun();if(runDependencies>0)return;if(Module["calledRun"])return;function doRun(){if(Module["calledRun"])return;Module["calledRun"]=true;if(ABORT)return;ensureInitRuntime();preMain();if(Module["onRuntimeInitialized"])Module["onRuntimeInitialized"]();postRun()}if(Module["setStatus"]){Module["setStatus"]("Running...");setTimeout((function(){setTimeout((function(){Module["setStatus"]("")}),1);doRun()}),1)}else{doRun()}}Module["run"]=run;function abort(what){if(Module["onAbort"]){Module["onAbort"](what)}if(what!==undefined){out(what);err(what);what=JSON.stringify(what)}else{what=""}ABORT=true;EXITSTATUS=1;throw"abort("+what+"). Build with -s ASSERTIONS=1 for more info."}Module["abort"]=abort;if(Module["preInit"]){if(typeof Module["preInit"]=="function")Module["preInit"]=[Module["preInit"]];while(Module["preInit"].length>0){Module["preInit"].pop()()}}Module["noExitRuntime"]=true;run()





  return Module;
}
);
})();
if (typeof exports === 'object' && typeof module === 'object')
    module.exports = Module;
  else if (typeof define === 'function' && define['amd'])
    define([], function() { return Module; });
  else if (typeof exports === 'object')
    exports["Module"] = Module;
  
}).call(this)}).call(this,require('_process'),require("buffer").Buffer,"/node_modules/@vulpemventures/secp256k1-zkp/dist")
},{"_process":116,"buffer":110,"fs":107,"path":115}],2:[function(require,module,exports){
(function (Buffer){(function (){
const lib = require('../dist/secp256k1-zkp.js');
const Long = require('long');

module.exports = () => {
  return new Promise((resolve) => {
    lib().then((Module) => {
      let free = [];

      function malloc(size) {
        const ptr = Module._malloc(size);
        free.push(ptr);
        return ptr;
      }

      function freeMalloc() {
        for (const ptr of free) {
          Module._free(ptr);
        }
        free = [];
      }

      /**
       *  @summary Calculates a ECDH point.
       *  @return {Array} 32-bytes ecdh point.
       *  @throws {Error} Decode error.
       *  @arg {Array} pubkey - 33-byte pubkey.
       *  @arg {Array} scalar - 32-byte scalar.
       *  @exports
       */
      function ecdh(pubkey, scalar) {
        const output = malloc(32);
        const ret = Module.ccall(
          'ecdh',
          'number',
          ['number', 'number', 'number'],
          [output, charStar(pubkey), charStar(scalar)]
        );

        if (ret === 1) {
          const out = new Uint8Array(
            Module.HEAPU8.subarray(output, output + 32)
          );
          freeMalloc();
          return Buffer.from(out);
        } else {
          freeMalloc();
          throw new Error('secp256k1_ecdh', ret);
        }
      }

      /**
       *  @summary Generates a blinding generator with a blinding factor.
       *  @return {Array} 64-byte generator successfully computed.
       *  @throws {Error} Decode error.
       *  @arg {Array} key - 32-byte array key.
       *  @arg {Array} blind - 32-byte array blinding factor.
       *  @exports
       */
      function generateBlinded(key, blind) {
        if (!key || !Buffer.isBuffer(key) || key.length !== 32)
          throw new TypeError('key must be a Buffer of 32 bytes');
        if (!blind || !Buffer.isBuffer(blind) || blind.length !== 32)
          throw new TypeError('blind must be a Buffer of 32 bytes');

        const output = malloc(64);

        const ret = Module.ccall(
          'generator_generate_blinded',
          'number',
          ['number', 'number', 'number'],
          [output, charStar(key), charStar(blind)]
        );
        if (ret === 1) {
          const out = new Uint8Array(
            Module.HEAPU8.subarray(output, output + 64)
          );
          freeMalloc();
          return Buffer.from(out);
        } else {
          freeMalloc();
          throw new Error('secp256k1_generator_generate_blinded', ret);
        }
      }

      /**
       *  @summary Parses a serialized generator.
       *  @return {Array} 64-bytes generator.
       *  @throws {Error} Decode error.
       *  @arg {Array} input - 33-byte serialized generator.
       *  @exports
       */
      function parse(input) {
        if (!input || !Buffer.isBuffer(input) || input.length !== 33)
          throw new TypeError('input must be a Buffer of 32 bytes');

        const gen = malloc(64);

        const ret = Module.ccall(
          'generator_parse',
          'number',
          ['number', 'number'],
          [gen, charStar(input)]
        );
        if (ret === 1) {
          const out = new Uint8Array(Module.HEAPU8.subarray(gen, gen + 64));
          freeMalloc();
          return Buffer.from(out);
        } else {
          freeMalloc();
          throw new Error('secp256k1_generator_parse', ret);
        }
      }

      /**
       *  @summary Serializes a generator.
       *  @return {Array} 33-bytes serialized generator.
       *  @throws {Error} Decode error.
       *  @arg {Array} generator - 64-byte generator.
       *  @exports
       */
      function serialize(generator) {
        if (
          !generator ||
          !Buffer.isBuffer(generator) ||
          generator.length !== 64
        )
          throw new TypeError('generator must be a Buffer of 32 bytes');

        const output = malloc(33);
        const ret = Module.ccall(
          'generator_serialize',
          'number',
          ['number', 'number'],
          [output, charStar(generator)]
        );
        if (ret === 1) {
          const out = new Uint8Array(
            Module.HEAPU8.subarray(output, output + 33)
          );
          freeMalloc();
          return Buffer.from(out);
        } else {
          freeMalloc();
          throw new Error('secp256k1_generator_parse', ret);
        }
      }

      /**
       *  @summary Generates a pedersen commitment.
       *  @return {Array} 33-bytes commitment successfully created.
       *  @throws {Error} - Decode error.
       *  @arg {Array} blindFactor - 32-byte blinding factor.
       *  @arg {string} value - unsigned 64-bit integer value to commit to as string.
       *  @arg {Array} generator - 64-byte generator.
       *  @exports
       */
      function commit(blindFactor, value, generator) {
        if (
          !blindFactor ||
          !Buffer.isBuffer(blindFactor) ||
          blindFactor.length !== 32
        )
          throw new TypeError('blindFactor must be a Buffer of 32 bytes');
        if (
          !generator ||
          !Buffer.isBuffer(generator) ||
          generator.length !== 64
        )
          throw new TypeError('generator must be a Buffer of 64 bytes');

        const commitment = malloc(64);
        const valueLong = Long.fromString(value, true);

        const ret = Module.ccall(
          'pedersen_commit',
          'number',
          ['number', 'number', 'number', 'number'],
          [
            commitment,
            charStar(blindFactor),
            valueLong.low,
            valueLong.high,
            charStar(generator),
          ]
        );
        if (ret === 1) {
          const out = new Uint8Array(
            Module.HEAPU8.subarray(commitment, commitment + 64)
          );
          freeMalloc();
          return Buffer.from(out);
        } else {
          freeMalloc();
          throw new Error('secp256k1_pedersen_commit', ret);
        }
      }

      /**
       *  @summary Serializes a pedersen commitment.
       *  @return {Array} 33-bytes serialized pedersen commitment.
       *  @throws {Error} - Decode error.
       *  @arg {Array} commitment - 64-byte pedersen commitment (cannot be NULL).
       *  @exports
       */
      function commitSerialize(commitment) {
        if (
          !commitment ||
          !Buffer.isBuffer(commitment) ||
          commitment.length !== 64
        )
          throw new TypeError('commitment must be a Buffer of 64 bytes');

        const out = malloc(33);

        const ret = Module.ccall(
          'pedersen_commitment_serialize',
          'number',
          ['number', 'number'],
          [out, charStar(commitment)]
        );
        if (ret === 1) {
          const cmt = new Uint8Array(Module.HEAPU8.subarray(out, out + 33));
          freeMalloc();
          return Buffer.from(cmt);
        } else {
          freeMalloc();
          throw new Error('secp256k1_pedersen_commitment_serialize', ret);
        }
      }

      /**
       *  @summary Parses a pedersen commitment.
       *  @return {Array} 64-bytes pedersen commitment.
       *  @throws {Error} - Decode error.
       *  @arg {Array} input - 33-byte commitment to parse (cannot be NULL).
       *  @exports
       */
      function commitParse(input) {
        if (!input || !Buffer.isBuffer(input) || input.length !== 33)
          throw new TypeError('input must be a Buffer of 33 bytes');

        const commitment = malloc(64);
        const ret = Module.ccall(
          'pedersen_commitment_parse',
          'number',
          ['number', 'number'],
          [commitment, charStar(input)]
        );
        if (ret === 1) {
          const cmt = new Uint8Array(
            Module.HEAPU8.subarray(commitment, commitment + 64)
          );
          freeMalloc();
          return Buffer.from(cmt);
        } else {
          freeMalloc();
          throw new Error('secp256k1_pedersen_commitment_parse', ret);
        }
      }

      /**
       *  @summary Sets the final blinding factor correctly when the generators themselves have blinding factors.
       *  @return {Array} 32-bytes final blinding factor.
       *  @throws {Error} - Decode error.
       *  @arg {Array} values - array of asset values as string.
       *  @arg {number} nInputs - How many of the initial array elements represent commitments that will be negated in the final sum.
       *  @arg {Array} blindGenerators - array of asset blinding factors.
       *  @arg {Array} blindFactors - array of commitment blinding factors.
       *  @exports
       */
      function blindGeneratorBlindSum(
        values,
        nInputs,
        blindGenerators,
        blindFactors
      ) {
        if (
          !blindGenerators ||
          !Array.isArray(blindGenerators) ||
          !blindGenerators.length
        )
          throw new TypeError(
            'blindGenerators must be a non empty array of Buffers'
          );
        if (!blindFactors || !Array.isArray(blindFactors))
          throw new TypeError('blindFactors must be an array of Buffers');

        const longValues = values.map((v) => Long.fromString(v, true));
        const blindOut = malloc(32);
        const ret = Module.ccall(
          'pedersen_blind_generator_blind_sum',
          'number',
          ['number', 'number', 'number', 'number', 'number', 'number'],
          [
            longIntStarArray(longValues),
            charStarArray(blindGenerators),
            charStarArray(blindFactors),
            blindGenerators.length,
            nInputs,
            blindOut,
          ]
        );
        if (ret === 1) {
          const output = new Uint8Array(
            Module.HEAPU8.subarray(blindOut, blindOut + 32)
          );
          freeMalloc();
          return Buffer.from(output);
        } else {
          freeMalloc();
          throw new Error('secp256k1_pedersen_blind_generator_blind_sum', ret);
        }
      }

      /**
       *  @summary Computes the sum of multiple positive and negative blinding factors.
       *  @return {Array} 32-bytes sum successfully computed.
       *  @throws {Error} Decode error.
       *  @arg {Array} blinds - 32-byte character arrays for blinding factors.
       *  @arg {number} [nneg = 0] - how many of the initial factors should be treated with a negative sign.
       *  @exports
       */
      function blindSum(blinds, nneg = 0) {
        if (!blinds || !Array.isArray(blinds) || !blinds.length)
          throw new TypeError('blinds must be a non empty array of Buffers');

        const sum = malloc(32);
        const ret = Module.ccall(
          'pedersen_blind_sum',
          'number',
          ['number', 'number', 'number', 'number'],
          [sum, charStarArray(blinds), blinds.length, blinds.length - nneg]
        );
        if (ret === 1) {
          const s = new Uint8Array(Module.HEAPU8.subarray(sum, sum + 32));
          freeMalloc();
          return Buffer.from(s);
        } else {
          freeMalloc();
          throw new Error('secp256k1_pedersen_blind_sum', ret);
        }
      }

      /**
       * @summary Verifies pedersen commitments - negativeCommits - excess === 0
       * @return {boolean} commitments successfully sum to zero.
       * @throws {Error} Commitments do not sum to zero or other error.
       * @arg {Array} commits: pointer to pointers to 33-byte character arrays for the commitments.
       * @arg {Array} ncommits: pointer to pointers to 33-byte character arrays for negative commitments.
       * @exports
       */
      function verifySum(commits, negativeCommits) {
        if (
          !commits ||
          !Array.isArray(commits) ||
          !commits.every((c) => c.length === 33)
        )
          throw new TypeError(
            'commits must be a non empty array of Buffers of 33 bytes'
          );
        if (
          !negativeCommits ||
          !Array.isArray(negativeCommits) ||
          !negativeCommits.every((c) => c.length === 33)
        )
          throw new TypeError(
            'negativeCommits must be a non empty array of Buffers of 33 bytes'
          );
        const ret = Module.ccall(
          'pedersen_verify_tally',
          'number',
          ['number', 'number', 'number', 'number'],
          [
            charStarArray(commits),
            commits.length,
            charStarArray(negativeCommits),
            negativeCommits.length,
          ]
        );
        freeMalloc();
        return ret === 1;
      }

      /**
       *  @summary Authors a proof that a committed value is within a range.
       *  @return {Array} Proof successfully created.
       *  @throws {Error} Decode failed.
       *  @arg {Array} commitment: 33-byte array with the commitment being proved.
       *  @arg {Array} blind: 32-byte blinding factor used by commit.
       *  @arg {Array} nonce: 32-byte secret nonce used to initialize the proof (value can be reverse-engineered out of the proof if this secret is known.).
       *  @arg {string} value: unblinded value.
       *  @arg {Array} generator: 64-byte secret generator for the proof.
       *  @arg {string} minValue: constructs a proof where the verifer can tell the minimum value is at least the specified amount.
       *  @arg {number} base10Exp: Base-10 exponent. Digits below above will be made public, but the proof will be made smaller. Allowed range is -1 to 18.
       *      (-1 is a special case that makes the value public. 0 is the most private.).
       *  @arg {number} minBits: Number of bits of the value to keep private. (0 = auto/minimal, - 64).
       *  @arg {Array} message: optional message.
       *  @arg {Array} extraCommit: optional extra commit.
       *  @exports
       */
      function sign(
        commitment,
        blind,
        nonce,
        value,
        generator,
        minValue = '0',
        base10Exp = 0,
        minBits = 0,
        message = [],
        extraCommit = []
      ) {
        if (!commitment || !Buffer.isBuffer(commitment) || !commitment.length)
          throw new TypeError('commit must be a non empty Buffer');
        if (!blind || !Buffer.isBuffer(blind) || blind.length !== 32)
          throw new TypeError('blind must be a Buffer of 32 bytes');
        if (!nonce || !Buffer.isBuffer(nonce) || !nonce.length)
          throw new TypeError('nonce must be a non empty Buffer');
        if (
          !generator ||
          !Buffer.isBuffer(generator) ||
          generator.length !== 64
        )
          throw new TypeError('generator must be a Buffer of 64 bytes');
        if (!message || !Buffer.isBuffer(message))
          throw new TypeError('message must be a Buffer');
        if (!extraCommit || !Buffer.isBuffer(extraCommit))
          throw new TypeError('extraCommit must be a Buffer');

        const proof = malloc(5134);
        const plen = malloc(8);
        Module.setValue(plen, 5134, 'i64');
        const minValueLong = Long.fromString(minValue, true);
        const valueLong = Long.fromString(value, true);

        const ret = Module.ccall(
          'rangeproof_sign',
          'number',
          [
            'number',
            'number',
            'number',
            'number',
            'number',
            'number',
            'number',
            'number',
            'number',
            'number',
            'number',
            'number',
            'number',
            'number',
          ],
          [
            proof,
            plen,
            minValueLong.low,
            minValueLong.high,
            charStar(commitment),
            charStar(blind),
            charStar(nonce),
            base10Exp,
            minBits,
            valueLong.low,
            valueLong.high,
            charStar(message),
            message.length,
            charStar(extraCommit),
            extraCommit.length,
            charStar(generator),
          ]
        );
        if (ret === 1) {
          const p = new Uint8Array(
            Module.HEAPU8.subarray(proof, proof + Module.getValue(plen, 'i64'))
          );
          freeMalloc();
          return Buffer.from(p);
        } else {
          freeMalloc();
          throw new Error('secp256k1_rangeproof_sign', ret);
        }
      }

      /**
       *  @typedef {ProofInfo}
       *  @property {number} exp - Exponent used in the proof (-1 means the value isn't private).
       *  @property {string} mantissa - Number of bits covered by the proof.
       *  @property {string} minValue - minimum value that commit could have.
       *  @property {string} maxValue - maximum value that commit could have.
       */
      /**
       *  @summary Returns value info from a range-proof.
       *  @return {ProofInfo} Information successfully extracted.
       *  @throws {Error} Decode failed.
       *  @arg {Array} proof - range-proof.
       *  @exports
       */
      function info(proof) {
        if (!proof || !Buffer.isBuffer(proof) || !proof.length)
          throw new TypeError('proof must be a non empty Buffer');

        const exp = charStar(4);
        const mantissa = charStar(4);
        const min = charStar(8);
        const max = charStar(8);
        const ret = Module.ccall(
          'rangeproof_info',
          'number',
          ['number', 'number', 'number', 'number', 'number', 'number'],
          [exp, mantissa, min, max, charStar(proof), proof.length]
        );

        if (ret === 1) {
          const res = {
            exp: Module.getValue(exp, 'i32'),
            mantissa: Module.getValue(mantissa, 'i32'),
            minValue: Uint64Long(min).toString(),
            maxValue: Uint64Long(max).toString(),
          };
          freeMalloc();
          return res;
        } else {
          freeMalloc();
          throw new Error('secp256k1_rangeproof_info decode failed', ret);
        }
      }

      /**
       *  @summary Verifies a range-proof.
       *  @return {boolean} Proof successfully verified.
       *  @arg {Array} commitment - 33-byte commitment.
       *  @arg {Array} proof - range proof to verify.
       *  @arg {Array} generator - 64-byte generator used for the proof.
       *  @arg {Array} extraCommit - extra data used for the proof.
       */
      function verify(commitment, proof, generator, extraCommit = []) {
        if (!commit || !Buffer.isBuffer(commitment) || commitment.length !== 33)
          throw new TypeError('commit must be a Buffer of 33 bytes');
        if (!proof || !Buffer.isBuffer(proof) || !proof.length)
          throw new TypeError('proof must be a non empty Buffer');
        if (
          !generator ||
          !Buffer.isBuffer(generator) ||
          generator.length !== 64
        )
          throw new TypeError('generator must be a Buffer of 64 bytes');
        if (!extraCommit || !Buffer.isBuffer(extraCommit))
          throw new TypeError('extraCommit must be a Buffer');

        const min = charStar(8);
        const max = charStar(8);
        const ret = Module.ccall(
          'rangeproof_verify',
          'number',
          [
            'number',
            'number',
            'number',
            'number',
            'number',
            'number',
            'number',
            'number',
          ],
          [
            min,
            max,
            charStar(commitment),
            charStar(proof),
            proof.length,
            charStar(extraCommit),
            extraCommit.length,
            charStar(generator),
          ]
        );
        freeMalloc();
        return ret === 1;
      }

      /**
       *  @typedef {ProofRewind}
       *  @property {Array} blind - 32-byte blinding factor used by commit.
       *  @property {string} value - unblinded value.
       *  @property {string} minValue - minimum value that commit could have.
       *  @property {string} maxValue - maximum value that commit could have.
       *  @property {Array} message - 32-byte unblinded message.
       */
      /**
       *  @summary Extracts information from a range-proof.
       *  @return {ProofRewind} Information successfully extracted.
       *  @throws {Error} Decode failed.
       *  @arg {Array} commitment - 33-byte array with the commitment being proved.
       *  @arg {Array} proof - range-proof.
       *  @arg {Array} nonce - 32-byte secret nonce used to initialize the proof.
       *  @arg {Array} generator - 64-byte generator for the proof.
       *  @arg {Array} extraCommit - extra data for range-proof.
       */
      function rewind(commitment, proof, nonce, generator, extraCommit = []) {
        if (!commitment || !Buffer.isBuffer(commitment) || !commitment.length)
          throw new TypeError('commit must be a non empty Buffer');
        if (!proof || !Buffer.isBuffer(proof) || !proof.length)
          throw new TypeError('proof must be a non empty Buffer');
        if (!nonce || !Buffer.isBuffer(nonce) || !nonce.length)
          throw new TypeError('nonce must be a non empty Buffer');
        if (
          !generator ||
          !Buffer.isBuffer(generator) ||
          generator.length !== 64
        )
          throw new TypeError('generator must be a Buffer of 64 bytes');
        if (!extraCommit || !Buffer.isBuffer(extraCommit))
          throw new TypeError('extraCommit must be a Buffer');
        const blind = malloc(32);
        const value = malloc(8);
        const message = malloc(64);
        const messageLength = malloc(8);
        const minValue = malloc(8);
        const maxValue = malloc(8);
        Module.setValue(messageLength, 64, 'i64');

        const ret = Module.ccall(
          'rangeproof_rewind',
          'number',
          [
            'number',
            'number',
            'number',
            'number',
            'number',
            'number',
            'number',
            'number',
            'number',
            'number',
            'number',
            'number',
            'number',
          ],
          [
            blind,
            value,
            message,
            messageLength,
            charStar(nonce),
            minValue,
            maxValue,
            charStar(commitment),
            charStar(proof),
            proof.length,
            charStar(extraCommit),
            extraCommit.length,
            charStar(generator),
          ]
        );

        if (ret === 1) {
          const bf = new Uint8Array(Module.HEAPU8.subarray(blind, blind + 32));
          const msg = new Uint8Array(
            Module.HEAPU8.subarray(
              message,
              message + Module.getValue(messageLength, 'i64')
            )
          );
          const out = {
            value: Uint64Long(value).toString(),
            minValue: Uint64Long(minValue).toString(),
            maxValue: Uint64Long(maxValue).toString(),
            blindFactor: Buffer.from(bf),
            message: Buffer.from(msg),
          };
          freeMalloc();
          return out;
        } else {
          freeMalloc();
          throw new Error('secp256k1_rangeproof_rewind', ret);
        }
      }

      /**
       *  @typedef {SurjectionProof}
       *  @property {number} nInputs - number of input tags used to generate the proof.
       *  @property {Array} usedInputs - 32-byte inputs bitmap.
       *  @property {Array} data - 8224-byte proof data.
       */
      /**
       *  @summary Serializes a surjection proof.
       *  @return {Array} Serialized surjection proof without leading zeros.
       *  @throws {Error} Decode failed.
       *  @arg {SurjectionProof} proof - proof to serialize.
       */
      function proofSerialize(proof) {
        if (
          !proof ||
          proof.nInputs === undefined ||
          proof.nInputs === null ||
          !proof.usedInputs ||
          !Buffer.isBuffer(proof.usedInputs) ||
          proof.usedInputs.length != 32 ||
          !proof.data ||
          !Buffer.isBuffer(proof.data)
        )
          throw new TypeError(
            'proof must be an object with nInputs of type number and data,' +
              'usedInputs of type Buffer'
          );
        const output = malloc(8258);
        const outputLength = malloc(8);
        Module.setValue(outputLength, 8258, 'i64');
        const ret = Module.ccall(
          'surjectionproof_serialize',
          'number',
          ['number', 'number', 'number', 'number', 'number'],
          [
            output,
            outputLength,
            intStar(proof.nInputs),
            charStar(proof.usedInputs),
            charStar(proof.data),
          ]
        );
        if (ret === 1) {
          const out = new Uint8Array(
            Module.HEAPU8.subarray(
              output,
              output + Module.getValue(outputLength, 'i64')
            )
          );
          freeMalloc();
          return Buffer.from(out);
        } else {
          freeMalloc();
          throw new Error('secp256k1_surjectionproof_serialize', ret);
        }
      }

      /**
       *  @summary Returns an initialized surjection proof.
       *  @return {SurjectionProof} Proof successfully computed.
       *  @throws {Error} Decode failed.
       *  @arg {Array} inputTags - Array of 32-byte input tags.
       *  @arg {number} inputTagsToUse - The number of inputs to include in the surjection proof.
       *  @arg {Array} outputTag - 32-byte output tag.
       *  @arg {number} maxIterations - Max number of attemoots to compute the proof.
       *  @arg {Array} seed - 32-byte random seed.
       */
      function proofInitialize(
        inputTags,
        inputTagsToUse,
        outputTag,
        maxIterations,
        seed
      ) {
        if (
          !inputTags ||
          !Array.isArray(inputTags) ||
          !inputTags.length ||
          !inputTags.every((t) => t.length === 32)
        )
          throw new TypeError(
            'inputTags must be a non empty array of Buffers of 32 bytes'
          );
        if (
          !outputTag ||
          !Buffer.isBuffer(outputTag) ||
          outputTag.length !== 32
        )
          throw new TypeError('outputTag must be a Buffer of 32 bytes');
        if (!seed || !Buffer.isBuffer(seed) || seed.length !== 32)
          throw new TypeError('seed must be a Buffer of 32 bytes');

        const nInputs = malloc(4);
        const usedInputs = malloc(32);
        const data = malloc(8224);
        const inputIndex = malloc(4);
        const ret = Module.ccall(
          'surjectionproof_initialize',
          'number',
          [
            'number',
            'number',
            'number',
            'number',
            'number',
            'number',
            'number',
            'number',
            'number',
            'number',
          ],
          [
            nInputs,
            usedInputs,
            data,
            inputIndex,
            charStarArray(inputTags),
            inputTags.length,
            inputTagsToUse,
            charStar(outputTag),
            maxIterations,
            charStar(seed),
          ]
        );
        if (ret > 0) {
          const usedIns = new Uint8Array(
            Module.HEAPU8.subarray(usedInputs, usedInputs + 32)
          );
          const d = new Uint8Array(Module.HEAPU8.subarray(data, data + 8224));
          const out = {
            proof: {
              nInputs: Module.getValue(nInputs, 'i32'),
              usedInputs: Buffer.from(usedIns),
              data: Buffer.from(d),
            },
            inputIndex: Module.getValue(inputIndex, 'i32'),
          };
          freeMalloc();
          return out;
        } else {
          freeMalloc();
          throw new Error('secp256k1_surjectionproof_initialize', ret);
        }
      }

      /**
       *  @summary Generates a surjection proof.
       *  @return {SurjectionProof} Proof successfully computed.
       *  @throws {Error} Decode failed.
       *  @arg {SurjectionProof} proof - Initialized surjection proof.
       *  @arg {Array} inputTags - Array of 64-byte ephemeral input tags.
       *  @arg {Array} outputTag - 64-byte ephemeral output tag.
       *  @arg {number} inputIndex - Proof input index.
       *  @arg {Array} inputBlindingKey - 32-byte blinding key for the input tags.
       *  @arg {Array} outputBlindingKey - 32-byte blinding key for the output tag.
       */
      function proofGenerate(
        proof,
        inputTags,
        outputTag,
        inputIndex,
        inputBlindingKey,
        outputBlindingKey
      ) {
        if (
          !proof ||
          proof.nInputs === undefined ||
          proof.nInputs === null ||
          !proof.usedInputs ||
          !Buffer.isBuffer(proof.usedInputs) ||
          proof.usedInputs.length != 32 ||
          !proof.data ||
          !Buffer.isBuffer(proof.data)
        )
          throw new TypeError(
            'proof must be an object with nInputs of type number and data,' +
              'usedInputs of type Buffer'
          );
        if (
          !inputTags ||
          !Array.isArray(inputTags) ||
          !inputTags.length ||
          !inputTags.every((t) => t.length === 64)
        )
          throw new TypeError(
            'inputTags must be a non empty array of Buffers of 64 bytes'
          );
        if (
          !outputTag ||
          !Buffer.isBuffer(outputTag) ||
          outputTag.length !== 64
        )
          throw new TypeError('ouputTag must be a Buffer of 64 bytes');
        if (
          !inputBlindingKey ||
          !Buffer.isBuffer(inputBlindingKey) ||
          inputBlindingKey.length !== 32
        )
          throw new TypeError('inputBlindingKey must be a Buffer of 32 bytes');
        if (
          !outputBlindingKey ||
          !Buffer.isBuffer(outputBlindingKey) ||
          outputBlindingKey.length !== 32
        )
          throw new TypeError('outputBlindingKey must be a Buffer of 32 bytes');
        if (inputIndex < 0 || inputIndex > inputTags.length)
          throw new TypeError(
            'inputIndex must be a number into range [0, ' +
              inputTags.length +
              ']'
          );
        const nInputs = intStar(proof.nInputs);
        const usedInputs = charStar(proof.usedInputs);
        const data = charStar(proof.data);
        const ret = Module.ccall(
          'surjectionproof_generate',
          'number',
          [
            'number',
            'number',
            'number',
            'number',
            'number',
            'number',
            'number',
            'number',
            'number',
          ],
          [
            nInputs,
            usedInputs,
            data,
            charStarArray(inputTags),
            inputTags.length,
            charStar(outputTag),
            inputIndex,
            charStar(inputBlindingKey),
            charStar(outputBlindingKey),
          ]
        );
        if (ret === 1) {
          const usedIns = new Uint8Array(
            Module.HEAPU8.subarray(usedInputs, usedInputs + 32)
          );
          const d = new Uint8Array(Module.HEAPU8.subarray(data, data + 8224));
          const p = {
            nInputs: inputTags.length,
            usedInputs: Buffer.from(usedIns),
            data: Buffer.from(d),
          };
          freeMalloc();
          return p;
        } else {
          freeMalloc();
          throw new Error('secp256k1_surjectionproof_generate', ret);
        }
      }

      /**
       *  @summary Verifies a surjection proof.
       *  @return {boolean} Proof successfully verified.
       *  @throws {Error} Decode failed.
       *  @arg {SurjectionProof} proof - proof to verify.
       *  @arg {Array} inputTags - Array of 64-byte ephemeral input tags.
       *  @arg {Array} outputTags - 64-byte ephemeral output tags.
       */
      function proofVerify(proof, inputTags, outputTag) {
        if (
          !inputTags ||
          !Array.isArray(inputTags) ||
          !inputTags.length ||
          !inputTags.every((t) => t.length === 64)
        )
          throw new TypeError(
            'inputTags must be a non empty array of Buffers of 64 bytes'
          );
        if (
          !outputTag ||
          !Buffer.isBuffer(outputTag) ||
          outputTag.length !== 64
        )
          throw new TypeError('ouputTag must be a Buffer of 64 bytes');
        const ret = Module.ccall(
          'surjectionproof_verify',
          'number',
          ['number', 'number', 'number', 'number', 'number', 'number'],
          [
            intStar(proof.nInputs),
            charStar(proof.usedInputs),
            charStar(proof.data),
            charStarArray(inputTags),
            inputTags.length,
            charStar(outputTag),
          ]
        );
        freeMalloc();
        return ret === 1;
      }

      function Uint64Long(ptr) {
        return new Long(
          Module.getValue(ptr, 'i32'),
          Module.getValue(ptr + 4, 'i32'),
          true
        );
      }

      function intStar(num) {
        const ptr = malloc(4);
        Module.setValue(ptr, num, 'i32');
        return ptr;
      }

      function charStar(buf) {
        const ptr = malloc(buf.length);
        for (let i = 0; i < buf.length; i++) {
          Module.setValue(ptr + i, buf[i], 'i8');
        }
        return ptr;
      }

      function charStarArray(array) {
        const arrayPtrs = malloc(4 * array.length);
        for (let i = 0; i < array.length; i++) {
          const ptr = charStar(array[i]);
          Module.setValue(arrayPtrs + i * 4, ptr, 'i32');
        }
        return arrayPtrs;
      }

      function longIntStarArray(array) {
        const ptr = malloc(8 * array.length);
        for (let i = 0; i < array.length; i++) {
          Module.setValue(ptr + i * 8, array[i].low, 'i32');
          Module.setValue(ptr + i * 8 + 4, array[i].high, 'i32');
        }
        return ptr;
      }

      resolve({
        ecdh,
        pedersen: {
          commit,
          commitSerialize,
          commitParse,
          blindGeneratorBlindSum,
          blindSum,
          verifySum,
        },
        generator: {
          generateBlinded,
          parse,
          serialize,
        },
        rangeproof: {
          sign,
          info,
          verify,
          rewind,
        },
        surjectionproof: {
          serialize: proofSerialize,
          initialize: proofInitialize,
          generate: proofGenerate,
          verify: proofVerify,
        },
      });
    });
  });
};

}).call(this)}).call(this,require("buffer").Buffer)
},{"../dist/secp256k1-zkp.js":1,"buffer":110,"long":43}],3:[function(require,module,exports){
'use strict'
// base-x encoding / decoding
// Copyright (c) 2018 base-x contributors
// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)
// Distributed under the MIT software license, see the accompanying
// file LICENSE or http://www.opensource.org/licenses/mit-license.php.
// @ts-ignore
var _Buffer = require('safe-buffer').Buffer
function base (ALPHABET) {
  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }
  var BASE_MAP = new Uint8Array(256)
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i)
    var xc = x.charCodeAt(0)
    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }
    BASE_MAP[xc] = i
  }
  var BASE = ALPHABET.length
  var LEADER = ALPHABET.charAt(0)
  var FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up
  var iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up
  function encode (source) {
    if (Array.isArray(source) || source instanceof Uint8Array) { source = _Buffer.from(source) }
    if (!_Buffer.isBuffer(source)) { throw new TypeError('Expected Buffer') }
    if (source.length === 0) { return '' }
        // Skip & count leading zeroes.
    var zeroes = 0
    var length = 0
    var pbegin = 0
    var pend = source.length
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++
      zeroes++
    }
        // Allocate enough space in big-endian base58 representation.
    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0
    var b58 = new Uint8Array(size)
        // Process the bytes.
    while (pbegin !== pend) {
      var carry = source[pbegin]
            // Apply "b58 = b58 * 256 + ch".
      var i = 0
      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {
        carry += (256 * b58[it1]) >>> 0
        b58[it1] = (carry % BASE) >>> 0
        carry = (carry / BASE) >>> 0
      }
      if (carry !== 0) { throw new Error('Non-zero carry') }
      length = i
      pbegin++
    }
        // Skip leading zeroes in base58 result.
    var it2 = size - length
    while (it2 !== size && b58[it2] === 0) {
      it2++
    }
        // Translate the result into a string.
    var str = LEADER.repeat(zeroes)
    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]) }
    return str
  }
  function decodeUnsafe (source) {
    if (typeof source !== 'string') { throw new TypeError('Expected String') }
    if (source.length === 0) { return _Buffer.alloc(0) }
    var psz = 0
        // Skip and count leading '1's.
    var zeroes = 0
    var length = 0
    while (source[psz] === LEADER) {
      zeroes++
      psz++
    }
        // Allocate enough space in big-endian base256 representation.
    var size = (((source.length - psz) * FACTOR) + 1) >>> 0 // log(58) / log(256), rounded up.
    var b256 = new Uint8Array(size)
        // Process the characters.
    while (source[psz]) {
            // Decode character
      var carry = BASE_MAP[source.charCodeAt(psz)]
            // Invalid character
      if (carry === 255) { return }
      var i = 0
      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {
        carry += (BASE * b256[it3]) >>> 0
        b256[it3] = (carry % 256) >>> 0
        carry = (carry / 256) >>> 0
      }
      if (carry !== 0) { throw new Error('Non-zero carry') }
      length = i
      psz++
    }
        // Skip leading zeroes in b256.
    var it4 = size - length
    while (it4 !== size && b256[it4] === 0) {
      it4++
    }
    var vch = _Buffer.allocUnsafe(zeroes + (size - it4))
    vch.fill(0x00, 0, zeroes)
    var j = zeroes
    while (it4 !== size) {
      vch[j++] = b256[it4++]
    }
    return vch
  }
  function decode (string) {
    var buffer = decodeUnsafe(string)
    if (buffer) { return buffer }
    throw new Error('Non-base' + BASE + ' character')
  }
  return {
    encode: encode,
    decodeUnsafe: decodeUnsafe,
    decode: decode
  }
}
module.exports = base

},{"safe-buffer":62}],4:[function(require,module,exports){
'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.bech32m = exports.bech32 = void 0;
const ALPHABET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';
const ALPHABET_MAP = {};
for (let z = 0; z < ALPHABET.length; z++) {
    const x = ALPHABET.charAt(z);
    ALPHABET_MAP[x] = z;
}
function polymodStep(pre) {
    const b = pre >> 25;
    return (((pre & 0x1ffffff) << 5) ^
        (-((b >> 0) & 1) & 0x3b6a57b2) ^
        (-((b >> 1) & 1) & 0x26508e6d) ^
        (-((b >> 2) & 1) & 0x1ea119fa) ^
        (-((b >> 3) & 1) & 0x3d4233dd) ^
        (-((b >> 4) & 1) & 0x2a1462b3));
}
function prefixChk(prefix) {
    let chk = 1;
    for (let i = 0; i < prefix.length; ++i) {
        const c = prefix.charCodeAt(i);
        if (c < 33 || c > 126)
            return 'Invalid prefix (' + prefix + ')';
        chk = polymodStep(chk) ^ (c >> 5);
    }
    chk = polymodStep(chk);
    for (let i = 0; i < prefix.length; ++i) {
        const v = prefix.charCodeAt(i);
        chk = polymodStep(chk) ^ (v & 0x1f);
    }
    return chk;
}
function convert(data, inBits, outBits, pad) {
    let value = 0;
    let bits = 0;
    const maxV = (1 << outBits) - 1;
    const result = [];
    for (let i = 0; i < data.length; ++i) {
        value = (value << inBits) | data[i];
        bits += inBits;
        while (bits >= outBits) {
            bits -= outBits;
            result.push((value >> bits) & maxV);
        }
    }
    if (pad) {
        if (bits > 0) {
            result.push((value << (outBits - bits)) & maxV);
        }
    }
    else {
        if (bits >= inBits)
            return 'Excess padding';
        if ((value << (outBits - bits)) & maxV)
            return 'Non-zero padding';
    }
    return result;
}
function toWords(bytes) {
    return convert(bytes, 8, 5, true);
}
function fromWordsUnsafe(words) {
    const res = convert(words, 5, 8, false);
    if (Array.isArray(res))
        return res;
}
function fromWords(words) {
    const res = convert(words, 5, 8, false);
    if (Array.isArray(res))
        return res;
    throw new Error(res);
}
function getLibraryFromEncoding(encoding) {
    let ENCODING_CONST;
    if (encoding === 'bech32') {
        ENCODING_CONST = 1;
    }
    else {
        ENCODING_CONST = 0x2bc830a3;
    }
    function encode(prefix, words, LIMIT) {
        LIMIT = LIMIT || 90;
        if (prefix.length + 7 + words.length > LIMIT)
            throw new TypeError('Exceeds length limit');
        prefix = prefix.toLowerCase();
        // determine chk mod
        let chk = prefixChk(prefix);
        if (typeof chk === 'string')
            throw new Error(chk);
        let result = prefix + '1';
        for (let i = 0; i < words.length; ++i) {
            const x = words[i];
            if (x >> 5 !== 0)
                throw new Error('Non 5-bit word');
            chk = polymodStep(chk) ^ x;
            result += ALPHABET.charAt(x);
        }
        for (let i = 0; i < 6; ++i) {
            chk = polymodStep(chk);
        }
        chk ^= ENCODING_CONST;
        for (let i = 0; i < 6; ++i) {
            const v = (chk >> ((5 - i) * 5)) & 0x1f;
            result += ALPHABET.charAt(v);
        }
        return result;
    }
    function __decode(str, LIMIT) {
        LIMIT = LIMIT || 90;
        if (str.length < 8)
            return str + ' too short';
        if (str.length > LIMIT)
            return 'Exceeds length limit';
        // don't allow mixed case
        const lowered = str.toLowerCase();
        const uppered = str.toUpperCase();
        if (str !== lowered && str !== uppered)
            return 'Mixed-case string ' + str;
        str = lowered;
        const split = str.lastIndexOf('1');
        if (split === -1)
            return 'No separator character for ' + str;
        if (split === 0)
            return 'Missing prefix for ' + str;
        const prefix = str.slice(0, split);
        const wordChars = str.slice(split + 1);
        if (wordChars.length < 6)
            return 'Data too short';
        let chk = prefixChk(prefix);
        if (typeof chk === 'string')
            return chk;
        const words = [];
        for (let i = 0; i < wordChars.length; ++i) {
            const c = wordChars.charAt(i);
            const v = ALPHABET_MAP[c];
            if (v === undefined)
                return 'Unknown character ' + c;
            chk = polymodStep(chk) ^ v;
            // not in the checksum?
            if (i + 6 >= wordChars.length)
                continue;
            words.push(v);
        }
        if (chk !== ENCODING_CONST)
            return 'Invalid checksum for ' + str;
        return { prefix, words };
    }
    function decodeUnsafe(str, LIMIT) {
        const res = __decode(str, LIMIT);
        if (typeof res === 'object')
            return res;
    }
    function decode(str, LIMIT) {
        const res = __decode(str, LIMIT);
        if (typeof res === 'object')
            return res;
        throw new Error(res);
    }
    return {
        decodeUnsafe,
        decode,
        encode,
        toWords,
        fromWordsUnsafe,
        fromWords,
    };
}
exports.bech32 = getLibraryFromEncoding('bech32');
exports.bech32m = getLibraryFromEncoding('bech32m');

},{}],5:[function(require,module,exports){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
const parser_1 = require('../parser');
function combine(psbts) {
  const self = psbts[0];
  const selfKeyVals = parser_1.psbtToKeyVals(self);
  const others = psbts.slice(1);
  if (others.length === 0) throw new Error('Combine: Nothing to combine');
  const selfTx = getTx(self);
  if (selfTx === undefined) {
    throw new Error('Combine: Self missing transaction');
  }
  const selfGlobalSet = getKeySet(selfKeyVals.globalKeyVals);
  const selfInputSets = selfKeyVals.inputKeyVals.map(getKeySet);
  const selfOutputSets = selfKeyVals.outputKeyVals.map(getKeySet);
  for (const other of others) {
    const otherTx = getTx(other);
    if (
      otherTx === undefined ||
      !otherTx.toBuffer().equals(selfTx.toBuffer())
    ) {
      throw new Error(
        'Combine: One of the Psbts does not have the same transaction.',
      );
    }
    const otherKeyVals = parser_1.psbtToKeyVals(other);
    const otherGlobalSet = getKeySet(otherKeyVals.globalKeyVals);
    otherGlobalSet.forEach(
      keyPusher(
        selfGlobalSet,
        selfKeyVals.globalKeyVals,
        otherKeyVals.globalKeyVals,
      ),
    );
    const otherInputSets = otherKeyVals.inputKeyVals.map(getKeySet);
    otherInputSets.forEach((inputSet, idx) =>
      inputSet.forEach(
        keyPusher(
          selfInputSets[idx],
          selfKeyVals.inputKeyVals[idx],
          otherKeyVals.inputKeyVals[idx],
        ),
      ),
    );
    const otherOutputSets = otherKeyVals.outputKeyVals.map(getKeySet);
    otherOutputSets.forEach((outputSet, idx) =>
      outputSet.forEach(
        keyPusher(
          selfOutputSets[idx],
          selfKeyVals.outputKeyVals[idx],
          otherKeyVals.outputKeyVals[idx],
        ),
      ),
    );
  }
  return parser_1.psbtFromKeyVals(selfTx, {
    globalMapKeyVals: selfKeyVals.globalKeyVals,
    inputKeyVals: selfKeyVals.inputKeyVals,
    outputKeyVals: selfKeyVals.outputKeyVals,
  });
}
exports.combine = combine;
function keyPusher(selfSet, selfKeyVals, otherKeyVals) {
  return key => {
    if (selfSet.has(key)) return;
    const newKv = otherKeyVals.filter(kv => kv.key.toString('hex') === key)[0];
    selfKeyVals.push(newKv);
    selfSet.add(key);
  };
}
function getTx(psbt) {
  return psbt.globalMap.unsignedTx;
}
function getKeySet(keyVals) {
  const set = new Set();
  keyVals.forEach(keyVal => {
    const hex = keyVal.key.toString('hex');
    if (set.has(hex))
      throw new Error('Combine: KeyValue Map keys should be unique');
    set.add(hex);
  });
  return set;
}

},{"../parser":23}],6:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
const typeFields_1 = require('../../typeFields');
const range = n => [...Array(n).keys()];
function decode(keyVal) {
  if (keyVal.key[0] !== typeFields_1.GlobalTypes.GLOBAL_XPUB) {
    throw new Error(
      'Decode Error: could not decode globalXpub with key 0x' +
        keyVal.key.toString('hex'),
    );
  }
  if (keyVal.key.length !== 79 || ![2, 3].includes(keyVal.key[46])) {
    throw new Error(
      'Decode Error: globalXpub has invalid extended pubkey in key 0x' +
        keyVal.key.toString('hex'),
    );
  }
  if ((keyVal.value.length / 4) % 1 !== 0) {
    throw new Error(
      'Decode Error: Global GLOBAL_XPUB value length should be multiple of 4',
    );
  }
  const extendedPubkey = keyVal.key.slice(1);
  const data = {
    masterFingerprint: keyVal.value.slice(0, 4),
    extendedPubkey,
    path: 'm',
  };
  for (const i of range(keyVal.value.length / 4 - 1)) {
    const val = keyVal.value.readUInt32LE(i * 4 + 4);
    const isHard = !!(val & 0x80000000);
    const idx = val & 0x7fffffff;
    data.path += '/' + idx.toString(10) + (isHard ? "'" : '');
  }
  return data;
}
exports.decode = decode;
function encode(data) {
  const head = Buffer.from([typeFields_1.GlobalTypes.GLOBAL_XPUB]);
  const key = Buffer.concat([head, data.extendedPubkey]);
  const splitPath = data.path.split('/');
  const value = Buffer.allocUnsafe(splitPath.length * 4);
  data.masterFingerprint.copy(value, 0);
  let offset = 4;
  splitPath.slice(1).forEach(level => {
    const isHard = level.slice(-1) === "'";
    let num = 0x7fffffff & parseInt(isHard ? level.slice(0, -1) : level, 10);
    if (isHard) num += 0x80000000;
    value.writeUInt32LE(num, offset);
    offset += 4;
  });
  return {
    key,
    value,
  };
}
exports.encode = encode;
exports.expected =
  '{ masterFingerprint: Buffer; extendedPubkey: Buffer; path: string; }';
function check(data) {
  const epk = data.extendedPubkey;
  const mfp = data.masterFingerprint;
  const p = data.path;
  return (
    Buffer.isBuffer(epk) &&
    epk.length === 78 &&
    [2, 3].indexOf(epk[45]) > -1 &&
    Buffer.isBuffer(mfp) &&
    mfp.length === 4 &&
    typeof p === 'string' &&
    !!p.match(/^m(\/\d+'?)+$/)
  );
}
exports.check = check;
function canAddToArray(array, item, dupeSet) {
  const dupeString = item.extendedPubkey.toString('hex');
  if (dupeSet.has(dupeString)) return false;
  dupeSet.add(dupeString);
  return (
    array.filter(v => v.extendedPubkey.equals(item.extendedPubkey)).length === 0
  );
}
exports.canAddToArray = canAddToArray;

}).call(this)}).call(this,require("buffer").Buffer)
},{"../../typeFields":26,"buffer":110}],7:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
const typeFields_1 = require('../../typeFields');
function encode(data) {
  return {
    key: Buffer.from([typeFields_1.GlobalTypes.UNSIGNED_TX]),
    value: data.toBuffer(),
  };
}
exports.encode = encode;

}).call(this)}).call(this,require("buffer").Buffer)
},{"../../typeFields":26,"buffer":110}],8:[function(require,module,exports){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
const typeFields_1 = require('../typeFields');
const globalXpub = require('./global/globalXpub');
const unsignedTx = require('./global/unsignedTx');
const finalScriptSig = require('./input/finalScriptSig');
const finalScriptWitness = require('./input/finalScriptWitness');
const nonWitnessUtxo = require('./input/nonWitnessUtxo');
const partialSig = require('./input/partialSig');
const porCommitment = require('./input/porCommitment');
const sighashType = require('./input/sighashType');
const witnessUtxo = require('./input/witnessUtxo');
const bip32Derivation = require('./shared/bip32Derivation');
const checkPubkey = require('./shared/checkPubkey');
const redeemScript = require('./shared/redeemScript');
const witnessScript = require('./shared/witnessScript');
const globals = {
  unsignedTx,
  globalXpub,
  // pass an Array of key bytes that require pubkey beside the key
  checkPubkey: checkPubkey.makeChecker([]),
};
exports.globals = globals;
const inputs = {
  nonWitnessUtxo,
  partialSig,
  sighashType,
  finalScriptSig,
  finalScriptWitness,
  porCommitment,
  witnessUtxo,
  bip32Derivation: bip32Derivation.makeConverter(
    typeFields_1.InputTypes.BIP32_DERIVATION,
  ),
  redeemScript: redeemScript.makeConverter(
    typeFields_1.InputTypes.REDEEM_SCRIPT,
  ),
  witnessScript: witnessScript.makeConverter(
    typeFields_1.InputTypes.WITNESS_SCRIPT,
  ),
  checkPubkey: checkPubkey.makeChecker([
    typeFields_1.InputTypes.PARTIAL_SIG,
    typeFields_1.InputTypes.BIP32_DERIVATION,
  ]),
};
exports.inputs = inputs;
const outputs = {
  bip32Derivation: bip32Derivation.makeConverter(
    typeFields_1.OutputTypes.BIP32_DERIVATION,
  ),
  redeemScript: redeemScript.makeConverter(
    typeFields_1.OutputTypes.REDEEM_SCRIPT,
  ),
  witnessScript: witnessScript.makeConverter(
    typeFields_1.OutputTypes.WITNESS_SCRIPT,
  ),
  checkPubkey: checkPubkey.makeChecker([
    typeFields_1.OutputTypes.BIP32_DERIVATION,
  ]),
};
exports.outputs = outputs;

},{"../typeFields":26,"./global/globalXpub":6,"./global/unsignedTx":7,"./input/finalScriptSig":9,"./input/finalScriptWitness":10,"./input/nonWitnessUtxo":11,"./input/partialSig":12,"./input/porCommitment":13,"./input/sighashType":14,"./input/witnessUtxo":15,"./shared/bip32Derivation":16,"./shared/checkPubkey":17,"./shared/redeemScript":18,"./shared/witnessScript":19}],9:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
const typeFields_1 = require('../../typeFields');
function decode(keyVal) {
  if (keyVal.key[0] !== typeFields_1.InputTypes.FINAL_SCRIPTSIG) {
    throw new Error(
      'Decode Error: could not decode finalScriptSig with key 0x' +
        keyVal.key.toString('hex'),
    );
  }
  return keyVal.value;
}
exports.decode = decode;
function encode(data) {
  const key = Buffer.from([typeFields_1.InputTypes.FINAL_SCRIPTSIG]);
  return {
    key,
    value: data,
  };
}
exports.encode = encode;
exports.expected = 'Buffer';
function check(data) {
  return Buffer.isBuffer(data);
}
exports.check = check;
function canAdd(currentData, newData) {
  return !!currentData && !!newData && currentData.finalScriptSig === undefined;
}
exports.canAdd = canAdd;

}).call(this)}).call(this,require("buffer").Buffer)
},{"../../typeFields":26,"buffer":110}],10:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
const typeFields_1 = require('../../typeFields');
function decode(keyVal) {
  if (keyVal.key[0] !== typeFields_1.InputTypes.FINAL_SCRIPTWITNESS) {
    throw new Error(
      'Decode Error: could not decode finalScriptWitness with key 0x' +
        keyVal.key.toString('hex'),
    );
  }
  return keyVal.value;
}
exports.decode = decode;
function encode(data) {
  const key = Buffer.from([typeFields_1.InputTypes.FINAL_SCRIPTWITNESS]);
  return {
    key,
    value: data,
  };
}
exports.encode = encode;
exports.expected = 'Buffer';
function check(data) {
  return Buffer.isBuffer(data);
}
exports.check = check;
function canAdd(currentData, newData) {
  return (
    !!currentData && !!newData && currentData.finalScriptWitness === undefined
  );
}
exports.canAdd = canAdd;

}).call(this)}).call(this,require("buffer").Buffer)
},{"../../typeFields":26,"buffer":110}],11:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
const typeFields_1 = require('../../typeFields');
function decode(keyVal) {
  if (keyVal.key[0] !== typeFields_1.InputTypes.NON_WITNESS_UTXO) {
    throw new Error(
      'Decode Error: could not decode nonWitnessUtxo with key 0x' +
        keyVal.key.toString('hex'),
    );
  }
  return keyVal.value;
}
exports.decode = decode;
function encode(data) {
  return {
    key: Buffer.from([typeFields_1.InputTypes.NON_WITNESS_UTXO]),
    value: data,
  };
}
exports.encode = encode;
exports.expected = 'Buffer';
function check(data) {
  return Buffer.isBuffer(data);
}
exports.check = check;
function canAdd(currentData, newData) {
  return (
    !!currentData &&
    !!newData &&
    currentData.witnessUtxo === undefined &&
    currentData.nonWitnessUtxo === undefined
  );
}
exports.canAdd = canAdd;

}).call(this)}).call(this,require("buffer").Buffer)
},{"../../typeFields":26,"buffer":110}],12:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
const typeFields_1 = require('../../typeFields');
function decode(keyVal) {
  if (keyVal.key[0] !== typeFields_1.InputTypes.PARTIAL_SIG) {
    throw new Error(
      'Decode Error: could not decode partialSig with key 0x' +
        keyVal.key.toString('hex'),
    );
  }
  if (
    !(keyVal.key.length === 34 || keyVal.key.length === 66) ||
    ![2, 3, 4].includes(keyVal.key[1])
  ) {
    throw new Error(
      'Decode Error: partialSig has invalid pubkey in key 0x' +
        keyVal.key.toString('hex'),
    );
  }
  const pubkey = keyVal.key.slice(1);
  return {
    pubkey,
    signature: keyVal.value,
  };
}
exports.decode = decode;
function encode(pSig) {
  const head = Buffer.from([typeFields_1.InputTypes.PARTIAL_SIG]);
  return {
    key: Buffer.concat([head, pSig.pubkey]),
    value: pSig.signature,
  };
}
exports.encode = encode;
exports.expected = '{ pubkey: Buffer; signature: Buffer; }';
function check(data) {
  return (
    Buffer.isBuffer(data.pubkey) &&
    Buffer.isBuffer(data.signature) &&
    [33, 65].includes(data.pubkey.length) &&
    [2, 3, 4].includes(data.pubkey[0]) &&
    isDerSigWithSighash(data.signature)
  );
}
exports.check = check;
function isDerSigWithSighash(buf) {
  if (!Buffer.isBuffer(buf) || buf.length < 9) return false;
  if (buf[0] !== 0x30) return false;
  if (buf.length !== buf[1] + 3) return false;
  if (buf[2] !== 0x02) return false;
  const rLen = buf[3];
  if (rLen > 33 || rLen < 1) return false;
  if (buf[3 + rLen + 1] !== 0x02) return false;
  const sLen = buf[3 + rLen + 2];
  if (sLen > 33 || sLen < 1) return false;
  if (buf.length !== 3 + rLen + 2 + sLen + 2) return false;
  return true;
}
function canAddToArray(array, item, dupeSet) {
  const dupeString = item.pubkey.toString('hex');
  if (dupeSet.has(dupeString)) return false;
  dupeSet.add(dupeString);
  return array.filter(v => v.pubkey.equals(item.pubkey)).length === 0;
}
exports.canAddToArray = canAddToArray;

}).call(this)}).call(this,require("buffer").Buffer)
},{"../../typeFields":26,"buffer":110}],13:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
const typeFields_1 = require('../../typeFields');
function decode(keyVal) {
  if (keyVal.key[0] !== typeFields_1.InputTypes.POR_COMMITMENT) {
    throw new Error(
      'Decode Error: could not decode porCommitment with key 0x' +
        keyVal.key.toString('hex'),
    );
  }
  return keyVal.value.toString('utf8');
}
exports.decode = decode;
function encode(data) {
  const key = Buffer.from([typeFields_1.InputTypes.POR_COMMITMENT]);
  return {
    key,
    value: Buffer.from(data, 'utf8'),
  };
}
exports.encode = encode;
exports.expected = 'string';
function check(data) {
  return typeof data === 'string';
}
exports.check = check;
function canAdd(currentData, newData) {
  return !!currentData && !!newData && currentData.porCommitment === undefined;
}
exports.canAdd = canAdd;

}).call(this)}).call(this,require("buffer").Buffer)
},{"../../typeFields":26,"buffer":110}],14:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
const typeFields_1 = require('../../typeFields');
function decode(keyVal) {
  if (keyVal.key[0] !== typeFields_1.InputTypes.SIGHASH_TYPE) {
    throw new Error(
      'Decode Error: could not decode sighashType with key 0x' +
        keyVal.key.toString('hex'),
    );
  }
  return keyVal.value.readUInt32LE(0);
}
exports.decode = decode;
function encode(data) {
  const key = Buffer.from([typeFields_1.InputTypes.SIGHASH_TYPE]);
  const value = Buffer.allocUnsafe(4);
  value.writeUInt32LE(data, 0);
  return {
    key,
    value,
  };
}
exports.encode = encode;
exports.expected = 'number';
function check(data) {
  return typeof data === 'number';
}
exports.check = check;
function canAdd(currentData, newData) {
  return !!currentData && !!newData && currentData.sighashType === undefined;
}
exports.canAdd = canAdd;

}).call(this)}).call(this,require("buffer").Buffer)
},{"../../typeFields":26,"buffer":110}],15:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
const typeFields_1 = require('../../typeFields');
const varuint = require('../varint');
function decode(keyVal) {
  if (keyVal.key[0] !== typeFields_1.InputTypes.WITNESS_UTXO) {
    throw new Error(
      'Decode Error: could not decode witnessUtxo with key 0x' +
        keyVal.key.toString('hex'),
    );
  }
  let rangeProof;
  let surjectionProof;
  let _offset = 0;
  let _next = 33;
  const asset = keyVal.value.slice(_offset, _next);
  _offset = _next;
  _next += 1;
  const prefix = keyVal.value.slice(_offset, _next);
  _offset = _next;
  _next += prefix[0] === 1 ? 8 : 32;
  const value = Buffer.concat([prefix, keyVal.value.slice(_offset, _next)]);
  _offset = _next;
  _next += 1;
  const nPrefix = keyVal.value.slice(_offset, _next);
  let nonce = nPrefix;
  if (nPrefix[0] !== 0) {
    _offset = _next;
    _next += 32;
    nonce = Buffer.concat([nonce, keyVal.value.slice(_offset, _next)]);
  }
  _offset = _next;
  _next += 1;
  const scriptLen = varuint.decode(keyVal.value, _offset);
  _offset = _next;
  _next += scriptLen;
  const script = keyVal.value.slice(_offset, _next);
  if (script.length !== scriptLen) {
    throw new Error('Decode Error: WITNESS_UTXO script is not proper length');
  }
  _offset = _next;
  if (_offset < keyVal.value.length) {
    _next += 1;
    const surjectionProofLen = varuint.decode(keyVal.value, _offset);
    _offset = _next;
    _next += surjectionProofLen;
    surjectionProof = keyVal.value.slice(_offset, _next);
    _offset = _next;
    _next += 1;
    const rangeProofLen = varuint.decode(keyVal.value, _offset);
    _next += varuint.encodingLength(rangeProofLen) - 1;
    _offset = _next;
    _next += rangeProofLen;
    rangeProof = keyVal.value.slice(_offset, _next);
    _offset = _next;
  }
  return {
    script,
    value,
    asset,
    nonce,
    rangeProof,
    surjectionProof,
  };
}
exports.decode = decode;
function encode(data) {
  const { script, value, asset, nonce, rangeProof, surjectionProof } = data;
  const assetLen = 33;
  const valueLen = value[0] === 1 ? 9 : 33;
  const nonceLen = nonce[0] === 0 ? 1 : 33;
  const varintScriptLen = varuint.encodingLength(script.length);
  const rangeProofLen = rangeProof ? rangeProof.length : 0;
  const varintRangeProofLen =
    nonceLen === 1 ? 0 : varuint.encodingLength(rangeProofLen);
  const surjectionProofLen = surjectionProof ? surjectionProof.length : 0;
  const varintSurjectionProofLen =
    nonceLen === 1 ? 0 : varuint.encodingLength(surjectionProofLen);
  const result = Buffer.allocUnsafe(
    assetLen +
      valueLen +
      nonceLen +
      varintScriptLen +
      script.length +
      varintRangeProofLen +
      rangeProofLen +
      varintSurjectionProofLen +
      surjectionProofLen,
  );
  let resultLen = 0;
  asset.copy(result, resultLen);
  resultLen += assetLen;
  value.copy(result, resultLen);
  resultLen += valueLen;
  nonce.copy(result, resultLen);
  resultLen += nonceLen;
  varuint.encode(script.length, result, resultLen);
  resultLen += varintScriptLen;
  script.copy(result, resultLen);
  if (nonceLen > 1) {
    resultLen += script.length;
    varuint.encode(surjectionProofLen, result, resultLen);
    resultLen += varintSurjectionProofLen;
    surjectionProof && surjectionProof.copy(result, resultLen);
    resultLen += surjectionProofLen;
    varuint.encode(rangeProofLen, result, resultLen);
    resultLen += varintRangeProofLen;
    rangeProof && rangeProof.copy(result, resultLen);
    resultLen += rangeProofLen;
  }
  return {
    key: Buffer.from([typeFields_1.InputTypes.WITNESS_UTXO]),
    value: result,
  };
}
exports.encode = encode;
exports.expected =
  '{ script: Buffer; value: Buffer; asset: Buffer; nonce: Buffer; rangeProof?: Buffer; surjectionProof?: Buffer }';
function check(data) {
  return (
    Buffer.isBuffer(data.script) &&
    Buffer.isBuffer(data.value) &&
    Buffer.isBuffer(data.asset) &&
    Buffer.isBuffer(data.nonce) &&
    // since proofs are optional, skip check returning true when undefined, otherwise check the type
    (data.rangeProof ? Buffer.isBuffer(data.rangeProof) : true) &&
    (data.surjectionProof ? Buffer.isBuffer(data.surjectionProof) : true)
  );
}
exports.check = check;
function canAdd(currentData, newData) {
  return (
    !!currentData &&
    !!newData &&
    currentData.witnessUtxo === undefined &&
    currentData.nonWitnessUtxo === undefined
  );
}
exports.canAdd = canAdd;

}).call(this)}).call(this,require("buffer").Buffer)
},{"../../typeFields":26,"../varint":21,"buffer":110}],16:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
const range = n => [...Array(n).keys()];
function makeConverter(TYPE_BYTE) {
  function decode(keyVal) {
    if (keyVal.key[0] !== TYPE_BYTE) {
      throw new Error(
        'Decode Error: could not decode bip32Derivation with key 0x' +
          keyVal.key.toString('hex'),
      );
    }
    if (
      !(keyVal.key.length === 34 || keyVal.key.length === 66) ||
      ![2, 3, 4].includes(keyVal.key[1])
    ) {
      throw new Error(
        'Decode Error: bip32Derivation has invalid pubkey in key 0x' +
          keyVal.key.toString('hex'),
      );
    }
    if ((keyVal.value.length / 4) % 1 !== 0) {
      throw new Error(
        'Decode Error: Input BIP32_DERIVATION value length should be multiple of 4',
      );
    }
    const pubkey = keyVal.key.slice(1);
    const data = {
      masterFingerprint: keyVal.value.slice(0, 4),
      pubkey,
      path: 'm',
    };
    for (const i of range(keyVal.value.length / 4 - 1)) {
      const val = keyVal.value.readUInt32LE(i * 4 + 4);
      const isHard = !!(val & 0x80000000);
      const idx = val & 0x7fffffff;
      data.path += '/' + idx.toString(10) + (isHard ? "'" : '');
    }
    return data;
  }
  function encode(data) {
    const head = Buffer.from([TYPE_BYTE]);
    const key = Buffer.concat([head, data.pubkey]);
    const splitPath = data.path.split('/');
    const value = Buffer.allocUnsafe(splitPath.length * 4);
    data.masterFingerprint.copy(value, 0);
    let offset = 4;
    splitPath.slice(1).forEach(level => {
      const isHard = level.slice(-1) === "'";
      let num = 0x7fffffff & parseInt(isHard ? level.slice(0, -1) : level, 10);
      if (isHard) num += 0x80000000;
      value.writeUInt32LE(num, offset);
      offset += 4;
    });
    return {
      key,
      value,
    };
  }
  const expected =
    '{ masterFingerprint: Buffer; pubkey: Buffer; path: string; }';
  function check(data) {
    return (
      Buffer.isBuffer(data.pubkey) &&
      Buffer.isBuffer(data.masterFingerprint) &&
      typeof data.path === 'string' &&
      [33, 65].includes(data.pubkey.length) &&
      [2, 3, 4].includes(data.pubkey[0]) &&
      data.masterFingerprint.length === 4
    );
  }
  function canAddToArray(array, item, dupeSet) {
    const dupeString = item.pubkey.toString('hex');
    if (dupeSet.has(dupeString)) return false;
    dupeSet.add(dupeString);
    return array.filter(v => v.pubkey.equals(item.pubkey)).length === 0;
  }
  return {
    decode,
    encode,
    check,
    expected,
    canAddToArray,
  };
}
exports.makeConverter = makeConverter;

}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":110}],17:[function(require,module,exports){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
function makeChecker(pubkeyTypes) {
  return checkPubkey;
  function checkPubkey(keyVal) {
    let pubkey;
    if (pubkeyTypes.includes(keyVal.key[0])) {
      pubkey = keyVal.key.slice(1);
      if (
        !(pubkey.length === 33 || pubkey.length === 65) ||
        ![2, 3, 4].includes(pubkey[0])
      ) {
        throw new Error(
          'Format Error: invalid pubkey in key 0x' + keyVal.key.toString('hex'),
        );
      }
    }
    return pubkey;
  }
}
exports.makeChecker = makeChecker;

},{}],18:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
function makeConverter(TYPE_BYTE) {
  function decode(keyVal) {
    if (keyVal.key[0] !== TYPE_BYTE) {
      throw new Error(
        'Decode Error: could not decode redeemScript with key 0x' +
          keyVal.key.toString('hex'),
      );
    }
    return keyVal.value;
  }
  function encode(data) {
    const key = Buffer.from([TYPE_BYTE]);
    return {
      key,
      value: data,
    };
  }
  const expected = 'Buffer';
  function check(data) {
    return Buffer.isBuffer(data);
  }
  function canAdd(currentData, newData) {
    return !!currentData && !!newData && currentData.redeemScript === undefined;
  }
  return {
    decode,
    encode,
    check,
    expected,
    canAdd,
  };
}
exports.makeConverter = makeConverter;

}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":110}],19:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
function makeConverter(TYPE_BYTE) {
  function decode(keyVal) {
    if (keyVal.key[0] !== TYPE_BYTE) {
      throw new Error(
        'Decode Error: could not decode witnessScript with key 0x' +
          keyVal.key.toString('hex'),
      );
    }
    return keyVal.value;
  }
  function encode(data) {
    const key = Buffer.from([TYPE_BYTE]);
    return {
      key,
      value: data,
    };
  }
  const expected = 'Buffer';
  function check(data) {
    return Buffer.isBuffer(data);
  }
  function canAdd(currentData, newData) {
    return (
      !!currentData && !!newData && currentData.witnessScript === undefined
    );
  }
  return {
    decode,
    encode,
    check,
    expected,
    canAdd,
  };
}
exports.makeConverter = makeConverter;

}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":110}],20:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
const varuint = require('./varint');
exports.range = n => [...Array(n).keys()];
function reverseBuffer(buffer) {
  if (buffer.length < 1) return buffer;
  let j = buffer.length - 1;
  let tmp = 0;
  for (let i = 0; i < buffer.length / 2; i++) {
    tmp = buffer[i];
    buffer[i] = buffer[j];
    buffer[j] = tmp;
    j--;
  }
  return buffer;
}
exports.reverseBuffer = reverseBuffer;
function keyValsToBuffer(keyVals) {
  const buffers = keyVals.map(keyValToBuffer);
  buffers.push(Buffer.from([0]));
  return Buffer.concat(buffers);
}
exports.keyValsToBuffer = keyValsToBuffer;
function keyValToBuffer(keyVal) {
  const keyLen = keyVal.key.length;
  const valLen = keyVal.value.length;
  const keyVarIntLen = varuint.encodingLength(keyLen);
  const valVarIntLen = varuint.encodingLength(valLen);
  const buffer = Buffer.allocUnsafe(
    keyVarIntLen + keyLen + valVarIntLen + valLen,
  );
  varuint.encode(keyLen, buffer, 0);
  keyVal.key.copy(buffer, keyVarIntLen);
  varuint.encode(valLen, buffer, keyVarIntLen + keyLen);
  keyVal.value.copy(buffer, keyVarIntLen + keyLen + valVarIntLen);
  return buffer;
}
exports.keyValToBuffer = keyValToBuffer;
// https://github.com/feross/buffer/blob/master/index.js#L1127
function verifuint(value, max) {
  if (typeof value !== 'number')
    throw new Error('cannot write a non-number as a number');
  if (value < 0)
    throw new Error('specified a negative value for writing an unsigned value');
  if (value > max) throw new Error('RangeError: value out of range');
  if (Math.floor(value) !== value)
    throw new Error('value has a fractional component');
}
function readUInt64LE(buffer, offset) {
  const a = buffer.readUInt32LE(offset);
  let b = buffer.readUInt32LE(offset + 4);
  b *= 0x100000000;
  verifuint(b + a, 0x001fffffffffffff);
  return b + a;
}
exports.readUInt64LE = readUInt64LE;
function writeUInt64LE(buffer, value, offset) {
  verifuint(value, 0x001fffffffffffff);
  buffer.writeInt32LE(value & -1, offset);
  buffer.writeUInt32LE(Math.floor(value / 0x100000000), offset + 4);
  return offset + 8;
}
exports.writeUInt64LE = writeUInt64LE;

}).call(this)}).call(this,require("buffer").Buffer)
},{"./varint":21,"buffer":110}],21:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
// Number.MAX_SAFE_INTEGER
const MAX_SAFE_INTEGER = 9007199254740991;
function checkUInt53(n) {
  if (n < 0 || n > MAX_SAFE_INTEGER || n % 1 !== 0)
    throw new RangeError('value out of range');
}
function encode(_number, buffer, offset) {
  checkUInt53(_number);
  if (!buffer) buffer = Buffer.allocUnsafe(encodingLength(_number));
  if (!Buffer.isBuffer(buffer))
    throw new TypeError('buffer must be a Buffer instance');
  if (!offset) offset = 0;
  // 8 bit
  if (_number < 0xfd) {
    buffer.writeUInt8(_number, offset);
    Object.assign(encode, { bytes: 1 });
    // 16 bit
  } else if (_number <= 0xffff) {
    buffer.writeUInt8(0xfd, offset);
    buffer.writeUInt16LE(_number, offset + 1);
    Object.assign(encode, { bytes: 3 });
    // 32 bit
  } else if (_number <= 0xffffffff) {
    buffer.writeUInt8(0xfe, offset);
    buffer.writeUInt32LE(_number, offset + 1);
    Object.assign(encode, { bytes: 5 });
    // 64 bit
  } else {
    buffer.writeUInt8(0xff, offset);
    buffer.writeUInt32LE(_number >>> 0, offset + 1);
    buffer.writeUInt32LE((_number / 0x100000000) | 0, offset + 5);
    Object.assign(encode, { bytes: 9 });
  }
  return buffer;
}
exports.encode = encode;
function decode(buffer, offset) {
  if (!Buffer.isBuffer(buffer))
    throw new TypeError('buffer must be a Buffer instance');
  if (!offset) offset = 0;
  const first = buffer.readUInt8(offset);
  // 8 bit
  if (first < 0xfd) {
    Object.assign(decode, { bytes: 1 });
    return first;
    // 16 bit
  } else if (first === 0xfd) {
    Object.assign(decode, { bytes: 3 });
    return buffer.readUInt16LE(offset + 1);
    // 32 bit
  } else if (first === 0xfe) {
    Object.assign(decode, { bytes: 5 });
    return buffer.readUInt32LE(offset + 1);
    // 64 bit
  } else {
    Object.assign(decode, { bytes: 9 });
    const lo = buffer.readUInt32LE(offset + 1);
    const hi = buffer.readUInt32LE(offset + 5);
    const _number = hi * 0x0100000000 + lo;
    checkUInt53(_number);
    return _number;
  }
}
exports.decode = decode;
function encodingLength(_number) {
  checkUInt53(_number);
  return _number < 0xfd
    ? 1
    : _number <= 0xffff
    ? 3
    : _number <= 0xffffffff
    ? 5
    : 9;
}
exports.encodingLength = encodingLength;

}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":110}],22:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
const convert = require('../converter');
const tools_1 = require('../converter/tools');
const varuint = require('../converter/varint');
const typeFields_1 = require('../typeFields');
function psbtFromBuffer(buffer, txGetter) {
  let offset = 0;
  function varSlice() {
    const keyLen = varuint.decode(buffer, offset);
    offset += varuint.encodingLength(keyLen);
    const key = buffer.slice(offset, offset + keyLen);
    offset += keyLen;
    return key;
  }
  function readUInt32BE() {
    const num = buffer.readUInt32BE(offset);
    offset += 4;
    return num;
  }
  function readUInt8() {
    const num = buffer.readUInt8(offset);
    offset += 1;
    return num;
  }
  function getKeyValue() {
    const key = varSlice();
    const value = varSlice();
    return {
      key,
      value,
    };
  }
  function checkEndOfKeyValPairs() {
    if (offset >= buffer.length) {
      throw new Error('Format Error: Unexpected End of PSBT');
    }
    const isEnd = buffer.readUInt8(offset) === 0;
    if (isEnd) {
      offset++;
    }
    return isEnd;
  }
  if (readUInt32BE() !== 0x70736574) {
    throw new Error('Format Error: Invalid Magic Number');
  }
  if (readUInt8() !== 0xff) {
    throw new Error(
      'Format Error: Magic Number must be followed by 0xff separator',
    );
  }
  const globalMapKeyVals = [];
  const globalKeyIndex = {};
  while (!checkEndOfKeyValPairs()) {
    const keyVal = getKeyValue();
    const hexKey = keyVal.key.toString('hex');
    if (globalKeyIndex[hexKey]) {
      throw new Error(
        'Format Error: Keys must be unique for global keymap: key ' + hexKey,
      );
    }
    globalKeyIndex[hexKey] = 1;
    globalMapKeyVals.push(keyVal);
  }
  const unsignedTxMaps = globalMapKeyVals.filter(
    keyVal => keyVal.key[0] === typeFields_1.GlobalTypes.UNSIGNED_TX,
  );
  if (unsignedTxMaps.length !== 1) {
    throw new Error('Format Error: Only one UNSIGNED_TX allowed');
  }
  const unsignedTx = txGetter(unsignedTxMaps[0].value);
  // Get input and output counts to loop the respective fields
  const { inputCount, outputCount } = unsignedTx.getInputOutputCounts();
  const inputKeyVals = [];
  const outputKeyVals = [];
  // Get input fields
  for (const index of tools_1.range(inputCount)) {
    const inputKeyIndex = {};
    const input = [];
    while (!checkEndOfKeyValPairs()) {
      const keyVal = getKeyValue();
      const hexKey = keyVal.key.toString('hex');
      if (inputKeyIndex[hexKey]) {
        throw new Error(
          'Format Error: Keys must be unique for each input: ' +
            'input index ' +
            index +
            ' key ' +
            hexKey,
        );
      }
      inputKeyIndex[hexKey] = 1;
      input.push(keyVal);
    }
    inputKeyVals.push(input);
  }
  for (const index of tools_1.range(outputCount)) {
    const outputKeyIndex = {};
    const output = [];
    while (!checkEndOfKeyValPairs()) {
      const keyVal = getKeyValue();
      const hexKey = keyVal.key.toString('hex');
      if (outputKeyIndex[hexKey]) {
        throw new Error(
          'Format Error: Keys must be unique for each output: ' +
            'output index ' +
            index +
            ' key ' +
            hexKey,
        );
      }
      outputKeyIndex[hexKey] = 1;
      output.push(keyVal);
    }
    outputKeyVals.push(output);
  }
  return psbtFromKeyVals(unsignedTx, {
    globalMapKeyVals,
    inputKeyVals,
    outputKeyVals,
  });
}
exports.psbtFromBuffer = psbtFromBuffer;
function checkKeyBuffer(type, keyBuf, keyNum) {
  if (!keyBuf.equals(Buffer.from([keyNum]))) {
    throw new Error(
      `Format Error: Invalid ${type} key: ${keyBuf.toString('hex')}`,
    );
  }
}
exports.checkKeyBuffer = checkKeyBuffer;
function psbtFromKeyVals(
  unsignedTx,
  { globalMapKeyVals, inputKeyVals, outputKeyVals },
) {
  // That was easy :-)
  const globalMap = {
    unsignedTx,
  };
  let txCount = 0;
  for (const keyVal of globalMapKeyVals) {
    // If a globalMap item needs pubkey, uncomment
    // const pubkey = convert.globals.checkPubkey(keyVal);
    switch (keyVal.key[0]) {
      case typeFields_1.GlobalTypes.UNSIGNED_TX:
        checkKeyBuffer(
          'global',
          keyVal.key,
          typeFields_1.GlobalTypes.UNSIGNED_TX,
        );
        if (txCount > 0) {
          throw new Error('Format Error: GlobalMap has multiple UNSIGNED_TX');
        }
        txCount++;
        break;
      case typeFields_1.GlobalTypes.GLOBAL_XPUB:
        if (globalMap.globalXpub === undefined) {
          globalMap.globalXpub = [];
        }
        globalMap.globalXpub.push(convert.globals.globalXpub.decode(keyVal));
        break;
      default:
        // This will allow inclusion during serialization.
        if (!globalMap.unknownKeyVals) globalMap.unknownKeyVals = [];
        globalMap.unknownKeyVals.push(keyVal);
    }
  }
  // Get input and output counts to loop the respective fields
  const inputCount = inputKeyVals.length;
  const outputCount = outputKeyVals.length;
  const inputs = [];
  const outputs = [];
  // Get input fields
  for (const index of tools_1.range(inputCount)) {
    const input = {};
    for (const keyVal of inputKeyVals[index]) {
      convert.inputs.checkPubkey(keyVal);
      switch (keyVal.key[0]) {
        case typeFields_1.InputTypes.NON_WITNESS_UTXO:
          checkKeyBuffer(
            'input',
            keyVal.key,
            typeFields_1.InputTypes.NON_WITNESS_UTXO,
          );
          if (
            input.nonWitnessUtxo !== undefined ||
            input.witnessUtxo !== undefined
          ) {
            throw new Error(
              'Format Error: Input has multiple [NON_]WITNESS_UTXO',
            );
          }
          input.nonWitnessUtxo = convert.inputs.nonWitnessUtxo.decode(keyVal);
          break;
        case typeFields_1.InputTypes.WITNESS_UTXO:
          checkKeyBuffer(
            'input',
            keyVal.key,
            typeFields_1.InputTypes.WITNESS_UTXO,
          );
          if (
            input.nonWitnessUtxo !== undefined ||
            input.witnessUtxo !== undefined
          ) {
            throw new Error(
              'Format Error: Input has multiple [NON_]WITNESS_UTXO',
            );
          }
          input.witnessUtxo = convert.inputs.witnessUtxo.decode(keyVal);
          break;
        case typeFields_1.InputTypes.PARTIAL_SIG:
          if (input.partialSig === undefined) {
            input.partialSig = [];
          }
          input.partialSig.push(convert.inputs.partialSig.decode(keyVal));
          break;
        case typeFields_1.InputTypes.SIGHASH_TYPE:
          checkKeyBuffer(
            'input',
            keyVal.key,
            typeFields_1.InputTypes.SIGHASH_TYPE,
          );
          if (input.sighashType !== undefined) {
            throw new Error('Format Error: Input has multiple SIGHASH_TYPE');
          }
          input.sighashType = convert.inputs.sighashType.decode(keyVal);
          break;
        case typeFields_1.InputTypes.REDEEM_SCRIPT:
          checkKeyBuffer(
            'input',
            keyVal.key,
            typeFields_1.InputTypes.REDEEM_SCRIPT,
          );
          if (input.redeemScript !== undefined) {
            throw new Error('Format Error: Input has multiple REDEEM_SCRIPT');
          }
          input.redeemScript = convert.inputs.redeemScript.decode(keyVal);
          break;
        case typeFields_1.InputTypes.WITNESS_SCRIPT:
          checkKeyBuffer(
            'input',
            keyVal.key,
            typeFields_1.InputTypes.WITNESS_SCRIPT,
          );
          if (input.witnessScript !== undefined) {
            throw new Error('Format Error: Input has multiple WITNESS_SCRIPT');
          }
          input.witnessScript = convert.inputs.witnessScript.decode(keyVal);
          break;
        case typeFields_1.InputTypes.BIP32_DERIVATION:
          if (input.bip32Derivation === undefined) {
            input.bip32Derivation = [];
          }
          input.bip32Derivation.push(
            convert.inputs.bip32Derivation.decode(keyVal),
          );
          break;
        case typeFields_1.InputTypes.FINAL_SCRIPTSIG:
          checkKeyBuffer(
            'input',
            keyVal.key,
            typeFields_1.InputTypes.FINAL_SCRIPTSIG,
          );
          input.finalScriptSig = convert.inputs.finalScriptSig.decode(keyVal);
          break;
        case typeFields_1.InputTypes.FINAL_SCRIPTWITNESS:
          checkKeyBuffer(
            'input',
            keyVal.key,
            typeFields_1.InputTypes.FINAL_SCRIPTWITNESS,
          );
          input.finalScriptWitness = convert.inputs.finalScriptWitness.decode(
            keyVal,
          );
          break;
        case typeFields_1.InputTypes.POR_COMMITMENT:
          checkKeyBuffer(
            'input',
            keyVal.key,
            typeFields_1.InputTypes.POR_COMMITMENT,
          );
          input.porCommitment = convert.inputs.porCommitment.decode(keyVal);
          break;
        default:
          // This will allow inclusion during serialization.
          if (!input.unknownKeyVals) input.unknownKeyVals = [];
          input.unknownKeyVals.push(keyVal);
      }
    }
    inputs.push(input);
  }
  for (const index of tools_1.range(outputCount)) {
    const output = {};
    for (const keyVal of outputKeyVals[index]) {
      convert.outputs.checkPubkey(keyVal);
      switch (keyVal.key[0]) {
        case typeFields_1.OutputTypes.REDEEM_SCRIPT:
          checkKeyBuffer(
            'output',
            keyVal.key,
            typeFields_1.OutputTypes.REDEEM_SCRIPT,
          );
          if (output.redeemScript !== undefined) {
            throw new Error('Format Error: Output has multiple REDEEM_SCRIPT');
          }
          output.redeemScript = convert.outputs.redeemScript.decode(keyVal);
          break;
        case typeFields_1.OutputTypes.WITNESS_SCRIPT:
          checkKeyBuffer(
            'output',
            keyVal.key,
            typeFields_1.OutputTypes.WITNESS_SCRIPT,
          );
          if (output.witnessScript !== undefined) {
            throw new Error('Format Error: Output has multiple WITNESS_SCRIPT');
          }
          output.witnessScript = convert.outputs.witnessScript.decode(keyVal);
          break;
        case typeFields_1.OutputTypes.BIP32_DERIVATION:
          if (output.bip32Derivation === undefined) {
            output.bip32Derivation = [];
          }
          output.bip32Derivation.push(
            convert.outputs.bip32Derivation.decode(keyVal),
          );
          break;
        default:
          if (!output.unknownKeyVals) output.unknownKeyVals = [];
          output.unknownKeyVals.push(keyVal);
      }
    }
    outputs.push(output);
  }
  return { globalMap, inputs, outputs };
}
exports.psbtFromKeyVals = psbtFromKeyVals;

}).call(this)}).call(this,require("buffer").Buffer)
},{"../converter":8,"../converter/tools":20,"../converter/varint":21,"../typeFields":26,"buffer":110}],23:[function(require,module,exports){
'use strict';
function __export(m) {
  for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, '__esModule', { value: true });
__export(require('./fromBuffer'));
__export(require('./toBuffer'));

},{"./fromBuffer":22,"./toBuffer":24}],24:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
const convert = require('../converter');
const tools_1 = require('../converter/tools');
function psbtToBuffer({ globalMap, inputs, outputs }) {
  const { globalKeyVals, inputKeyVals, outputKeyVals } = psbtToKeyVals({
    globalMap,
    inputs,
    outputs,
  });
  const globalBuffer = tools_1.keyValsToBuffer(globalKeyVals);
  const keyValsOrEmptyToBuffer = keyVals =>
    keyVals.length === 0
      ? [Buffer.from([0])]
      : keyVals.map(tools_1.keyValsToBuffer);
  const inputBuffers = keyValsOrEmptyToBuffer(inputKeyVals);
  const outputBuffers = keyValsOrEmptyToBuffer(outputKeyVals);
  const header = Buffer.allocUnsafe(5);
  header.writeUIntBE(0x70736574ff, 0, 5);
  return Buffer.concat(
    [header, globalBuffer].concat(inputBuffers, outputBuffers),
  );
}
exports.psbtToBuffer = psbtToBuffer;
const sortKeyVals = (a, b) => {
  return a.key.compare(b.key);
};
function keyValsFromMap(keyValMap, converterFactory) {
  const keyHexSet = new Set();
  const keyVals = Object.entries(keyValMap).reduce((result, [key, value]) => {
    if (key === 'unknownKeyVals') return result;
    // We are checking for undefined anyways. So ignore TS error
    // @ts-ignore
    const converter = converterFactory[key];
    if (converter === undefined) return result;
    const encodedKeyVals = (Array.isArray(value) ? value : [value]).map(
      converter.encode,
    );
    const keyHexes = encodedKeyVals.map(kv => kv.key.toString('hex'));
    keyHexes.forEach(hex => {
      if (keyHexSet.has(hex))
        throw new Error('Serialize Error: Duplicate key: ' + hex);
      keyHexSet.add(hex);
    });
    return result.concat(encodedKeyVals);
  }, []);
  // Get other keyVals that have not yet been gotten
  const otherKeyVals = keyValMap.unknownKeyVals
    ? keyValMap.unknownKeyVals.filter(keyVal => {
        return !keyHexSet.has(keyVal.key.toString('hex'));
      })
    : [];
  return keyVals.concat(otherKeyVals).sort(sortKeyVals);
}
function psbtToKeyVals({ globalMap, inputs, outputs }) {
  // First parse the global keyVals
  // Get any extra keyvals to pass along
  return {
    globalKeyVals: keyValsFromMap(globalMap, convert.globals),
    inputKeyVals: inputs.map(i => keyValsFromMap(i, convert.inputs)),
    outputKeyVals: outputs.map(o => keyValsFromMap(o, convert.outputs)),
  };
}
exports.psbtToKeyVals = psbtToKeyVals;

}).call(this)}).call(this,require("buffer").Buffer)
},{"../converter":8,"../converter/tools":20,"buffer":110}],25:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
const combiner_1 = require('./combiner');
const parser_1 = require('./parser');
const typeFields_1 = require('./typeFields');
const utils_1 = require('./utils');
class Psbt {
  constructor(tx) {
    this.inputs = [];
    this.outputs = [];
    this.globalMap = {
      unsignedTx: tx,
    };
  }
  static fromBase64(data, txFromBuffer) {
    const buffer = Buffer.from(data, 'base64');
    return this.fromBuffer(buffer, txFromBuffer);
  }
  static fromHex(data, txFromBuffer) {
    const buffer = Buffer.from(data, 'hex');
    return this.fromBuffer(buffer, txFromBuffer);
  }
  static fromBuffer(buffer, txFromBuffer) {
    const results = parser_1.psbtFromBuffer(buffer, txFromBuffer);
    const psbt = new this(results.globalMap.unsignedTx);
    Object.assign(psbt, results);
    return psbt;
  }
  toBase64() {
    const buffer = this.toBuffer();
    return buffer.toString('base64');
  }
  toHex() {
    const buffer = this.toBuffer();
    return buffer.toString('hex');
  }
  toBuffer() {
    return parser_1.psbtToBuffer(this);
  }
  updateGlobal(updateData) {
    utils_1.updateGlobal(updateData, this.globalMap);
    return this;
  }
  updateInput(inputIndex, updateData) {
    const input = utils_1.checkForInput(this.inputs, inputIndex);
    utils_1.updateInput(updateData, input);
    return this;
  }
  updateOutput(outputIndex, updateData) {
    const output = utils_1.checkForOutput(this.outputs, outputIndex);
    utils_1.updateOutput(updateData, output);
    return this;
  }
  addUnknownKeyValToGlobal(keyVal) {
    utils_1.checkHasKey(
      keyVal,
      this.globalMap.unknownKeyVals,
      utils_1.getEnumLength(typeFields_1.GlobalTypes),
    );
    if (!this.globalMap.unknownKeyVals) this.globalMap.unknownKeyVals = [];
    this.globalMap.unknownKeyVals.push(keyVal);
    return this;
  }
  addUnknownKeyValToInput(inputIndex, keyVal) {
    const input = utils_1.checkForInput(this.inputs, inputIndex);
    utils_1.checkHasKey(
      keyVal,
      input.unknownKeyVals,
      utils_1.getEnumLength(typeFields_1.InputTypes),
    );
    if (!input.unknownKeyVals) input.unknownKeyVals = [];
    input.unknownKeyVals.push(keyVal);
    return this;
  }
  addUnknownKeyValToOutput(outputIndex, keyVal) {
    const output = utils_1.checkForOutput(this.outputs, outputIndex);
    utils_1.checkHasKey(
      keyVal,
      output.unknownKeyVals,
      utils_1.getEnumLength(typeFields_1.OutputTypes),
    );
    if (!output.unknownKeyVals) output.unknownKeyVals = [];
    output.unknownKeyVals.push(keyVal);
    return this;
  }
  addInput(inputData) {
    this.globalMap.unsignedTx.addInput(inputData);
    this.inputs.push({
      unknownKeyVals: [],
    });
    const addKeyVals = inputData.unknownKeyVals || [];
    const inputIndex = this.inputs.length - 1;
    if (!Array.isArray(addKeyVals)) {
      throw new Error('unknownKeyVals must be an Array');
    }
    addKeyVals.forEach(keyVal =>
      this.addUnknownKeyValToInput(inputIndex, keyVal),
    );
    utils_1.addInputAttributes(this.inputs, inputData);
    return this;
  }
  addOutput(outputData) {
    this.globalMap.unsignedTx.addOutput(outputData);
    this.outputs.push({
      unknownKeyVals: [],
    });
    const addKeyVals = outputData.unknownKeyVals || [];
    const outputIndex = this.outputs.length - 1;
    if (!Array.isArray(addKeyVals)) {
      throw new Error('unknownKeyVals must be an Array');
    }
    addKeyVals.forEach(keyVal =>
      this.addUnknownKeyValToInput(outputIndex, keyVal),
    );
    utils_1.addOutputAttributes(this.outputs, outputData);
    return this;
  }
  clearFinalizedInput(inputIndex) {
    const input = utils_1.checkForInput(this.inputs, inputIndex);
    utils_1.inputCheckUncleanFinalized(inputIndex, input);
    for (const key of Object.keys(input)) {
      if (
        ![
          'witnessUtxo',
          'nonWitnessUtxo',
          'finalScriptSig',
          'finalScriptWitness',
          'unknownKeyVals',
        ].includes(key)
      ) {
        // @ts-ignore
        delete input[key];
      }
    }
    return this;
  }
  combine(...those) {
    // Combine this with those.
    // Return self for chaining.
    const result = combiner_1.combine([this].concat(those));
    Object.assign(this, result);
    return this;
  }
  getTransaction() {
    return this.globalMap.unsignedTx.toBuffer();
  }
}
exports.Psbt = Psbt;

}).call(this)}).call(this,require("buffer").Buffer)
},{"./combiner":5,"./parser":23,"./typeFields":26,"./utils":27,"buffer":110}],26:[function(require,module,exports){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
var GlobalTypes;
(function(GlobalTypes) {
  GlobalTypes[(GlobalTypes['UNSIGNED_TX'] = 0)] = 'UNSIGNED_TX';
  GlobalTypes[(GlobalTypes['GLOBAL_XPUB'] = 1)] = 'GLOBAL_XPUB';
})((GlobalTypes = exports.GlobalTypes || (exports.GlobalTypes = {})));
exports.GLOBAL_TYPE_NAMES = ['unsignedTx', 'globalXpub'];
var InputTypes;
(function(InputTypes) {
  InputTypes[(InputTypes['NON_WITNESS_UTXO'] = 0)] = 'NON_WITNESS_UTXO';
  InputTypes[(InputTypes['WITNESS_UTXO'] = 1)] = 'WITNESS_UTXO';
  InputTypes[(InputTypes['PARTIAL_SIG'] = 2)] = 'PARTIAL_SIG';
  InputTypes[(InputTypes['SIGHASH_TYPE'] = 3)] = 'SIGHASH_TYPE';
  InputTypes[(InputTypes['REDEEM_SCRIPT'] = 4)] = 'REDEEM_SCRIPT';
  InputTypes[(InputTypes['WITNESS_SCRIPT'] = 5)] = 'WITNESS_SCRIPT';
  InputTypes[(InputTypes['BIP32_DERIVATION'] = 6)] = 'BIP32_DERIVATION';
  InputTypes[(InputTypes['FINAL_SCRIPTSIG'] = 7)] = 'FINAL_SCRIPTSIG';
  InputTypes[(InputTypes['FINAL_SCRIPTWITNESS'] = 8)] = 'FINAL_SCRIPTWITNESS';
  InputTypes[(InputTypes['POR_COMMITMENT'] = 9)] = 'POR_COMMITMENT';
})((InputTypes = exports.InputTypes || (exports.InputTypes = {})));
exports.INPUT_TYPE_NAMES = [
  'nonWitnessUtxo',
  'witnessUtxo',
  'partialSig',
  'sighashType',
  'redeemScript',
  'witnessScript',
  'bip32Derivation',
  'finalScriptSig',
  'finalScriptWitness',
  'porCommitment',
];
var OutputTypes;
(function(OutputTypes) {
  OutputTypes[(OutputTypes['REDEEM_SCRIPT'] = 0)] = 'REDEEM_SCRIPT';
  OutputTypes[(OutputTypes['WITNESS_SCRIPT'] = 1)] = 'WITNESS_SCRIPT';
  OutputTypes[(OutputTypes['BIP32_DERIVATION'] = 2)] = 'BIP32_DERIVATION';
})((OutputTypes = exports.OutputTypes || (exports.OutputTypes = {})));
exports.OUTPUT_TYPE_NAMES = [
  'redeemScript',
  'witnessScript',
  'bip32Derivation',
];

},{}],27:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
const converter = require('./converter');
function checkForInput(inputs, inputIndex) {
  const input = inputs[inputIndex];
  if (input === undefined) throw new Error(`No input #${inputIndex}`);
  return input;
}
exports.checkForInput = checkForInput;
function checkForOutput(outputs, outputIndex) {
  const output = outputs[outputIndex];
  if (output === undefined) throw new Error(`No output #${outputIndex}`);
  return output;
}
exports.checkForOutput = checkForOutput;
function checkHasKey(checkKeyVal, keyVals, enumLength) {
  if (checkKeyVal.key[0] < enumLength) {
    throw new Error(
      `Use the method for your specific key instead of addUnknownKeyVal*`,
    );
  }
  if (
    keyVals &&
    keyVals.filter(kv => kv.key.equals(checkKeyVal.key)).length !== 0
  ) {
    throw new Error(`Duplicate Key: ${checkKeyVal.key.toString('hex')}`);
  }
}
exports.checkHasKey = checkHasKey;
function getEnumLength(myenum) {
  let count = 0;
  Object.keys(myenum).forEach(val => {
    if (Number(isNaN(Number(val)))) {
      count++;
    }
  });
  return count;
}
exports.getEnumLength = getEnumLength;
function inputCheckUncleanFinalized(inputIndex, input) {
  let result = false;
  if (!input.nonWitnessUtxo !== !input.witnessUtxo) {
    const needScriptSig = !!input.redeemScript;
    const needWitnessScript = !!input.witnessScript;
    const scriptSigOK = !needScriptSig || !!input.finalScriptSig;
    const witnessScriptOK = !needWitnessScript || !!input.finalScriptWitness;
    const hasOneFinal = !!input.finalScriptSig || !!input.finalScriptWitness;
    result = scriptSigOK && witnessScriptOK && hasOneFinal;
  }
  if (result === false) {
    throw new Error(
      `Input #${inputIndex} has too much or too little data to clean`,
    );
  }
}
exports.inputCheckUncleanFinalized = inputCheckUncleanFinalized;
function throwForUpdateMaker(typeName, name, expected, data) {
  throw new Error(
    `Data for ${typeName} key ${name} is incorrect: Expected ` +
      `${expected} and got ${JSON.stringify(data)}`,
  );
}
function updateMaker(typeName) {
  return (updateData, mainData) => {
    for (const name of Object.keys(updateData)) {
      // @ts-ignore
      const data = updateData[name];
      // @ts-ignore
      const { canAdd, canAddToArray, check, expected } =
        // @ts-ignore
        converter[typeName + 's'][name] || {};
      const isArray = !!canAddToArray;
      // If unknown data. ignore and do not add
      if (check) {
        if (isArray) {
          if (
            !Array.isArray(data) ||
            // @ts-ignore
            (mainData[name] && !Array.isArray(mainData[name]))
          ) {
            throw new Error(`Key type ${name} must be an array`);
          }
          if (!data.every(check)) {
            throwForUpdateMaker(typeName, name, expected, data);
          }
          // @ts-ignore
          const arr = mainData[name] || [];
          const dupeCheckSet = new Set();
          if (!data.every(v => canAddToArray(arr, v, dupeCheckSet))) {
            throw new Error('Can not add duplicate data to array');
          }
          // @ts-ignore
          mainData[name] = arr.concat(data);
        } else {
          if (!check(data)) {
            throwForUpdateMaker(typeName, name, expected, data);
          }
          if (!canAdd(mainData, data)) {
            throw new Error(`Can not add duplicate data to ${typeName}`);
          }
          // @ts-ignore
          mainData[name] = data;
        }
      }
    }
  };
}
exports.updateGlobal = updateMaker('global');
exports.updateInput = updateMaker('input');
exports.updateOutput = updateMaker('output');
function addInputAttributes(inputs, data) {
  const index = inputs.length - 1;
  const input = checkForInput(inputs, index);
  exports.updateInput(data, input);
}
exports.addInputAttributes = addInputAttributes;
function addOutputAttributes(outputs, data) {
  const index = outputs.length - 1;
  const output = checkForInput(outputs, index);
  exports.updateOutput(data, output);
}
exports.addOutputAttributes = addOutputAttributes;
function defaultVersionSetter(version, txBuf) {
  if (!Buffer.isBuffer(txBuf) || txBuf.length < 4) {
    throw new Error('Set Version: Invalid Transaction');
  }
  txBuf.writeUInt32LE(version, 0);
  return txBuf;
}
exports.defaultVersionSetter = defaultVersionSetter;
function defaultLocktimeSetter(locktime, txBuf) {
  if (!Buffer.isBuffer(txBuf) || txBuf.length < 4) {
    throw new Error('Set Locktime: Invalid Transaction');
  }
  txBuf.writeUInt32LE(locktime, txBuf.length - 4);
  return txBuf;
}
exports.defaultLocktimeSetter = defaultLocktimeSetter;

}).call(this)}).call(this,{"isBuffer":require("../../../../../../../usr/local/lib/node_modules/browserify/node_modules/is-buffer/index.js")})
},{"../../../../../../../usr/local/lib/node_modules/browserify/node_modules/is-buffer/index.js":114,"./converter":8}],28:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var Long = _interopDefault(require('long'));

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it) return (it = it.call(o)).next.bind(it);

  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it) o = it;
    var i = 0;
    return function () {
      if (i >= o.length) return {
        done: true
      };
      return {
        done: false,
        value: o[i++]
      };
    };
  }

  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function convertBits(bytes, from, to, pad) {
  if (from < 1 || from > 8 || to < 1 || from > 8) {
    throw new Error("only bits groups between 1 and 8 are allowed");
  }

  var regrouped = [];
  var nextByte = 0;
  var filledBits = 0;

  for (var _iterator = _createForOfIteratorHelperLoose(bytes), _step; !(_step = _iterator()).done;) {
    var n = _step.value;
    var b = n << 8 - from; // How many bits remaining to extract from the input data.

    var remFromBits = from;

    while (remFromBits > 0) {
      // How many bits remaining to be added to the next byte.
      var remToBits = to - filledBits; // The number of bytes to next extract is the minimum of
      // remFromBits and remToBits.

      var toExtract = remFromBits;

      if (remToBits < toExtract) {
        toExtract = remToBits;
      } // Add the next bits to nextByte, shifting the already
      // added bits to the left.


      nextByte = nextByte << toExtract | b >> 8 - toExtract; // Discard the bits we just extracted and get ready for
      // next iteration.

      b = (b << toExtract) % 256;
      remFromBits -= toExtract;
      filledBits += toExtract; // If the nextByte is completely filled, we add it to
      // our regrouped bytes and start on the next byte.

      if (filledBits === to) {
        regrouped.push(nextByte);
        filledBits = 0;
        nextByte = 0;
      }
    }
  } // We pad any unfinished group if specified.


  if (pad && filledBits > 0) {
    nextByte = nextByte << to - filledBits;
    regrouped.push(nextByte);
    filledBits = 0;
    nextByte = 0;
  } // Any incomplete group must be <= 4 bits, and all zeroes.


  if (filledBits > 0 && (filledBits > 4 || nextByte !== 0)) {
    throw new Error("invalid incomplete group of bits");
  }

  return regrouped;
}
function validateWitnessVersion(version) {
  if (version < 0 || version > 16) {
    throw new Error("invalid witness version");
  }
}

var CHARSET = "qpzry9x8gf2tvdw0s3jn54khce6mua7l";
var MAX_LEN = 1000;

function hexToLong(hex) {
  return Long.fromString(hex, true, 16);
}

var GENERATORS = /*#__PURE__*/["7d52fba40bd886", "5e8dbf1a03950c", "1c3a3c74072a18", "385d72fa0e5139", "7093e5a608865b"].map(hexToLong);
var BLECH32 = "blech32";
var BLECH32M = "blech32m";
function getEncodingType(witnessVersion) {
  validateWitnessVersion(witnessVersion);

  if (witnessVersion === 0) {
    return BLECH32;
  } else if (witnessVersion === 1) {
    return BLECH32M;
  } else {
    throw new Error("Unsuported witness version (" + witnessVersion + "), only 0 (blech32) or 1 (blech32m) are supported");
  }
}

function getEncodingConst(enc) {
  if (enc === BLECH32) {
    return Long.fromNumber(1);
  } else if (enc === BLECH32M) {
    return hexToLong("455972a3350f7a1");
  } else {
    throw new Error("Invalid encoding type");
  }
}

function polymod(values) {
  var chk = Long.fromNumber(1);

  for (var p = 0; p < values.length; ++p) {
    var top = chk.shiftRight(55);
    chk = chk.and(hexToLong("7fffffffffffff")).shiftLeft(5).xor(values[p]);

    for (var i = 0; i < 5; i++) {
      if (top.shiftRight(Long.fromNumber(i)).and(1).equals(1)) {
        chk = chk.xor(GENERATORS[i]);
      }
    }
  }

  return chk;
}

function hrpExpand(hrp) {
  var ret = [];

  for (var p = 0; p < hrp.length; ++p) {
    ret.push(hrp.charCodeAt(p) >> 5);
  }

  ret.push(0);

  for (var _p = 0; _p < hrp.length; ++_p) {
    ret.push(hrp.charCodeAt(_p) & 31);
  }

  return Uint8Array.from(ret);
}

function verifyChecksum(hrp, data, enc) {
  var hrpAndData = Array.from(hrpExpand(hrp)).concat(data);
  return polymod(hrpAndData).equals(getEncodingConst(enc));
}

var zeros = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];

function createChecksum(hrp, data, enc) {
  var values = Array.from(hrpExpand(hrp)).concat(Array.from(data)).concat(zeros); // concat 12 zero

  var mod = polymod(values).xor(getEncodingConst(enc));
  var ret = [];

  for (var p = 0; p < 12; ++p) {
    ret.push(mod.shiftRight(5 * (11 - p)).and(31));
  }

  return ret.map(function (_long) {
    return _long.toInt();
  });
} // blech32 encode function


function encode(hrp, data, enc) {
  var checkSum = createChecksum(hrp, data, enc);
  var combined = Array.from(data).concat(checkSum);
  var ret = hrp + "1";

  for (var p = 0; p < combined.length; ++p) {
    ret += CHARSET.charAt(combined[p]);
  }

  return ret;
} // blech32 decode function

function decode(blechString, enc) {
  var has_lower = false;
  var has_upper = false;

  for (var p = 0; p < blechString.length; ++p) {
    if (blechString.charCodeAt(p) < 33 || blechString.charCodeAt(p) > 126) {
      throw new Error("Invalid charcode in blech32 string");
    }

    if (blechString.charCodeAt(p) >= 97 && blechString.charCodeAt(p) <= 122) {
      has_lower = true;
    }

    if (blechString.charCodeAt(p) >= 65 && blechString.charCodeAt(p) <= 90) {
      has_upper = true;
    }
  }

  if (has_lower && has_upper) {
    throw new Error("blech32 has lowercases AND uppercases");
  }

  blechString = blechString.toLowerCase();
  var pos = blechString.lastIndexOf("1");

  if (pos < 1 || pos + 13 > blechString.length) {
    throw new Error('Invalid index of "1"');
  }

  var hrp = blechString.substring(0, pos);
  var data = [];

  for (var _p2 = pos + 1; _p2 < blechString.length; ++_p2) {
    var d = CHARSET.indexOf(blechString.charAt(_p2));

    if (d === -1) {
      throw new Error("\"" + blechString.charAt(_p2) + "\" is not allowed in blech32 strings");
    }

    data.push(d);
  }

  if (!verifyChecksum(hrp, data, enc)) {
    throw new Error("invalid " + enc + " checksum \"" + blechString + "\"");
  }

  return {
    hrp: hrp,
    data: Uint8Array.from(data.slice(0, data.length - 12))
  };
}

/**
 * encodeAddress encodes data
 * @param hrp human readeable part
 * @param witnessProgram witnessProgram = pubkey + witness
 * @param witnessVersion witness version
 */

function encodeAddress(_ref) {
  var witness = _ref.witness,
      witnessVersion = _ref.witnessVersion,
      blindingPublicKey = _ref.blindingPublicKey,
      hrp = _ref.hrp;
  validateWitnessVersion(witnessVersion);
  var witnessProgram = Buffer.concat([Buffer.from(blindingPublicKey, "hex"), Buffer.from(witness, "hex")]);
  var witnessProgLength = witnessProgram.length;
  if (witnessVersion === 0 && witnessProgLength !== 53 && witnessProgLength !== 65) throw new Error("witness version 0 needs witness program length = 53 OR = 65");
  if (witnessProgLength < 2 || witnessProgLength > 65) throw new Error("witness program length should be >= 2 and <= 65");
  var data = [witnessVersion].concat(convertBits(Array.from(witnessProgram), 8, 5, true));
  return encode(hrp, Uint8Array.from(data), getEncodingType(data[0]));
}
/**
 * decodeAddress decodes a segwit string address.
 * @param addr the blech32 encoded string.
 * @param encodingType the encoding type.
 */


function decodeAddress(addr, enc) {
  var _decode = decode(addr, enc),
      hrp = _decode.hrp,
      data = _decode.data;

  var witnessVersion = data[0];
  validateWitnessVersion(witnessVersion);
  if (data.length === 0 || data.length > MAX_LEN) throw new Error("Invalid data length");
  var witnessProgram = convertBits(Array.from(data.slice(1)), 5, 8, false);
  if (witnessProgram.length < 2 || witnessProgram.length > 65) throw new Error("Invalid witness data length");
  if (data[0] === 0 && witnessProgram.length !== 53 && witnessProgram.length !== 65) throw new Error("Invalid witness data length for witness version 0");
  var blindingPublicKey = Buffer.from(witnessProgram.slice(0, 33)).toString("hex");
  var witness = Buffer.from(witnessProgram.slice(33)).toString("hex");
  return {
    witness: witness,
    blindingPublicKey: blindingPublicKey,
    witnessVersion: witnessVersion,
    hrp: hrp
  };
}
/**
 * a class wrapping the encodeAddress and decodeAddress functions.
 */


var Blech32Address = /*#__PURE__*/function () {
  function Blech32Address(data) {
    this.witness = data.witness;
    this.blindingPublicKey = data.blindingPublicKey;
    this.witnessVersion = data.witnessVersion;
    this.address = encodeAddress(data);
  }

  Blech32Address.from = function from(witness, blindingPublicKey, hrp, witnessVersion) {
    return new Blech32Address({
      witness: witness,
      witnessVersion: witnessVersion,
      blindingPublicKey: blindingPublicKey,
      hrp: hrp
    });
  };

  Blech32Address.fromString = function fromString(blechString, encodingType) {
    return new Blech32Address(decodeAddress(blechString, encodingType));
  };

  return Blech32Address;
}();

exports.BLECH32 = BLECH32;
exports.BLECH32M = BLECH32M;
exports.Blech32Address = Blech32Address;
exports.MAX_LEN = MAX_LEN;
exports.decode = decode;
exports.encode = encode;
exports.getEncodingType = getEncodingType;


}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":110,"long":43}],29:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var r,e=(r=require("long"))&&"object"==typeof r&&"default"in r?r.default:r;function n(r,e){(null==e||e>r.length)&&(e=r.length);for(var n=0,t=new Array(e);n<e;n++)t[n]=r[n];return t}function t(r,e,t,o){if(e<1||e>8||t<1||e>8)throw new Error("only bits groups between 1 and 8 are allowed");for(var i,a=[],f=0,s=0,h=function(r,e){var t="undefined"!=typeof Symbol&&r[Symbol.iterator]||r["@@iterator"];if(t)return(t=t.call(r)).next.bind(t);if(Array.isArray(r)||(t=function(r,e){if(r){if("string"==typeof r)return n(r,void 0);var t=Object.prototype.toString.call(r).slice(8,-1);return"Object"===t&&r.constructor&&(t=r.constructor.name),"Map"===t||"Set"===t?Array.from(r):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?n(r,void 0):void 0}}(r))){t&&(r=t);var o=0;return function(){return o>=r.length?{done:!0}:{done:!1,value:r[o++]}}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}(r);!(i=h()).done;)for(var c=i.value<<8-e,l=e;l>0;){var u=t-s,d=l;u<d&&(d=u),f=f<<d|c>>8-d,c=(c<<d)%256,l-=d,(s+=d)===t&&(a.push(f),s=0,f=0)}if(o&&s>0&&(a.push(f<<=t-s),s=0,f=0),s>0&&(s>4||0!==f))throw new Error("invalid incomplete group of bits");return a}function o(r){if(r<0||r>16)throw new Error("invalid witness version")}var i="qpzry9x8gf2tvdw0s3jn54khce6mua7l";function a(r){return e.fromString(r,!0,16)}var f=["7d52fba40bd886","5e8dbf1a03950c","1c3a3c74072a18","385d72fa0e5139","7093e5a608865b"].map(a);function s(r){if(o(r),0===r)return"blech32";if(1===r)return"blech32m";throw new Error("Unsuported witness version ("+r+"), only 0 (blech32) or 1 (blech32m) are supported")}function h(r){if("blech32"===r)return e.fromNumber(1);if("blech32m"===r)return a("455972a3350f7a1");throw new Error("Invalid encoding type")}function c(r){for(var n=e.fromNumber(1),t=0;t<r.length;++t){var o=n.shiftRight(55);n=n.and(a("7fffffffffffff")).shiftLeft(5).xor(r[t]);for(var i=0;i<5;i++)o.shiftRight(e.fromNumber(i)).and(1).equals(1)&&(n=n.xor(f[i]))}return n}function l(r){for(var e=[],n=0;n<r.length;++n)e.push(r.charCodeAt(n)>>5);e.push(0);for(var t=0;t<r.length;++t)e.push(31&r.charCodeAt(t));return Uint8Array.from(e)}var u=[0,0,0,0,0,0,0,0,0,0,0,0];function d(r,e,n){for(var t=function(r,e,n){for(var t=c(Array.from(l(r)).concat(Array.from(e)).concat(u)).xor(h(n)),o=[],i=0;i<12;++i)o.push(t.shiftRight(5*(11-i)).and(31));return o.map((function(r){return r.toInt()}))}(r,e,n),o=Array.from(e).concat(t),a=r+"1",f=0;f<o.length;++f)a+=i.charAt(o[f]);return a}function w(r,e){for(var n=!1,t=!1,o=0;o<r.length;++o){if(r.charCodeAt(o)<33||r.charCodeAt(o)>126)throw new Error("Invalid charcode in blech32 string");r.charCodeAt(o)>=97&&r.charCodeAt(o)<=122&&(n=!0),r.charCodeAt(o)>=65&&r.charCodeAt(o)<=90&&(t=!0)}if(n&&t)throw new Error("blech32 has lowercases AND uppercases");var a=(r=r.toLowerCase()).lastIndexOf("1");if(a<1||a+13>r.length)throw new Error('Invalid index of "1"');for(var f=r.substring(0,a),s=[],u=a+1;u<r.length;++u){var d=i.indexOf(r.charAt(u));if(-1===d)throw new Error('"'+r.charAt(u)+'" is not allowed in blech32 strings');s.push(d)}if(!function(r,e,n){return c(Array.from(l(r)).concat(e)).equals(h(n))}(f,s,e))throw new Error("invalid "+e+' checksum "'+r+'"');return{hrp:f,data:Uint8Array.from(s.slice(0,s.length-12))}}var v=function(){function r(r){this.witness=r.witness,this.blindingPublicKey=r.blindingPublicKey,this.witnessVersion=r.witnessVersion,this.address=function(r){var e=r.witness,n=r.witnessVersion,i=r.blindingPublicKey,a=r.hrp;o(n);var f=Buffer.concat([Buffer.from(i,"hex"),Buffer.from(e,"hex")]),h=f.length;if(0===n&&53!==h&&65!==h)throw new Error("witness version 0 needs witness program length = 53 OR = 65");if(h<2||h>65)throw new Error("witness program length should be >= 2 and <= 65");var c=[n].concat(t(Array.from(f),8,5,!0));return d(a,Uint8Array.from(c),s(c[0]))}(r)}return r.from=function(e,n,t,o){return new r({witness:e,witnessVersion:o,blindingPublicKey:n,hrp:t})},r.fromString=function(e,n){return new r(function(r,e){var n=w(r,e),i=n.hrp,a=n.data,f=a[0];if(o(f),0===a.length||a.length>1e3)throw new Error("Invalid data length");var s=t(Array.from(a.slice(1)),5,8,!1);if(s.length<2||s.length>65)throw new Error("Invalid witness data length");if(0===a[0]&&53!==s.length&&65!==s.length)throw new Error("Invalid witness data length for witness version 0");var h=Buffer.from(s.slice(0,33)).toString("hex");return{witness:Buffer.from(s.slice(33)).toString("hex"),blindingPublicKey:h,witnessVersion:f,hrp:i}}(e,n))},r}();exports.BLECH32="blech32",exports.BLECH32M="blech32m",exports.Blech32Address=v,exports.MAX_LEN=1e3,exports.decode=w,exports.encode=d,exports.getEncodingType=s;


}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":110,"long":43}],30:[function(require,module,exports){
(function (process){(function (){

'use strict'

if (process.env.NODE_ENV === 'production') {
  module.exports = require('./blech32.cjs.production.min.js')
} else {
  module.exports = require('./blech32.cjs.development.js')
}

}).call(this)}).call(this,require('_process'))
},{"./blech32.cjs.development.js":28,"./blech32.cjs.production.min.js":29,"_process":116}],31:[function(require,module,exports){
var basex = require('base-x')
var ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'

module.exports = basex(ALPHABET)

},{"base-x":3}],32:[function(require,module,exports){
'use strict'

var base58 = require('bs58')
var Buffer = require('safe-buffer').Buffer

module.exports = function (checksumFn) {
  // Encode a buffer as a base58-check encoded string
  function encode (payload) {
    var checksum = checksumFn(payload)

    return base58.encode(Buffer.concat([
      payload,
      checksum
    ], payload.length + 4))
  }

  function decodeRaw (buffer) {
    var payload = buffer.slice(0, -4)
    var checksum = buffer.slice(-4)
    var newChecksum = checksumFn(payload)

    if (checksum[0] ^ newChecksum[0] |
        checksum[1] ^ newChecksum[1] |
        checksum[2] ^ newChecksum[2] |
        checksum[3] ^ newChecksum[3]) return

    return payload
  }

  // Decode a base58-check encoded string to a buffer, no result if checksum is wrong
  function decodeUnsafe (string) {
    var buffer = base58.decodeUnsafe(string)
    if (!buffer) return

    return decodeRaw(buffer)
  }

  function decode (string) {
    var buffer = base58.decode(string)
    var payload = decodeRaw(buffer, checksumFn)
    if (!payload) throw new Error('Invalid checksum')
    return payload
  }

  return {
    encode: encode,
    decode: decode,
    decodeUnsafe: decodeUnsafe
  }
}

},{"bs58":31,"safe-buffer":62}],33:[function(require,module,exports){
'use strict'

var createHash = require('create-hash')
var bs58checkBase = require('./base')

// SHA256(SHA256(buffer))
function sha256x2 (buffer) {
  var tmp = createHash('sha256').update(buffer).digest()
  return createHash('sha256').update(tmp).digest()
}

module.exports = bs58checkBase(sha256x2)

},{"./base":32,"create-hash":35}],34:[function(require,module,exports){
var Buffer = require('safe-buffer').Buffer
var Transform = require('stream').Transform
var StringDecoder = require('string_decoder').StringDecoder
var inherits = require('inherits')

function CipherBase (hashMode) {
  Transform.call(this)
  this.hashMode = typeof hashMode === 'string'
  if (this.hashMode) {
    this[hashMode] = this._finalOrDigest
  } else {
    this.final = this._finalOrDigest
  }
  if (this._final) {
    this.__final = this._final
    this._final = null
  }
  this._decoder = null
  this._encoding = null
}
inherits(CipherBase, Transform)

CipherBase.prototype.update = function (data, inputEnc, outputEnc) {
  if (typeof data === 'string') {
    data = Buffer.from(data, inputEnc)
  }

  var outData = this._update(data)
  if (this.hashMode) return this

  if (outputEnc) {
    outData = this._toString(outData, outputEnc)
  }

  return outData
}

CipherBase.prototype.setAutoPadding = function () {}
CipherBase.prototype.getAuthTag = function () {
  throw new Error('trying to get auth tag in unsupported state')
}

CipherBase.prototype.setAuthTag = function () {
  throw new Error('trying to set auth tag in unsupported state')
}

CipherBase.prototype.setAAD = function () {
  throw new Error('trying to set aad in unsupported state')
}

CipherBase.prototype._transform = function (data, _, next) {
  var err
  try {
    if (this.hashMode) {
      this._update(data)
    } else {
      this.push(this._update(data))
    }
  } catch (e) {
    err = e
  } finally {
    next(err)
  }
}
CipherBase.prototype._flush = function (done) {
  var err
  try {
    this.push(this.__final())
  } catch (e) {
    err = e
  }

  done(err)
}
CipherBase.prototype._finalOrDigest = function (outputEnc) {
  var outData = this.__final() || Buffer.alloc(0)
  if (outputEnc) {
    outData = this._toString(outData, outputEnc, true)
  }
  return outData
}

CipherBase.prototype._toString = function (value, enc, fin) {
  if (!this._decoder) {
    this._decoder = new StringDecoder(enc)
    this._encoding = enc
  }

  if (this._encoding !== enc) throw new Error('can\'t switch encodings')

  var out = this._decoder.write(value)
  if (fin) {
    out += this._decoder.end()
  }

  return out
}

module.exports = CipherBase

},{"inherits":42,"safe-buffer":62,"stream":118,"string_decoder":133}],35:[function(require,module,exports){
'use strict'
var inherits = require('inherits')
var MD5 = require('md5.js')
var RIPEMD160 = require('ripemd160')
var sha = require('sha.js')
var Base = require('cipher-base')

function Hash (hash) {
  Base.call(this, 'digest')

  this._hash = hash
}

inherits(Hash, Base)

Hash.prototype._update = function (data) {
  this._hash.update(data)
}

Hash.prototype._final = function () {
  return this._hash.digest()
}

module.exports = function createHash (alg) {
  alg = alg.toLowerCase()
  if (alg === 'md5') return new MD5()
  if (alg === 'rmd160' || alg === 'ripemd160') return new RIPEMD160()

  return new Hash(sha(alg))
}

},{"cipher-base":34,"inherits":42,"md5.js":44,"ripemd160":61,"sha.js":64}],36:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
exports.ECPairFactory = exports.networks = void 0;
const networks = require('./networks');
exports.networks = networks;
const types = require('./types');
const randomBytes = require('randombytes');
const wif = require('wif');
const testecc_1 = require('./testecc');
const isOptions = types.typeforce.maybe(
  types.typeforce.compile({
    compressed: types.maybe(types.Boolean),
    network: types.maybe(types.Network),
  }),
);
function ECPairFactory(ecc) {
  (0, testecc_1.testEcc)(ecc);
  function isPoint(maybePoint) {
    return ecc.isPoint(maybePoint);
  }
  function fromPrivateKey(buffer, options) {
    types.typeforce(types.Buffer256bit, buffer);
    if (!ecc.isPrivate(buffer))
      throw new TypeError('Private key not in range [1, n)');
    types.typeforce(isOptions, options);
    return new ECPair(buffer, undefined, options);
  }
  function fromPublicKey(buffer, options) {
    types.typeforce(ecc.isPoint, buffer);
    types.typeforce(isOptions, options);
    return new ECPair(undefined, buffer, options);
  }
  function fromWIF(wifString, network) {
    const decoded = wif.decode(wifString);
    const version = decoded.version;
    // list of networks?
    if (types.Array(network)) {
      network = network
        .filter((x) => {
          return version === x.wif;
        })
        .pop();
      if (!network) throw new Error('Unknown network version');
      // otherwise, assume a network object (or default to bitcoin)
    } else {
      network = network || networks.bitcoin;
      if (version !== network.wif) throw new Error('Invalid network version');
    }
    return fromPrivateKey(decoded.privateKey, {
      compressed: decoded.compressed,
      network: network,
    });
  }
  function makeRandom(options) {
    types.typeforce(isOptions, options);
    if (options === undefined) options = {};
    const rng = options.rng || randomBytes;
    let d;
    do {
      d = rng(32);
      types.typeforce(types.Buffer256bit, d);
    } while (!ecc.isPrivate(d));
    return fromPrivateKey(d, options);
  }
  class ECPair {
    __D;
    __Q;
    compressed;
    network;
    lowR;
    constructor(__D, __Q, options) {
      this.__D = __D;
      this.__Q = __Q;
      this.lowR = false;
      if (options === undefined) options = {};
      this.compressed =
        options.compressed === undefined ? true : options.compressed;
      this.network = options.network || networks.bitcoin;
      if (__Q !== undefined)
        this.__Q = Buffer.from(ecc.pointCompress(__Q, this.compressed));
    }
    get privateKey() {
      return this.__D;
    }
    get publicKey() {
      if (!this.__Q) {
        // It is not possible for both `__Q` and `__D` to be `undefined` at the same time.
        // The factory methods guard for this.
        const p = ecc.pointFromScalar(this.__D, this.compressed);
        // It is not possible for `p` to be null.
        // `fromPrivateKey()` checks that `__D` is a valid scalar.
        this.__Q = Buffer.from(p);
      }
      return this.__Q;
    }
    toWIF() {
      if (!this.__D) throw new Error('Missing private key');
      return wif.encode(this.network.wif, this.__D, this.compressed);
    }
    sign(hash, lowR) {
      if (!this.__D) throw new Error('Missing private key');
      if (lowR === undefined) lowR = this.lowR;
      if (lowR === false) {
        return Buffer.from(ecc.sign(hash, this.__D));
      } else {
        let sig = ecc.sign(hash, this.__D);
        const extraData = Buffer.alloc(32, 0);
        let counter = 0;
        // if first try is lowR, skip the loop
        // for second try and on, add extra entropy counting up
        while (sig[0] > 0x7f) {
          counter++;
          extraData.writeUIntLE(counter, 0, 6);
          sig = ecc.sign(hash, this.__D, extraData);
        }
        return Buffer.from(sig);
      }
    }
    signSchnorr(hash) {
      if (!this.privateKey) throw new Error('Missing private key');
      if (!ecc.signSchnorr)
        throw new Error('signSchnorr not supported by ecc library');
      return Buffer.from(ecc.signSchnorr(hash, this.privateKey));
    }
    verify(hash, signature) {
      return ecc.verify(hash, this.publicKey, signature);
    }
    verifySchnorr(hash, signature) {
      if (!ecc.verifySchnorr)
        throw new Error('verifySchnorr not supported by ecc library');
      return ecc.verifySchnorr(hash, this.publicKey.subarray(1, 33), signature);
    }
  }
  return {
    isPoint,
    fromPrivateKey,
    fromPublicKey,
    fromWIF,
    makeRandom,
  };
}
exports.ECPairFactory = ECPairFactory;

}).call(this)}).call(this,require("buffer").Buffer)
},{"./networks":38,"./testecc":39,"./types":40,"buffer":110,"randombytes":45,"wif":78}],37:[function(require,module,exports){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
exports.networks = exports.ECPairFactory = exports.default = void 0;
var ecpair_1 = require('./ecpair');
Object.defineProperty(exports, 'default', {
  enumerable: true,
  get: function () {
    return ecpair_1.ECPairFactory;
  },
});
Object.defineProperty(exports, 'ECPairFactory', {
  enumerable: true,
  get: function () {
    return ecpair_1.ECPairFactory;
  },
});
Object.defineProperty(exports, 'networks', {
  enumerable: true,
  get: function () {
    return ecpair_1.networks;
  },
});

},{"./ecpair":36}],38:[function(require,module,exports){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
exports.testnet = exports.bitcoin = void 0;
exports.bitcoin = {
  messagePrefix: '\x18Bitcoin Signed Message:\n',
  bech32: 'bc',
  bip32: {
    public: 0x0488b21e,
    private: 0x0488ade4,
  },
  pubKeyHash: 0x00,
  scriptHash: 0x05,
  wif: 0x80,
};
exports.testnet = {
  messagePrefix: '\x18Bitcoin Signed Message:\n',
  bech32: 'tb',
  bip32: {
    public: 0x043587cf,
    private: 0x04358394,
  },
  pubKeyHash: 0x6f,
  scriptHash: 0xc4,
  wif: 0xef,
};

},{}],39:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
exports.testEcc = void 0;
const h = (hex) => Buffer.from(hex, 'hex');
function testEcc(ecc) {
  assert(
    ecc.isPoint(
      h('0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'),
    ),
  );
  assert(
    !ecc.isPoint(
      h('030000000000000000000000000000000000000000000000000000000000000005'),
    ),
  );
  assert(
    ecc.isPrivate(
      h('79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'),
    ),
  );
  // order - 1
  assert(
    ecc.isPrivate(
      h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140'),
    ),
  );
  // 0
  assert(
    !ecc.isPrivate(
      h('0000000000000000000000000000000000000000000000000000000000000000'),
    ),
  );
  // order
  assert(
    !ecc.isPrivate(
      h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141'),
    ),
  );
  // order + 1
  assert(
    !ecc.isPrivate(
      h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364142'),
    ),
  );
  assert(
    Buffer.from(
      ecc.pointCompress(
        h(
          '0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',
        ),
        true,
      ),
    ).equals(
      h('0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'),
    ),
  );
  assert(
    Buffer.from(
      ecc.pointCompress(
        h(
          '0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',
        ),
        false,
      ),
    ).equals(
      h(
        '0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',
      ),
    ),
  );
  assert(
    Buffer.from(
      ecc.pointCompress(
        h('0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'),
        true,
      ),
    ).equals(
      h('0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'),
    ),
  );
  assert(
    Buffer.from(
      ecc.pointCompress(
        h('0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'),
        false,
      ),
    ).equals(
      h(
        '0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',
      ),
    ),
  );
  assert(
    Buffer.from(
      ecc.pointFromScalar(
        h('b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af'),
      ),
    ).equals(
      h('02b07ba9dca9523b7ef4bd97703d43d20399eb698e194704791a25ce77a400df99'),
    ),
  );
  assert(
    Buffer.from(
      ecc.sign(
        h('5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed'),
        h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140'),
      ),
    ).equals(
      h(
        '54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5',
      ),
    ),
  );
  assert(
    ecc.verify(
      h('5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed'),
      h('0379be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'),
      h(
        '54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5',
      ),
    ),
  );
  if (ecc.signSchnorr) {
    assert(
      Buffer.from(
        ecc.signSchnorr(
          h('7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c'),
          h('c90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b14e5c9'),
          h('c87aa53824b4d7ae2eb035a2b5bbbccc080e76cdc6d1692c4b0b62d798e6d906'),
        ),
      ).equals(
        h(
          '5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7',
        ),
      ),
    );
  }
  if (ecc.verifySchnorr) {
    assert(
      ecc.verifySchnorr(
        h('7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c'),
        h('dd308afec5777e13121fa72b9cc1b7cc0139715309b086c960e18fd969774eb8'),
        h(
          '5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7',
        ),
      ),
    );
  }
}
exports.testEcc = testEcc;
function assert(bool) {
  if (!bool) throw new Error('ecc library invalid');
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":110}],40:[function(require,module,exports){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
exports.maybe =
  exports.Boolean =
  exports.Array =
  exports.Buffer256bit =
  exports.Network =
  exports.typeforce =
    void 0;
exports.typeforce = require('typeforce');
// exposed, external API
exports.Network = exports.typeforce.compile({
  messagePrefix: exports.typeforce.oneOf(
    exports.typeforce.Buffer,
    exports.typeforce.String,
  ),
  bip32: {
    public: exports.typeforce.UInt32,
    private: exports.typeforce.UInt32,
  },
  pubKeyHash: exports.typeforce.UInt8,
  scriptHash: exports.typeforce.UInt8,
  wif: exports.typeforce.UInt8,
});
exports.Buffer256bit = exports.typeforce.BufferN(32);
exports.Array = exports.typeforce.Array;
exports.Boolean = exports.typeforce.Boolean; // tslint:disable-line variable-name
exports.maybe = exports.typeforce.maybe;

},{"typeforce":74}],41:[function(require,module,exports){
'use strict'
var Buffer = require('safe-buffer').Buffer
var Transform = require('readable-stream').Transform
var inherits = require('inherits')

function throwIfNotStringOrBuffer (val, prefix) {
  if (!Buffer.isBuffer(val) && typeof val !== 'string') {
    throw new TypeError(prefix + ' must be a string or a buffer')
  }
}

function HashBase (blockSize) {
  Transform.call(this)

  this._block = Buffer.allocUnsafe(blockSize)
  this._blockSize = blockSize
  this._blockOffset = 0
  this._length = [0, 0, 0, 0]

  this._finalized = false
}

inherits(HashBase, Transform)

HashBase.prototype._transform = function (chunk, encoding, callback) {
  var error = null
  try {
    this.update(chunk, encoding)
  } catch (err) {
    error = err
  }

  callback(error)
}

HashBase.prototype._flush = function (callback) {
  var error = null
  try {
    this.push(this.digest())
  } catch (err) {
    error = err
  }

  callback(error)
}

HashBase.prototype.update = function (data, encoding) {
  throwIfNotStringOrBuffer(data, 'Data')
  if (this._finalized) throw new Error('Digest already called')
  if (!Buffer.isBuffer(data)) data = Buffer.from(data, encoding)

  // consume data
  var block = this._block
  var offset = 0
  while (this._blockOffset + data.length - offset >= this._blockSize) {
    for (var i = this._blockOffset; i < this._blockSize;) block[i++] = data[offset++]
    this._update()
    this._blockOffset = 0
  }
  while (offset < data.length) block[this._blockOffset++] = data[offset++]

  // update length
  for (var j = 0, carry = data.length * 8; carry > 0; ++j) {
    this._length[j] += carry
    carry = (this._length[j] / 0x0100000000) | 0
    if (carry > 0) this._length[j] -= 0x0100000000 * carry
  }

  return this
}

HashBase.prototype._update = function () {
  throw new Error('_update is not implemented')
}

HashBase.prototype.digest = function (encoding) {
  if (this._finalized) throw new Error('Digest already called')
  this._finalized = true

  var digest = this._digest()
  if (encoding !== undefined) digest = digest.toString(encoding)

  // reset state
  this._block.fill(0)
  this._blockOffset = 0
  for (var i = 0; i < 4; ++i) this._length[i] = 0

  return digest
}

HashBase.prototype._digest = function () {
  throw new Error('_digest is not implemented')
}

module.exports = HashBase

},{"inherits":42,"readable-stream":60,"safe-buffer":62}],42:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}

},{}],43:[function(require,module,exports){
module.exports = Long;

/**
 * wasm optimizations, to do native i64 multiplication and divide
 */
var wasm = null;

try {
  wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
    0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11
  ])), {}).exports;
} catch (e) {
  // no wasm support :(
}

/**
 * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.
 *  See the from* functions below for more convenient ways of constructing Longs.
 * @exports Long
 * @class A Long class for representing a 64 bit two's-complement integer value.
 * @param {number} low The low (signed) 32 bits of the long
 * @param {number} high The high (signed) 32 bits of the long
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @constructor
 */
function Long(low, high, unsigned) {

    /**
     * The low 32 bits as a signed value.
     * @type {number}
     */
    this.low = low | 0;

    /**
     * The high 32 bits as a signed value.
     * @type {number}
     */
    this.high = high | 0;

    /**
     * Whether unsigned or not.
     * @type {boolean}
     */
    this.unsigned = !!unsigned;
}

// The internal representation of a long is the two given signed, 32-bit values.
// We use 32-bit pieces because these are the size of integers on which
// Javascript performs bit-operations.  For operations like addition and
// multiplication, we split each number into 16 bit pieces, which can easily be
// multiplied within Javascript's floating-point representation without overflow
// or change in sign.
//
// In the algorithms below, we frequently reduce the negative case to the
// positive case by negating the input(s) and then post-processing the result.
// Note that we must ALWAYS check specially whether those values are MIN_VALUE
// (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
// a positive number, it overflows back into a negative).  Not handling this
// case would often result in infinite recursion.
//
// Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*
// methods on which they depend.

/**
 * An indicator used to reliably determine if an object is a Long or not.
 * @type {boolean}
 * @const
 * @private
 */
Long.prototype.__isLong__;

Object.defineProperty(Long.prototype, "__isLong__", { value: true });

/**
 * @function
 * @param {*} obj Object
 * @returns {boolean}
 * @inner
 */
function isLong(obj) {
    return (obj && obj["__isLong__"]) === true;
}

/**
 * Tests if the specified object is a Long.
 * @function
 * @param {*} obj Object
 * @returns {boolean}
 */
Long.isLong = isLong;

/**
 * A cache of the Long representations of small integer values.
 * @type {!Object}
 * @inner
 */
var INT_CACHE = {};

/**
 * A cache of the Long representations of small unsigned integer values.
 * @type {!Object}
 * @inner
 */
var UINT_CACHE = {};

/**
 * @param {number} value
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromInt(value, unsigned) {
    var obj, cachedObj, cache;
    if (unsigned) {
        value >>>= 0;
        if (cache = (0 <= value && value < 256)) {
            cachedObj = UINT_CACHE[value];
            if (cachedObj)
                return cachedObj;
        }
        obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);
        if (cache)
            UINT_CACHE[value] = obj;
        return obj;
    } else {
        value |= 0;
        if (cache = (-128 <= value && value < 128)) {
            cachedObj = INT_CACHE[value];
            if (cachedObj)
                return cachedObj;
        }
        obj = fromBits(value, value < 0 ? -1 : 0, false);
        if (cache)
            INT_CACHE[value] = obj;
        return obj;
    }
}

/**
 * Returns a Long representing the given 32 bit integer value.
 * @function
 * @param {number} value The 32 bit integer in question
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromInt = fromInt;

/**
 * @param {number} value
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromNumber(value, unsigned) {
    if (isNaN(value))
        return unsigned ? UZERO : ZERO;
    if (unsigned) {
        if (value < 0)
            return UZERO;
        if (value >= TWO_PWR_64_DBL)
            return MAX_UNSIGNED_VALUE;
    } else {
        if (value <= -TWO_PWR_63_DBL)
            return MIN_VALUE;
        if (value + 1 >= TWO_PWR_63_DBL)
            return MAX_VALUE;
    }
    if (value < 0)
        return fromNumber(-value, unsigned).neg();
    return fromBits((value % TWO_PWR_32_DBL) | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);
}

/**
 * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.
 * @function
 * @param {number} value The number in question
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromNumber = fromNumber;

/**
 * @param {number} lowBits
 * @param {number} highBits
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromBits(lowBits, highBits, unsigned) {
    return new Long(lowBits, highBits, unsigned);
}

/**
 * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is
 *  assumed to use 32 bits.
 * @function
 * @param {number} lowBits The low 32 bits
 * @param {number} highBits The high 32 bits
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromBits = fromBits;

/**
 * @function
 * @param {number} base
 * @param {number} exponent
 * @returns {number}
 * @inner
 */
var pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)

/**
 * @param {string} str
 * @param {(boolean|number)=} unsigned
 * @param {number=} radix
 * @returns {!Long}
 * @inner
 */
function fromString(str, unsigned, radix) {
    if (str.length === 0)
        throw Error('empty string');
    if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
        return ZERO;
    if (typeof unsigned === 'number') {
        // For goog.math.long compatibility
        radix = unsigned,
        unsigned = false;
    } else {
        unsigned = !! unsigned;
    }
    radix = radix || 10;
    if (radix < 2 || 36 < radix)
        throw RangeError('radix');

    var p;
    if ((p = str.indexOf('-')) > 0)
        throw Error('interior hyphen');
    else if (p === 0) {
        return fromString(str.substring(1), unsigned, radix).neg();
    }

    // Do several (8) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
    var radixToPower = fromNumber(pow_dbl(radix, 8));

    var result = ZERO;
    for (var i = 0; i < str.length; i += 8) {
        var size = Math.min(8, str.length - i),
            value = parseInt(str.substring(i, i + size), radix);
        if (size < 8) {
            var power = fromNumber(pow_dbl(radix, size));
            result = result.mul(power).add(fromNumber(value));
        } else {
            result = result.mul(radixToPower);
            result = result.add(fromNumber(value));
        }
    }
    result.unsigned = unsigned;
    return result;
}

/**
 * Returns a Long representation of the given string, written using the specified radix.
 * @function
 * @param {string} str The textual representation of the Long
 * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed
 * @param {number=} radix The radix in which the text is written (2-36), defaults to 10
 * @returns {!Long} The corresponding Long value
 */
Long.fromString = fromString;

/**
 * @function
 * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromValue(val, unsigned) {
    if (typeof val === 'number')
        return fromNumber(val, unsigned);
    if (typeof val === 'string')
        return fromString(val, unsigned);
    // Throws for non-objects, converts non-instanceof Long:
    return fromBits(val.low, val.high, typeof unsigned === 'boolean' ? unsigned : val.unsigned);
}

/**
 * Converts the specified value to a Long using the appropriate from* function for its type.
 * @function
 * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long}
 */
Long.fromValue = fromValue;

// NOTE: the compiler should inline these constant values below and then remove these variables, so there should be
// no runtime penalty for these.

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_16_DBL = 1 << 16;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_24_DBL = 1 << 24;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;

/**
 * @type {!Long}
 * @const
 * @inner
 */
var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);

/**
 * @type {!Long}
 * @inner
 */
var ZERO = fromInt(0);

/**
 * Signed zero.
 * @type {!Long}
 */
Long.ZERO = ZERO;

/**
 * @type {!Long}
 * @inner
 */
var UZERO = fromInt(0, true);

/**
 * Unsigned zero.
 * @type {!Long}
 */
Long.UZERO = UZERO;

/**
 * @type {!Long}
 * @inner
 */
var ONE = fromInt(1);

/**
 * Signed one.
 * @type {!Long}
 */
Long.ONE = ONE;

/**
 * @type {!Long}
 * @inner
 */
var UONE = fromInt(1, true);

/**
 * Unsigned one.
 * @type {!Long}
 */
Long.UONE = UONE;

/**
 * @type {!Long}
 * @inner
 */
var NEG_ONE = fromInt(-1);

/**
 * Signed negative one.
 * @type {!Long}
 */
Long.NEG_ONE = NEG_ONE;

/**
 * @type {!Long}
 * @inner
 */
var MAX_VALUE = fromBits(0xFFFFFFFF|0, 0x7FFFFFFF|0, false);

/**
 * Maximum signed value.
 * @type {!Long}
 */
Long.MAX_VALUE = MAX_VALUE;

/**
 * @type {!Long}
 * @inner
 */
var MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF|0, 0xFFFFFFFF|0, true);

/**
 * Maximum unsigned value.
 * @type {!Long}
 */
Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;

/**
 * @type {!Long}
 * @inner
 */
var MIN_VALUE = fromBits(0, 0x80000000|0, false);

/**
 * Minimum signed value.
 * @type {!Long}
 */
Long.MIN_VALUE = MIN_VALUE;

/**
 * @alias Long.prototype
 * @inner
 */
var LongPrototype = Long.prototype;

/**
 * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.
 * @returns {number}
 */
LongPrototype.toInt = function toInt() {
    return this.unsigned ? this.low >>> 0 : this.low;
};

/**
 * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).
 * @returns {number}
 */
LongPrototype.toNumber = function toNumber() {
    if (this.unsigned)
        return ((this.high >>> 0) * TWO_PWR_32_DBL) + (this.low >>> 0);
    return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
};

/**
 * Converts the Long to a string written in the specified radix.
 * @param {number=} radix Radix (2-36), defaults to 10
 * @returns {string}
 * @override
 * @throws {RangeError} If `radix` is out of range
 */
LongPrototype.toString = function toString(radix) {
    radix = radix || 10;
    if (radix < 2 || 36 < radix)
        throw RangeError('radix');
    if (this.isZero())
        return '0';
    if (this.isNegative()) { // Unsigned Longs are never negative
        if (this.eq(MIN_VALUE)) {
            // We need to change the Long value before it can be negated, so we remove
            // the bottom-most digit in this base and then recurse to do the rest.
            var radixLong = fromNumber(radix),
                div = this.div(radixLong),
                rem1 = div.mul(radixLong).sub(this);
            return div.toString(radix) + rem1.toInt().toString(radix);
        } else
            return '-' + this.neg().toString(radix);
    }

    // Do several (6) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
    var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),
        rem = this;
    var result = '';
    while (true) {
        var remDiv = rem.div(radixToPower),
            intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,
            digits = intval.toString(radix);
        rem = remDiv;
        if (rem.isZero())
            return digits + result;
        else {
            while (digits.length < 6)
                digits = '0' + digits;
            result = '' + digits + result;
        }
    }
};

/**
 * Gets the high 32 bits as a signed integer.
 * @returns {number} Signed high bits
 */
LongPrototype.getHighBits = function getHighBits() {
    return this.high;
};

/**
 * Gets the high 32 bits as an unsigned integer.
 * @returns {number} Unsigned high bits
 */
LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
    return this.high >>> 0;
};

/**
 * Gets the low 32 bits as a signed integer.
 * @returns {number} Signed low bits
 */
LongPrototype.getLowBits = function getLowBits() {
    return this.low;
};

/**
 * Gets the low 32 bits as an unsigned integer.
 * @returns {number} Unsigned low bits
 */
LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
    return this.low >>> 0;
};

/**
 * Gets the number of bits needed to represent the absolute value of this Long.
 * @returns {number}
 */
LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
    if (this.isNegative()) // Unsigned Longs are never negative
        return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
    var val = this.high != 0 ? this.high : this.low;
    for (var bit = 31; bit > 0; bit--)
        if ((val & (1 << bit)) != 0)
            break;
    return this.high != 0 ? bit + 33 : bit + 1;
};

/**
 * Tests if this Long's value equals zero.
 * @returns {boolean}
 */
LongPrototype.isZero = function isZero() {
    return this.high === 0 && this.low === 0;
};

/**
 * Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.
 * @returns {boolean}
 */
LongPrototype.eqz = LongPrototype.isZero;

/**
 * Tests if this Long's value is negative.
 * @returns {boolean}
 */
LongPrototype.isNegative = function isNegative() {
    return !this.unsigned && this.high < 0;
};

/**
 * Tests if this Long's value is positive.
 * @returns {boolean}
 */
LongPrototype.isPositive = function isPositive() {
    return this.unsigned || this.high >= 0;
};

/**
 * Tests if this Long's value is odd.
 * @returns {boolean}
 */
LongPrototype.isOdd = function isOdd() {
    return (this.low & 1) === 1;
};

/**
 * Tests if this Long's value is even.
 * @returns {boolean}
 */
LongPrototype.isEven = function isEven() {
    return (this.low & 1) === 0;
};

/**
 * Tests if this Long's value equals the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.equals = function equals(other) {
    if (!isLong(other))
        other = fromValue(other);
    if (this.unsigned !== other.unsigned && (this.high >>> 31) === 1 && (other.high >>> 31) === 1)
        return false;
    return this.high === other.high && this.low === other.low;
};

/**
 * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.eq = LongPrototype.equals;

/**
 * Tests if this Long's value differs from the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.notEquals = function notEquals(other) {
    return !this.eq(/* validates */ other);
};

/**
 * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.neq = LongPrototype.notEquals;

/**
 * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.ne = LongPrototype.notEquals;

/**
 * Tests if this Long's value is less than the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lessThan = function lessThan(other) {
    return this.comp(/* validates */ other) < 0;
};

/**
 * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lt = LongPrototype.lessThan;

/**
 * Tests if this Long's value is less than or equal the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
    return this.comp(/* validates */ other) <= 0;
};

/**
 * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lte = LongPrototype.lessThanOrEqual;

/**
 * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.le = LongPrototype.lessThanOrEqual;

/**
 * Tests if this Long's value is greater than the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.greaterThan = function greaterThan(other) {
    return this.comp(/* validates */ other) > 0;
};

/**
 * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.gt = LongPrototype.greaterThan;

/**
 * Tests if this Long's value is greater than or equal the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
    return this.comp(/* validates */ other) >= 0;
};

/**
 * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.gte = LongPrototype.greaterThanOrEqual;

/**
 * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.ge = LongPrototype.greaterThanOrEqual;

/**
 * Compares this Long's value with the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {number} 0 if they are the same, 1 if the this is greater and -1
 *  if the given one is greater
 */
LongPrototype.compare = function compare(other) {
    if (!isLong(other))
        other = fromValue(other);
    if (this.eq(other))
        return 0;
    var thisNeg = this.isNegative(),
        otherNeg = other.isNegative();
    if (thisNeg && !otherNeg)
        return -1;
    if (!thisNeg && otherNeg)
        return 1;
    // At this point the sign bits are the same
    if (!this.unsigned)
        return this.sub(other).isNegative() ? -1 : 1;
    // Both are positive if at least one is unsigned
    return (other.high >>> 0) > (this.high >>> 0) || (other.high === this.high && (other.low >>> 0) > (this.low >>> 0)) ? -1 : 1;
};

/**
 * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {number} 0 if they are the same, 1 if the this is greater and -1
 *  if the given one is greater
 */
LongPrototype.comp = LongPrototype.compare;

/**
 * Negates this Long's value.
 * @returns {!Long} Negated Long
 */
LongPrototype.negate = function negate() {
    if (!this.unsigned && this.eq(MIN_VALUE))
        return MIN_VALUE;
    return this.not().add(ONE);
};

/**
 * Negates this Long's value. This is an alias of {@link Long#negate}.
 * @function
 * @returns {!Long} Negated Long
 */
LongPrototype.neg = LongPrototype.negate;

/**
 * Returns the sum of this and the specified Long.
 * @param {!Long|number|string} addend Addend
 * @returns {!Long} Sum
 */
LongPrototype.add = function add(addend) {
    if (!isLong(addend))
        addend = fromValue(addend);

    // Divide each number into 4 chunks of 16 bits, and then sum the chunks.

    var a48 = this.high >>> 16;
    var a32 = this.high & 0xFFFF;
    var a16 = this.low >>> 16;
    var a00 = this.low & 0xFFFF;

    var b48 = addend.high >>> 16;
    var b32 = addend.high & 0xFFFF;
    var b16 = addend.low >>> 16;
    var b00 = addend.low & 0xFFFF;

    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 + b00;
    c16 += c00 >>> 16;
    c00 &= 0xFFFF;
    c16 += a16 + b16;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c32 += a32 + b32;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c48 += a48 + b48;
    c48 &= 0xFFFF;
    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
};

/**
 * Returns the difference of this and the specified Long.
 * @param {!Long|number|string} subtrahend Subtrahend
 * @returns {!Long} Difference
 */
LongPrototype.subtract = function subtract(subtrahend) {
    if (!isLong(subtrahend))
        subtrahend = fromValue(subtrahend);
    return this.add(subtrahend.neg());
};

/**
 * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.
 * @function
 * @param {!Long|number|string} subtrahend Subtrahend
 * @returns {!Long} Difference
 */
LongPrototype.sub = LongPrototype.subtract;

/**
 * Returns the product of this and the specified Long.
 * @param {!Long|number|string} multiplier Multiplier
 * @returns {!Long} Product
 */
LongPrototype.multiply = function multiply(multiplier) {
    if (this.isZero())
        return ZERO;
    if (!isLong(multiplier))
        multiplier = fromValue(multiplier);

    // use wasm support if present
    if (wasm) {
        var low = wasm.mul(this.low,
                           this.high,
                           multiplier.low,
                           multiplier.high);
        return fromBits(low, wasm.get_high(), this.unsigned);
    }

    if (multiplier.isZero())
        return ZERO;
    if (this.eq(MIN_VALUE))
        return multiplier.isOdd() ? MIN_VALUE : ZERO;
    if (multiplier.eq(MIN_VALUE))
        return this.isOdd() ? MIN_VALUE : ZERO;

    if (this.isNegative()) {
        if (multiplier.isNegative())
            return this.neg().mul(multiplier.neg());
        else
            return this.neg().mul(multiplier).neg();
    } else if (multiplier.isNegative())
        return this.mul(multiplier.neg()).neg();

    // If both longs are small, use float multiplication
    if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
        return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);

    // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
    // We can skip products that would overflow.

    var a48 = this.high >>> 16;
    var a32 = this.high & 0xFFFF;
    var a16 = this.low >>> 16;
    var a00 = this.low & 0xFFFF;

    var b48 = multiplier.high >>> 16;
    var b32 = multiplier.high & 0xFFFF;
    var b16 = multiplier.low >>> 16;
    var b00 = multiplier.low & 0xFFFF;

    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 * b00;
    c16 += c00 >>> 16;
    c00 &= 0xFFFF;
    c16 += a16 * b00;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c16 += a00 * b16;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c32 += a32 * b00;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c32 += a16 * b16;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c32 += a00 * b32;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
    c48 &= 0xFFFF;
    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
};

/**
 * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.
 * @function
 * @param {!Long|number|string} multiplier Multiplier
 * @returns {!Long} Product
 */
LongPrototype.mul = LongPrototype.multiply;

/**
 * Returns this Long divided by the specified. The result is signed if this Long is signed or
 *  unsigned if this Long is unsigned.
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Quotient
 */
LongPrototype.divide = function divide(divisor) {
    if (!isLong(divisor))
        divisor = fromValue(divisor);
    if (divisor.isZero())
        throw Error('division by zero');

    // use wasm support if present
    if (wasm) {
        // guard against signed division overflow: the largest
        // negative number / -1 would be 1 larger than the largest
        // positive number, due to two's complement.
        if (!this.unsigned &&
            this.high === -0x80000000 &&
            divisor.low === -1 && divisor.high === -1) {
            // be consistent with non-wasm code path
            return this;
        }
        var low = (this.unsigned ? wasm.div_u : wasm.div_s)(
            this.low,
            this.high,
            divisor.low,
            divisor.high
        );
        return fromBits(low, wasm.get_high(), this.unsigned);
    }

    if (this.isZero())
        return this.unsigned ? UZERO : ZERO;
    var approx, rem, res;
    if (!this.unsigned) {
        // This section is only relevant for signed longs and is derived from the
        // closure library as a whole.
        if (this.eq(MIN_VALUE)) {
            if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
                return MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE
            else if (divisor.eq(MIN_VALUE))
                return ONE;
            else {
                // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
                var halfThis = this.shr(1);
                approx = halfThis.div(divisor).shl(1);
                if (approx.eq(ZERO)) {
                    return divisor.isNegative() ? ONE : NEG_ONE;
                } else {
                    rem = this.sub(divisor.mul(approx));
                    res = approx.add(rem.div(divisor));
                    return res;
                }
            }
        } else if (divisor.eq(MIN_VALUE))
            return this.unsigned ? UZERO : ZERO;
        if (this.isNegative()) {
            if (divisor.isNegative())
                return this.neg().div(divisor.neg());
            return this.neg().div(divisor).neg();
        } else if (divisor.isNegative())
            return this.div(divisor.neg()).neg();
        res = ZERO;
    } else {
        // The algorithm below has not been made for unsigned longs. It's therefore
        // required to take special care of the MSB prior to running it.
        if (!divisor.unsigned)
            divisor = divisor.toUnsigned();
        if (divisor.gt(this))
            return UZERO;
        if (divisor.gt(this.shru(1))) // 15 >>> 1 = 7 ; with divisor = 8 ; true
            return UONE;
        res = UZERO;
    }

    // Repeat the following until the remainder is less than other:  find a
    // floating-point that approximates remainder / other *from below*, add this
    // into the result, and subtract it from the remainder.  It is critical that
    // the approximate value is less than or equal to the real value so that the
    // remainder never becomes negative.
    rem = this;
    while (rem.gte(divisor)) {
        // Approximate the result of division. This may be a little greater or
        // smaller than the actual value.
        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));

        // We will tweak the approximate result by changing it in the 48-th digit or
        // the smallest non-fractional digit, whichever is larger.
        var log2 = Math.ceil(Math.log(approx) / Math.LN2),
            delta = (log2 <= 48) ? 1 : pow_dbl(2, log2 - 48),

        // Decrease the approximation until it is smaller than the remainder.  Note
        // that if it is too large, the product overflows and is negative.
            approxRes = fromNumber(approx),
            approxRem = approxRes.mul(divisor);
        while (approxRem.isNegative() || approxRem.gt(rem)) {
            approx -= delta;
            approxRes = fromNumber(approx, this.unsigned);
            approxRem = approxRes.mul(divisor);
        }

        // We know the answer can't be zero... and actually, zero would cause
        // infinite recursion since we would make no progress.
        if (approxRes.isZero())
            approxRes = ONE;

        res = res.add(approxRes);
        rem = rem.sub(approxRem);
    }
    return res;
};

/**
 * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Quotient
 */
LongPrototype.div = LongPrototype.divide;

/**
 * Returns this Long modulo the specified.
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.modulo = function modulo(divisor) {
    if (!isLong(divisor))
        divisor = fromValue(divisor);

    // use wasm support if present
    if (wasm) {
        var low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(
            this.low,
            this.high,
            divisor.low,
            divisor.high
        );
        return fromBits(low, wasm.get_high(), this.unsigned);
    }

    return this.sub(this.div(divisor).mul(divisor));
};

/**
 * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.mod = LongPrototype.modulo;

/**
 * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.rem = LongPrototype.modulo;

/**
 * Returns the bitwise NOT of this Long.
 * @returns {!Long}
 */
LongPrototype.not = function not() {
    return fromBits(~this.low, ~this.high, this.unsigned);
};

/**
 * Returns the bitwise AND of this Long and the specified.
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.and = function and(other) {
    if (!isLong(other))
        other = fromValue(other);
    return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
};

/**
 * Returns the bitwise OR of this Long and the specified.
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.or = function or(other) {
    if (!isLong(other))
        other = fromValue(other);
    return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
};

/**
 * Returns the bitwise XOR of this Long and the given one.
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.xor = function xor(other) {
    if (!isLong(other))
        other = fromValue(other);
    return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
};

/**
 * Returns this Long with bits shifted to the left by the given amount.
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftLeft = function shiftLeft(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
        return this;
    else if (numBits < 32)
        return fromBits(this.low << numBits, (this.high << numBits) | (this.low >>> (32 - numBits)), this.unsigned);
    else
        return fromBits(0, this.low << (numBits - 32), this.unsigned);
};

/**
 * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shl = LongPrototype.shiftLeft;

/**
 * Returns this Long with bits arithmetically shifted to the right by the given amount.
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftRight = function shiftRight(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
        return this;
    else if (numBits < 32)
        return fromBits((this.low >>> numBits) | (this.high << (32 - numBits)), this.high >> numBits, this.unsigned);
    else
        return fromBits(this.high >> (numBits - 32), this.high >= 0 ? 0 : -1, this.unsigned);
};

/**
 * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shr = LongPrototype.shiftRight;

/**
 * Returns this Long with bits logically shifted to the right by the given amount.
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    numBits &= 63;
    if (numBits === 0)
        return this;
    else {
        var high = this.high;
        if (numBits < 32) {
            var low = this.low;
            return fromBits((low >>> numBits) | (high << (32 - numBits)), high >>> numBits, this.unsigned);
        } else if (numBits === 32)
            return fromBits(high, 0, this.unsigned);
        else
            return fromBits(high >>> (numBits - 32), 0, this.unsigned);
    }
};

/**
 * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shru = LongPrototype.shiftRightUnsigned;

/**
 * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;

/**
 * Converts this Long to signed.
 * @returns {!Long} Signed long
 */
LongPrototype.toSigned = function toSigned() {
    if (!this.unsigned)
        return this;
    return fromBits(this.low, this.high, false);
};

/**
 * Converts this Long to unsigned.
 * @returns {!Long} Unsigned long
 */
LongPrototype.toUnsigned = function toUnsigned() {
    if (this.unsigned)
        return this;
    return fromBits(this.low, this.high, true);
};

/**
 * Converts this Long to its byte representation.
 * @param {boolean=} le Whether little or big endian, defaults to big endian
 * @returns {!Array.<number>} Byte representation
 */
LongPrototype.toBytes = function toBytes(le) {
    return le ? this.toBytesLE() : this.toBytesBE();
};

/**
 * Converts this Long to its little endian byte representation.
 * @returns {!Array.<number>} Little endian byte representation
 */
LongPrototype.toBytesLE = function toBytesLE() {
    var hi = this.high,
        lo = this.low;
    return [
        lo        & 0xff,
        lo >>>  8 & 0xff,
        lo >>> 16 & 0xff,
        lo >>> 24       ,
        hi        & 0xff,
        hi >>>  8 & 0xff,
        hi >>> 16 & 0xff,
        hi >>> 24
    ];
};

/**
 * Converts this Long to its big endian byte representation.
 * @returns {!Array.<number>} Big endian byte representation
 */
LongPrototype.toBytesBE = function toBytesBE() {
    var hi = this.high,
        lo = this.low;
    return [
        hi >>> 24       ,
        hi >>> 16 & 0xff,
        hi >>>  8 & 0xff,
        hi        & 0xff,
        lo >>> 24       ,
        lo >>> 16 & 0xff,
        lo >>>  8 & 0xff,
        lo        & 0xff
    ];
};

/**
 * Creates a Long from its byte representation.
 * @param {!Array.<number>} bytes Byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @param {boolean=} le Whether little or big endian, defaults to big endian
 * @returns {Long} The corresponding Long value
 */
Long.fromBytes = function fromBytes(bytes, unsigned, le) {
    return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);
};

/**
 * Creates a Long from its little endian byte representation.
 * @param {!Array.<number>} bytes Little endian byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {Long} The corresponding Long value
 */
Long.fromBytesLE = function fromBytesLE(bytes, unsigned) {
    return new Long(
        bytes[0]       |
        bytes[1] <<  8 |
        bytes[2] << 16 |
        bytes[3] << 24,
        bytes[4]       |
        bytes[5] <<  8 |
        bytes[6] << 16 |
        bytes[7] << 24,
        unsigned
    );
};

/**
 * Creates a Long from its big endian byte representation.
 * @param {!Array.<number>} bytes Big endian byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {Long} The corresponding Long value
 */
Long.fromBytesBE = function fromBytesBE(bytes, unsigned) {
    return new Long(
        bytes[4] << 24 |
        bytes[5] << 16 |
        bytes[6] <<  8 |
        bytes[7],
        bytes[0] << 24 |
        bytes[1] << 16 |
        bytes[2] <<  8 |
        bytes[3],
        unsigned
    );
};

},{}],44:[function(require,module,exports){
'use strict'
var inherits = require('inherits')
var HashBase = require('hash-base')
var Buffer = require('safe-buffer').Buffer

var ARRAY16 = new Array(16)

function MD5 () {
  HashBase.call(this, 64)

  // state
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
}

inherits(MD5, HashBase)

MD5.prototype._update = function () {
  var M = ARRAY16
  for (var i = 0; i < 16; ++i) M[i] = this._block.readInt32LE(i * 4)

  var a = this._a
  var b = this._b
  var c = this._c
  var d = this._d

  a = fnF(a, b, c, d, M[0], 0xd76aa478, 7)
  d = fnF(d, a, b, c, M[1], 0xe8c7b756, 12)
  c = fnF(c, d, a, b, M[2], 0x242070db, 17)
  b = fnF(b, c, d, a, M[3], 0xc1bdceee, 22)
  a = fnF(a, b, c, d, M[4], 0xf57c0faf, 7)
  d = fnF(d, a, b, c, M[5], 0x4787c62a, 12)
  c = fnF(c, d, a, b, M[6], 0xa8304613, 17)
  b = fnF(b, c, d, a, M[7], 0xfd469501, 22)
  a = fnF(a, b, c, d, M[8], 0x698098d8, 7)
  d = fnF(d, a, b, c, M[9], 0x8b44f7af, 12)
  c = fnF(c, d, a, b, M[10], 0xffff5bb1, 17)
  b = fnF(b, c, d, a, M[11], 0x895cd7be, 22)
  a = fnF(a, b, c, d, M[12], 0x6b901122, 7)
  d = fnF(d, a, b, c, M[13], 0xfd987193, 12)
  c = fnF(c, d, a, b, M[14], 0xa679438e, 17)
  b = fnF(b, c, d, a, M[15], 0x49b40821, 22)

  a = fnG(a, b, c, d, M[1], 0xf61e2562, 5)
  d = fnG(d, a, b, c, M[6], 0xc040b340, 9)
  c = fnG(c, d, a, b, M[11], 0x265e5a51, 14)
  b = fnG(b, c, d, a, M[0], 0xe9b6c7aa, 20)
  a = fnG(a, b, c, d, M[5], 0xd62f105d, 5)
  d = fnG(d, a, b, c, M[10], 0x02441453, 9)
  c = fnG(c, d, a, b, M[15], 0xd8a1e681, 14)
  b = fnG(b, c, d, a, M[4], 0xe7d3fbc8, 20)
  a = fnG(a, b, c, d, M[9], 0x21e1cde6, 5)
  d = fnG(d, a, b, c, M[14], 0xc33707d6, 9)
  c = fnG(c, d, a, b, M[3], 0xf4d50d87, 14)
  b = fnG(b, c, d, a, M[8], 0x455a14ed, 20)
  a = fnG(a, b, c, d, M[13], 0xa9e3e905, 5)
  d = fnG(d, a, b, c, M[2], 0xfcefa3f8, 9)
  c = fnG(c, d, a, b, M[7], 0x676f02d9, 14)
  b = fnG(b, c, d, a, M[12], 0x8d2a4c8a, 20)

  a = fnH(a, b, c, d, M[5], 0xfffa3942, 4)
  d = fnH(d, a, b, c, M[8], 0x8771f681, 11)
  c = fnH(c, d, a, b, M[11], 0x6d9d6122, 16)
  b = fnH(b, c, d, a, M[14], 0xfde5380c, 23)
  a = fnH(a, b, c, d, M[1], 0xa4beea44, 4)
  d = fnH(d, a, b, c, M[4], 0x4bdecfa9, 11)
  c = fnH(c, d, a, b, M[7], 0xf6bb4b60, 16)
  b = fnH(b, c, d, a, M[10], 0xbebfbc70, 23)
  a = fnH(a, b, c, d, M[13], 0x289b7ec6, 4)
  d = fnH(d, a, b, c, M[0], 0xeaa127fa, 11)
  c = fnH(c, d, a, b, M[3], 0xd4ef3085, 16)
  b = fnH(b, c, d, a, M[6], 0x04881d05, 23)
  a = fnH(a, b, c, d, M[9], 0xd9d4d039, 4)
  d = fnH(d, a, b, c, M[12], 0xe6db99e5, 11)
  c = fnH(c, d, a, b, M[15], 0x1fa27cf8, 16)
  b = fnH(b, c, d, a, M[2], 0xc4ac5665, 23)

  a = fnI(a, b, c, d, M[0], 0xf4292244, 6)
  d = fnI(d, a, b, c, M[7], 0x432aff97, 10)
  c = fnI(c, d, a, b, M[14], 0xab9423a7, 15)
  b = fnI(b, c, d, a, M[5], 0xfc93a039, 21)
  a = fnI(a, b, c, d, M[12], 0x655b59c3, 6)
  d = fnI(d, a, b, c, M[3], 0x8f0ccc92, 10)
  c = fnI(c, d, a, b, M[10], 0xffeff47d, 15)
  b = fnI(b, c, d, a, M[1], 0x85845dd1, 21)
  a = fnI(a, b, c, d, M[8], 0x6fa87e4f, 6)
  d = fnI(d, a, b, c, M[15], 0xfe2ce6e0, 10)
  c = fnI(c, d, a, b, M[6], 0xa3014314, 15)
  b = fnI(b, c, d, a, M[13], 0x4e0811a1, 21)
  a = fnI(a, b, c, d, M[4], 0xf7537e82, 6)
  d = fnI(d, a, b, c, M[11], 0xbd3af235, 10)
  c = fnI(c, d, a, b, M[2], 0x2ad7d2bb, 15)
  b = fnI(b, c, d, a, M[9], 0xeb86d391, 21)

  this._a = (this._a + a) | 0
  this._b = (this._b + b) | 0
  this._c = (this._c + c) | 0
  this._d = (this._d + d) | 0
}

MD5.prototype._digest = function () {
  // create padding and handle blocks
  this._block[this._blockOffset++] = 0x80
  if (this._blockOffset > 56) {
    this._block.fill(0, this._blockOffset, 64)
    this._update()
    this._blockOffset = 0
  }

  this._block.fill(0, this._blockOffset, 56)
  this._block.writeUInt32LE(this._length[0], 56)
  this._block.writeUInt32LE(this._length[1], 60)
  this._update()

  // produce result
  var buffer = Buffer.allocUnsafe(16)
  buffer.writeInt32LE(this._a, 0)
  buffer.writeInt32LE(this._b, 4)
  buffer.writeInt32LE(this._c, 8)
  buffer.writeInt32LE(this._d, 12)
  return buffer
}

function rotl (x, n) {
  return (x << n) | (x >>> (32 - n))
}

function fnF (a, b, c, d, m, k, s) {
  return (rotl((a + ((b & c) | ((~b) & d)) + m + k) | 0, s) + b) | 0
}

function fnG (a, b, c, d, m, k, s) {
  return (rotl((a + ((b & d) | (c & (~d))) + m + k) | 0, s) + b) | 0
}

function fnH (a, b, c, d, m, k, s) {
  return (rotl((a + (b ^ c ^ d) + m + k) | 0, s) + b) | 0
}

function fnI (a, b, c, d, m, k, s) {
  return (rotl((a + ((c ^ (b | (~d)))) + m + k) | 0, s) + b) | 0
}

module.exports = MD5

},{"hash-base":41,"inherits":42,"safe-buffer":62}],45:[function(require,module,exports){
(function (process,global){(function (){
'use strict'

// limit of Crypto.getRandomValues()
// https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues
var MAX_BYTES = 65536

// Node supports requesting up to this number of bytes
// https://github.com/nodejs/node/blob/master/lib/internal/crypto/random.js#L48
var MAX_UINT32 = 4294967295

function oldBrowser () {
  throw new Error('Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11')
}

var Buffer = require('safe-buffer').Buffer
var crypto = global.crypto || global.msCrypto

if (crypto && crypto.getRandomValues) {
  module.exports = randomBytes
} else {
  module.exports = oldBrowser
}

function randomBytes (size, cb) {
  // phantomjs needs to throw
  if (size > MAX_UINT32) throw new RangeError('requested too many random bytes')

  var bytes = Buffer.allocUnsafe(size)

  if (size > 0) {  // getRandomValues fails on IE if size == 0
    if (size > MAX_BYTES) { // this is the max bytes crypto.getRandomValues
      // can do at once see https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues
      for (var generated = 0; generated < size; generated += MAX_BYTES) {
        // buffer.slice automatically checks if the end is past the end of
        // the buffer so we don't have to here
        crypto.getRandomValues(bytes.slice(generated, generated + MAX_BYTES))
      }
    } else {
      crypto.getRandomValues(bytes)
    }
  }

  if (typeof cb === 'function') {
    return process.nextTick(function () {
      cb(null, bytes)
    })
  }

  return bytes
}

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"_process":116,"safe-buffer":62}],46:[function(require,module,exports){
'use strict';

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var codes = {};

function createErrorType(code, message, Base) {
  if (!Base) {
    Base = Error;
  }

  function getMessage(arg1, arg2, arg3) {
    if (typeof message === 'string') {
      return message;
    } else {
      return message(arg1, arg2, arg3);
    }
  }

  var NodeError =
  /*#__PURE__*/
  function (_Base) {
    _inheritsLoose(NodeError, _Base);

    function NodeError(arg1, arg2, arg3) {
      return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
    }

    return NodeError;
  }(Base);

  NodeError.prototype.name = Base.name;
  NodeError.prototype.code = code;
  codes[code] = NodeError;
} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js


function oneOf(expected, thing) {
  if (Array.isArray(expected)) {
    var len = expected.length;
    expected = expected.map(function (i) {
      return String(i);
    });

    if (len > 2) {
      return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
    } else if (len === 2) {
      return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
    } else {
      return "of ".concat(thing, " ").concat(expected[0]);
    }
  } else {
    return "of ".concat(thing, " ").concat(String(expected));
  }
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith


function startsWith(str, search, pos) {
  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith


function endsWith(str, search, this_len) {
  if (this_len === undefined || this_len > str.length) {
    this_len = str.length;
  }

  return str.substring(this_len - search.length, this_len) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes


function includes(str, search, start) {
  if (typeof start !== 'number') {
    start = 0;
  }

  if (start + search.length > str.length) {
    return false;
  } else {
    return str.indexOf(search, start) !== -1;
  }
}

createErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {
  return 'The value "' + value + '" is invalid for option "' + name + '"';
}, TypeError);
createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
  // determiner: 'must be' or 'must not be'
  var determiner;

  if (typeof expected === 'string' && startsWith(expected, 'not ')) {
    determiner = 'must not be';
    expected = expected.replace(/^not /, '');
  } else {
    determiner = 'must be';
  }

  var msg;

  if (endsWith(name, ' argument')) {
    // For cases like 'first argument'
    msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  } else {
    var type = includes(name, '.') ? 'property' : 'argument';
    msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  }

  msg += ". Received type ".concat(typeof actual);
  return msg;
}, TypeError);
createErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');
createErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {
  return 'The ' + name + ' method is not implemented';
});
createErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');
createErrorType('ERR_STREAM_DESTROYED', function (name) {
  return 'Cannot call ' + name + ' after a stream was destroyed';
});
createErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');
createErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');
createErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');
createErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);
createErrorType('ERR_UNKNOWN_ENCODING', function (arg) {
  return 'Unknown encoding: ' + arg;
}, TypeError);
createErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');
module.exports.codes = codes;

},{}],47:[function(require,module,exports){
(function (process){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.
'use strict';
/*<replacement>*/

var objectKeys = Object.keys || function (obj) {
  var keys = [];

  for (var key in obj) {
    keys.push(key);
  }

  return keys;
};
/*</replacement>*/


module.exports = Duplex;

var Readable = require('./_stream_readable');

var Writable = require('./_stream_writable');

require('inherits')(Duplex, Readable);

{
  // Allow the keys array to be GC'ed.
  var keys = objectKeys(Writable.prototype);

  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);
  Readable.call(this, options);
  Writable.call(this, options);
  this.allowHalfOpen = true;

  if (options) {
    if (options.readable === false) this.readable = false;
    if (options.writable === false) this.writable = false;

    if (options.allowHalfOpen === false) {
      this.allowHalfOpen = false;
      this.once('end', onend);
    }
  }
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
});
Object.defineProperty(Duplex.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});
Object.defineProperty(Duplex.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
}); // the no-half-open enforcer

function onend() {
  // If the writable side ended, then we're ok.
  if (this._writableState.ended) return; // no more data can be written.
  // But allow more writes to happen in this tick.

  process.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }

    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});
}).call(this)}).call(this,require('_process'))
},{"./_stream_readable":49,"./_stream_writable":51,"_process":116,"inherits":42}],48:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.
'use strict';

module.exports = PassThrough;

var Transform = require('./_stream_transform');

require('inherits')(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);
  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
},{"./_stream_transform":50,"inherits":42}],49:[function(require,module,exports){
(function (process,global){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
'use strict';

module.exports = Readable;
/*<replacement>*/

var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;
/*<replacement>*/

var EE = require('events').EventEmitter;

var EElistenerCount = function EElistenerCount(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/


var Stream = require('./internal/streams/stream');
/*</replacement>*/


var Buffer = require('buffer').Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*<replacement>*/


var debugUtil = require('util');

var debug;

if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function debug() {};
}
/*</replacement>*/


var BufferList = require('./internal/streams/buffer_list');

var destroyImpl = require('./internal/streams/destroy');

var _require = require('./internal/streams/state'),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = require('../errors').codes,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT; // Lazy loaded to improve the startup performance.


var StringDecoder;
var createReadableStreamAsyncIterator;
var from;

require('inherits')(Readable, Stream);

var errorOrDestroy = destroyImpl.errorOrDestroy;
var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.

  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream, isDuplex) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"

  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex); // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()

  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.

  this.sync = true; // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.

  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.paused = true; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'end' (and potentially 'finish')

  this.autoDestroy = !!options.autoDestroy; // has it been destroyed

  this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s

  this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled

  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;

  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');
  if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside
  // the ReadableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  this._readableState = new ReadableState(options, this, isDuplex); // legacy

  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined) {
      return false;
    }

    return this._readableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
  }
});
Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;

Readable.prototype._destroy = function (err, cb) {
  cb(err);
}; // Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.


Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;

      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }

      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
}; // Unshift should *always* be something directly out of read()


Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  debug('readableAddChunk', chunk);
  var state = stream._readableState;

  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);

    if (er) {
      errorOrDestroy(stream, er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
      } else if (state.destroyed) {
        return false;
      } else {
        state.reading = false;

        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
      maybeReadMore(stream, state);
    }
  } // We can push more data if we are below the highWaterMark.
  // Also, if we have no data yet, we can stand some more bytes.
  // This is to work around cases where hwm=0, such as the repl.


  return !state.ended && (state.length < state.highWaterMark || state.length === 0);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    state.awaitDrain = 0;
    stream.emit('data', chunk);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
    if (state.needReadable) emitReadable(stream);
  }

  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;

  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);
  }

  return er;
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
}; // backwards compatibility.


Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  var decoder = new StringDecoder(enc);
  this._readableState.decoder = decoder; // If setEncoding(null), decoder.encoding equals utf8

  this._readableState.encoding = this._readableState.decoder.encoding; // Iterate over current buffer to convert already stored Buffers:

  var p = this._readableState.buffer.head;
  var content = '';

  while (p !== null) {
    content += decoder.write(p.data);
    p = p.next;
  }

  this._readableState.buffer.clear();

  if (content !== '') this._readableState.buffer.push(content);
  this._readableState.length = content.length;
  return this;
}; // Don't raise the hwm > 1GB


var MAX_HWM = 0x40000000;

function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }

  return n;
} // This function is designed to be inlinable, so please take care when making
// changes to the function body.


function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;

  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  } // If we're asking for more than the current hwm, then raise the hwm.


  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n; // Don't have enough

  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }

  return state.length;
} // you can override either this method, or the async _read(n) below.


Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;
  if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.

  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.

  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  } // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.
  // if we need a readable event, then we need to do some reading.


  var doRead = state.needReadable;
  debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some

  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  } // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.


  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true; // if the length is currently zero, then we *need* a readable event.

    if (state.length === 0) state.needReadable = true; // call internal read method

    this._read(state.highWaterMark);

    state.sync = false; // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.

    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = state.length <= state.highWaterMark;
    n = 0;
  } else {
    state.length -= n;
    state.awaitDrain = 0;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.

    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);
  return ret;
};

function onEofChunk(stream, state) {
  debug('onEofChunk');
  if (state.ended) return;

  if (state.decoder) {
    var chunk = state.decoder.end();

    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }

  state.ended = true;

  if (state.sync) {
    // if we are sync, wait until next tick to emit the data.
    // Otherwise we risk emitting data in the flow()
    // the readable code triggers during a read() call
    emitReadable(stream);
  } else {
    // emit 'readable' now to make sure it gets picked up.
    state.needReadable = false;

    if (!state.emittedReadable) {
      state.emittedReadable = true;
      emitReadable_(stream);
    }
  }
} // Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.


function emitReadable(stream) {
  var state = stream._readableState;
  debug('emitReadable', state.needReadable, state.emittedReadable);
  state.needReadable = false;

  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    process.nextTick(emitReadable_, stream);
  }
}

function emitReadable_(stream) {
  var state = stream._readableState;
  debug('emitReadable_', state.destroyed, state.length, state.ended);

  if (!state.destroyed && (state.length || state.ended)) {
    stream.emit('readable');
    state.emittedReadable = false;
  } // The stream needs another readable event if
  // 1. It is not flowing, as the flow mechanism will take
  //    care of it.
  // 2. It is not ended.
  // 3. It is below the highWaterMark, so we can schedule
  //    another readable later.


  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
  flow(stream);
} // at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.


function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  // Attempt to read more data if we should.
  //
  // The conditions for reading more data are (one of):
  // - Not enough data buffered (state.length < state.highWaterMark). The loop
  //   is responsible for filling the buffer with enough data if such data
  //   is available. If highWaterMark is 0 and we are not in the flowing mode
  //   we should _not_ attempt to buffer any extra data. We'll get more data
  //   when the stream consumer calls read() instead.
  // - No data in the buffer, and the stream is in flowing mode. In this mode
  //   the loop below is responsible for ensuring read() is called. Failing to
  //   call read here would abort the flow and there's no other mechanism for
  //   continuing the flow if the stream consumer has just subscribed to the
  //   'data' event.
  //
  // In addition to the above conditions to keep reading data, the following
  // conditions prevent the data from being read:
  // - The stream has ended (state.ended).
  // - There is already a pending 'read' operation (state.reading). This is a
  //   case where the the stream has called the implementation defined _read()
  //   method, but they are processing the call asynchronously and have _not_
  //   called push() with new data. In this case we skip performing more
  //   read()s. The execution ends in this method again after the _read() ends
  //   up calling push() with more data.
  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
    var len = state.length;
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length) // didn't get any data, stop spinning.
      break;
  }

  state.readingMore = false;
} // abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.


Readable.prototype._read = function (n) {
  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;

    case 1:
      state.pipes = [state.pipes, dest];
      break;

    default:
      state.pipes.push(dest);
      break;
  }

  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);
  dest.on('unpipe', onunpipe);

  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');

    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  } // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.


  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);
  var cleanedUp = false;

  function cleanup() {
    debug('cleanup'); // cleanup event handlers once the pipe is broken

    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);
    cleanedUp = true; // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.

    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  src.on('data', ondata);

  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);
    debug('dest.write', ret);

    if (ret === false) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', state.awaitDrain);
        state.awaitDrain++;
      }

      src.pause();
    }
  } // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.


  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);
  } // Make sure our error handler is attached before userland ones.


  prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.

  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }

  dest.once('close', onclose);

  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }

  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  } // tell the dest that it's being piped to


  dest.emit('pipe', src); // start the flow if it hasn't been started already.

  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function pipeOnDrainFunctionResult() {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;

    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = {
    hasUnpiped: false
  }; // if we're not piping anywhere, then do nothing.

  if (state.pipesCount === 0) return this; // just one destination.  most common case.

  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;
    if (!dest) dest = state.pipes; // got a match.

    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  } // slow case. multiple pipe destinations.


  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, {
        hasUnpiped: false
      });
    }

    return this;
  } // try to find the right one.


  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;
  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];
  dest.emit('unpipe', this, unpipeInfo);
  return this;
}; // set up data events if they are asked for
// Ensure readable listeners eventually get something


Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);
  var state = this._readableState;

  if (ev === 'data') {
    // update readableListening so that resume() may be a no-op
    // a few lines down. This is needed to support once('readable').
    state.readableListening = this.listenerCount('readable') > 0; // Try start flowing on next tick if stream isn't explicitly paused

    if (state.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.flowing = false;
      state.emittedReadable = false;
      debug('on readable', state.length, state.reading);

      if (state.length) {
        emitReadable(this);
      } else if (!state.reading) {
        process.nextTick(nReadingNextTick, this);
      }
    }
  }

  return res;
};

Readable.prototype.addListener = Readable.prototype.on;

Readable.prototype.removeListener = function (ev, fn) {
  var res = Stream.prototype.removeListener.call(this, ev, fn);

  if (ev === 'readable') {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

Readable.prototype.removeAllListeners = function (ev) {
  var res = Stream.prototype.removeAllListeners.apply(this, arguments);

  if (ev === 'readable' || ev === undefined) {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

function updateReadableListening(self) {
  var state = self._readableState;
  state.readableListening = self.listenerCount('readable') > 0;

  if (state.resumeScheduled && !state.paused) {
    // flowing needs to be set to true now, otherwise
    // the upcoming resume will not flow.
    state.flowing = true; // crude way to check if we should resume
  } else if (self.listenerCount('data') > 0) {
    self.resume();
  }
}

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
} // pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.


Readable.prototype.resume = function () {
  var state = this._readableState;

  if (!state.flowing) {
    debug('resume'); // we flow only if there is no one listening
    // for readable, but we still have to call
    // resume()

    state.flowing = !state.readableListening;
    resume(this, state);
  }

  state.paused = false;
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    process.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  debug('resume', state.reading);

  if (!state.reading) {
    stream.read(0);
  }

  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);

  if (this._readableState.flowing !== false) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }

  this._readableState.paused = true;
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);

  while (state.flowing && stream.read() !== null) {
    ;
  }
} // wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.


Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;
  stream.on('end', function () {
    debug('wrapped end');

    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });
  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode

    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);

    if (!ret) {
      paused = true;
      stream.pause();
    }
  }); // proxy all the other methods.
  // important when wrapping filters and duplexes.

  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function methodWrap(method) {
        return function methodWrapReturnFunction() {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  } // proxy certain important events.


  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  } // when we try to consume some more bytes, simply unpause the
  // underlying stream.


  this._read = function (n) {
    debug('wrapped _read', n);

    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

if (typeof Symbol === 'function') {
  Readable.prototype[Symbol.asyncIterator] = function () {
    if (createReadableStreamAsyncIterator === undefined) {
      createReadableStreamAsyncIterator = require('./internal/streams/async_iterator');
    }

    return createReadableStreamAsyncIterator(this);
  };
}

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.highWaterMark;
  }
});
Object.defineProperty(Readable.prototype, 'readableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState && this._readableState.buffer;
  }
});
Object.defineProperty(Readable.prototype, 'readableFlowing', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.flowing;
  },
  set: function set(state) {
    if (this._readableState) {
      this._readableState.flowing = state;
    }
  }
}); // exposed for testing purposes only.

Readable._fromList = fromList;
Object.defineProperty(Readable.prototype, 'readableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.length;
  }
}); // Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.

function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;
  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = state.buffer.consume(n, state.decoder);
  }
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;
  debug('endReadable', state.endEmitted);

  if (!state.endEmitted) {
    state.ended = true;
    process.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  debug('endReadableNT', state.endEmitted, state.length); // Check that we didn't get one last unshift.

  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');

    if (state.autoDestroy) {
      // In case of duplex streams we need a way to detect
      // if the writable side is ready for autoDestroy as well
      var wState = stream._writableState;

      if (!wState || wState.autoDestroy && wState.finished) {
        stream.destroy();
      }
    }
  }
}

if (typeof Symbol === 'function') {
  Readable.from = function (iterable, opts) {
    if (from === undefined) {
      from = require('./internal/streams/from');
    }

    return from(Readable, iterable, opts);
  };
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }

  return -1;
}
}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../errors":46,"./_stream_duplex":47,"./internal/streams/async_iterator":52,"./internal/streams/buffer_list":53,"./internal/streams/destroy":54,"./internal/streams/from":56,"./internal/streams/state":58,"./internal/streams/stream":59,"_process":116,"buffer":110,"events":111,"inherits":42,"string_decoder/":71,"util":109}],50:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.
'use strict';

module.exports = Transform;

var _require$codes = require('../errors').codes,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,
    ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;

var Duplex = require('./_stream_duplex');

require('inherits')(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;
  var cb = ts.writecb;

  if (cb === null) {
    return this.emit('error', new ERR_MULTIPLE_CALLBACK());
  }

  ts.writechunk = null;
  ts.writecb = null;
  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);
  cb(er);
  var rs = this._readableState;
  rs.reading = false;

  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);
  Duplex.call(this, options);
  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }; // start out asking for a readable event once data is transformed.

  this._readableState.needReadable = true; // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.

  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;
    if (typeof options.flush === 'function') this._flush = options.flush;
  } // When the writable side finishes, then flush out anything remaining.


  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function' && !this._readableState.destroyed) {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
}; // This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.


Transform.prototype._transform = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;

  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
}; // Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.


Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && !ts.transforming) {
    ts.transforming = true;

    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);
  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data); // TODO(BridgeAR): Write a test for these two error cases
  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided

  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
  return stream.push(null);
}
},{"../errors":46,"./_stream_duplex":47,"inherits":42}],51:[function(require,module,exports){
(function (process,global){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.
'use strict';

module.exports = Writable;
/* <replacement> */

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
} // It seems a linked list but it is not
// there will be only 2 of these for each stream


function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;

  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/


var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;
/*<replacement>*/

var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/

var Stream = require('./internal/streams/stream');
/*</replacement>*/


var Buffer = require('buffer').Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

var destroyImpl = require('./internal/streams/destroy');

var _require = require('./internal/streams/state'),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = require('../errors').codes,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,
    ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,
    ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,
    ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;

var errorOrDestroy = destroyImpl.errorOrDestroy;

require('inherits')(Writable, Stream);

function nop() {}

function WritableState(options, stream, isDuplex) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream,
  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream
  // contains buffers or objects.

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()

  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex); // if _final has been called

  this.finalCalled = false; // drain event flag.

  this.needDrain = false; // at the start of calling end()

  this.ending = false; // when end() has been called, and returned

  this.ended = false; // when 'finish' is emitted

  this.finished = false; // has it been destroyed

  this.destroyed = false; // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.

  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.

  this.length = 0; // a flag to see when we're in the middle of a write.

  this.writing = false; // when true all writes will be buffered until .uncork() call

  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.

  this.sync = true; // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.

  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)

  this.onwrite = function (er) {
    onwrite(stream, er);
  }; // the callback that the user supplies to write(chunk,encoding,cb)


  this.writecb = null; // the amount that is being written when _write is called.

  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null; // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted

  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams

  this.prefinished = false; // True if the error was already emitted and should not be thrown again

  this.errorEmitted = false; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'finish' (and potentially 'end')

  this.autoDestroy = !!options.autoDestroy; // count buffered requests

  this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two

  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];

  while (current) {
    out.push(current);
    current = current.next;
  }

  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function writableStateBufferGetter() {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})(); // Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.


var realHasInstance;

if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function value(object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;
      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function realHasInstance(object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex'); // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.
  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  // Checking for a Stream.Duplex instance is faster here instead of inside
  // the WritableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
  this._writableState = new WritableState(options, this, isDuplex); // legacy.

  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;
    if (typeof options.writev === 'function') this._writev = options.writev;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
} // Otherwise people can pipe Writable streams, which is just wrong.


Writable.prototype.pipe = function () {
  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
};

function writeAfterEnd(stream, cb) {
  var er = new ERR_STREAM_WRITE_AFTER_END(); // TODO: defer error events consistently everywhere, not just the cb

  errorOrDestroy(stream, er);
  process.nextTick(cb, er);
} // Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.


function validChunk(stream, state, chunk, cb) {
  var er;

  if (chunk === null) {
    er = new ERR_STREAM_NULL_VALUES();
  } else if (typeof chunk !== 'string' && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);
  }

  if (er) {
    errorOrDestroy(stream, er);
    process.nextTick(cb, er);
    return false;
  }

  return true;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
  if (typeof cb !== 'function') cb = nop;
  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }
  return ret;
};

Writable.prototype.cork = function () {
  this._writableState.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;
    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

Object.defineProperty(Writable.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }

  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
}); // if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.

function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);

    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }

  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.

  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };

    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }

    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    process.nextTick(cb, er); // this can emit finish, and it will always happen
    // after error

    process.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er); // this can emit finish, but finish must
    // always follow error

    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();
  onwriteStateUpdate(state);
  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state) || stream.destroyed;

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      process.nextTick(afterWrite, stream, state, finished, cb);
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
} // Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.


function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
} // if there's something in the buffer waiting, then process it


function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    var allBuffers = true;

    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }

    buffer.allBuffers = allBuffers;
    doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite

    state.pendingcb++;
    state.lastBufferedRequest = null;

    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }

    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.

      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks

  if (state.corked) {
    state.corked = 1;
    this.uncork();
  } // ignore unnecessary end() calls.


  if (!state.ending) endWritable(this, state, cb);
  return this;
};

Object.defineProperty(Writable.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
});

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}

function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;

    if (err) {
      errorOrDestroy(stream, err);
    }

    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}

function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function' && !state.destroyed) {
      state.pendingcb++;
      state.finalCalled = true;
      process.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);

  if (need) {
    prefinish(stream, state);

    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');

      if (state.autoDestroy) {
        // In case of duplex streams we need a way to detect
        // if the readable side is ready for autoDestroy as well
        var rState = stream._readableState;

        if (!rState || rState.autoDestroy && rState.endEmitted) {
          stream.destroy();
        }
      }
    }
  }

  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);

  if (cb) {
    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);
  }

  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;

  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  } // reuse the free corkReq.


  state.corkedRequestsFree.next = corkReq;
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._writableState === undefined) {
      return false;
    }

    return this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._writableState.destroyed = value;
  }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;

Writable.prototype._destroy = function (err, cb) {
  cb(err);
};
}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../errors":46,"./_stream_duplex":47,"./internal/streams/destroy":54,"./internal/streams/state":58,"./internal/streams/stream":59,"_process":116,"buffer":110,"inherits":42,"util-deprecate":76}],52:[function(require,module,exports){
(function (process){(function (){
'use strict';

var _Object$setPrototypeO;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var finished = require('./end-of-stream');

var kLastResolve = Symbol('lastResolve');
var kLastReject = Symbol('lastReject');
var kError = Symbol('error');
var kEnded = Symbol('ended');
var kLastPromise = Symbol('lastPromise');
var kHandlePromise = Symbol('handlePromise');
var kStream = Symbol('stream');

function createIterResult(value, done) {
  return {
    value: value,
    done: done
  };
}

function readAndResolve(iter) {
  var resolve = iter[kLastResolve];

  if (resolve !== null) {
    var data = iter[kStream].read(); // we defer if data is null
    // we can be expecting either 'end' or
    // 'error'

    if (data !== null) {
      iter[kLastPromise] = null;
      iter[kLastResolve] = null;
      iter[kLastReject] = null;
      resolve(createIterResult(data, false));
    }
  }
}

function onReadable(iter) {
  // we wait for the next tick, because it might
  // emit an error with process.nextTick
  process.nextTick(readAndResolve, iter);
}

function wrapForNext(lastPromise, iter) {
  return function (resolve, reject) {
    lastPromise.then(function () {
      if (iter[kEnded]) {
        resolve(createIterResult(undefined, true));
        return;
      }

      iter[kHandlePromise](resolve, reject);
    }, reject);
  };
}

var AsyncIteratorPrototype = Object.getPrototypeOf(function () {});
var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
  get stream() {
    return this[kStream];
  },

  next: function next() {
    var _this = this;

    // if we have detected an error in the meanwhile
    // reject straight away
    var error = this[kError];

    if (error !== null) {
      return Promise.reject(error);
    }

    if (this[kEnded]) {
      return Promise.resolve(createIterResult(undefined, true));
    }

    if (this[kStream].destroyed) {
      // We need to defer via nextTick because if .destroy(err) is
      // called, the error will be emitted via nextTick, and
      // we cannot guarantee that there is no error lingering around
      // waiting to be emitted.
      return new Promise(function (resolve, reject) {
        process.nextTick(function () {
          if (_this[kError]) {
            reject(_this[kError]);
          } else {
            resolve(createIterResult(undefined, true));
          }
        });
      });
    } // if we have multiple next() calls
    // we will wait for the previous Promise to finish
    // this logic is optimized to support for await loops,
    // where next() is only called once at a time


    var lastPromise = this[kLastPromise];
    var promise;

    if (lastPromise) {
      promise = new Promise(wrapForNext(lastPromise, this));
    } else {
      // fast path needed to support multiple this.push()
      // without triggering the next() queue
      var data = this[kStream].read();

      if (data !== null) {
        return Promise.resolve(createIterResult(data, false));
      }

      promise = new Promise(this[kHandlePromise]);
    }

    this[kLastPromise] = promise;
    return promise;
  }
}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {
  return this;
}), _defineProperty(_Object$setPrototypeO, "return", function _return() {
  var _this2 = this;

  // destroy(err, cb) is a private API
  // we can guarantee we have that here, because we control the
  // Readable class this is attached to
  return new Promise(function (resolve, reject) {
    _this2[kStream].destroy(null, function (err) {
      if (err) {
        reject(err);
        return;
      }

      resolve(createIterResult(undefined, true));
    });
  });
}), _Object$setPrototypeO), AsyncIteratorPrototype);

var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
  var _Object$create;

  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
    value: stream,
    writable: true
  }), _defineProperty(_Object$create, kLastResolve, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kLastReject, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kError, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kEnded, {
    value: stream._readableState.endEmitted,
    writable: true
  }), _defineProperty(_Object$create, kHandlePromise, {
    value: function value(resolve, reject) {
      var data = iterator[kStream].read();

      if (data) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve(createIterResult(data, false));
      } else {
        iterator[kLastResolve] = resolve;
        iterator[kLastReject] = reject;
      }
    },
    writable: true
  }), _Object$create));
  iterator[kLastPromise] = null;
  finished(stream, function (err) {
    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
      var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise
      // returned by next() and store the error

      if (reject !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        reject(err);
      }

      iterator[kError] = err;
      return;
    }

    var resolve = iterator[kLastResolve];

    if (resolve !== null) {
      iterator[kLastPromise] = null;
      iterator[kLastResolve] = null;
      iterator[kLastReject] = null;
      resolve(createIterResult(undefined, true));
    }

    iterator[kEnded] = true;
  });
  stream.on('readable', onReadable.bind(null, iterator));
  return iterator;
};

module.exports = createReadableStreamAsyncIterator;
}).call(this)}).call(this,require('_process'))
},{"./end-of-stream":55,"_process":116}],53:[function(require,module,exports){
'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var _require = require('buffer'),
    Buffer = _require.Buffer;

var _require2 = require('util'),
    inspect = _require2.inspect;

var custom = inspect && inspect.custom || 'inspect';

function copyBuffer(src, target, offset) {
  Buffer.prototype.copy.call(src, target, offset);
}

module.exports =
/*#__PURE__*/
function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  _createClass(BufferList, [{
    key: "push",
    value: function push(v) {
      var entry = {
        data: v,
        next: null
      };
      if (this.length > 0) this.tail.next = entry;else this.head = entry;
      this.tail = entry;
      ++this.length;
    }
  }, {
    key: "unshift",
    value: function unshift(v) {
      var entry = {
        data: v,
        next: this.head
      };
      if (this.length === 0) this.tail = entry;
      this.head = entry;
      ++this.length;
    }
  }, {
    key: "shift",
    value: function shift() {
      if (this.length === 0) return;
      var ret = this.head.data;
      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
      --this.length;
      return ret;
    }
  }, {
    key: "clear",
    value: function clear() {
      this.head = this.tail = null;
      this.length = 0;
    }
  }, {
    key: "join",
    value: function join(s) {
      if (this.length === 0) return '';
      var p = this.head;
      var ret = '' + p.data;

      while (p = p.next) {
        ret += s + p.data;
      }

      return ret;
    }
  }, {
    key: "concat",
    value: function concat(n) {
      if (this.length === 0) return Buffer.alloc(0);
      var ret = Buffer.allocUnsafe(n >>> 0);
      var p = this.head;
      var i = 0;

      while (p) {
        copyBuffer(p.data, ret, i);
        i += p.data.length;
        p = p.next;
      }

      return ret;
    } // Consumes a specified amount of bytes or characters from the buffered data.

  }, {
    key: "consume",
    value: function consume(n, hasStrings) {
      var ret;

      if (n < this.head.data.length) {
        // `slice` is the same for buffers and strings.
        ret = this.head.data.slice(0, n);
        this.head.data = this.head.data.slice(n);
      } else if (n === this.head.data.length) {
        // First chunk is a perfect match.
        ret = this.shift();
      } else {
        // Result spans more than one buffer.
        ret = hasStrings ? this._getString(n) : this._getBuffer(n);
      }

      return ret;
    }
  }, {
    key: "first",
    value: function first() {
      return this.head.data;
    } // Consumes a specified amount of characters from the buffered data.

  }, {
    key: "_getString",
    value: function _getString(n) {
      var p = this.head;
      var c = 1;
      var ret = p.data;
      n -= ret.length;

      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length) ret += str;else ret += str.slice(0, n);
        n -= nb;

        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = str.slice(nb);
          }

          break;
        }

        ++c;
      }

      this.length -= c;
      return ret;
    } // Consumes a specified amount of bytes from the buffered data.

  }, {
    key: "_getBuffer",
    value: function _getBuffer(n) {
      var ret = Buffer.allocUnsafe(n);
      var p = this.head;
      var c = 1;
      p.data.copy(ret);
      n -= p.data.length;

      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret, ret.length - n, 0, nb);
        n -= nb;

        if (n === 0) {
          if (nb === buf.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = buf.slice(nb);
          }

          break;
        }

        ++c;
      }

      this.length -= c;
      return ret;
    } // Make sure the linked list only shows the minimal necessary information.

  }, {
    key: custom,
    value: function value(_, options) {
      return inspect(this, _objectSpread({}, options, {
        // Only inspect one level.
        depth: 0,
        // It should not recurse.
        customInspect: false
      }));
    }
  }]);

  return BufferList;
}();
},{"buffer":110,"util":109}],54:[function(require,module,exports){
(function (process){(function (){
'use strict'; // undocumented cb() API, needed for core, not for public API

function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err) {
      if (!this._writableState) {
        process.nextTick(emitErrorNT, this, err);
      } else if (!this._writableState.errorEmitted) {
        this._writableState.errorEmitted = true;
        process.nextTick(emitErrorNT, this, err);
      }
    }

    return this;
  } // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks


  if (this._readableState) {
    this._readableState.destroyed = true;
  } // if this is a duplex stream mark the writable part as destroyed as well


  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      if (!_this._writableState) {
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else if (!_this._writableState.errorEmitted) {
        _this._writableState.errorEmitted = true;
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else {
        process.nextTick(emitCloseNT, _this);
      }
    } else if (cb) {
      process.nextTick(emitCloseNT, _this);
      cb(err);
    } else {
      process.nextTick(emitCloseNT, _this);
    }
  });

  return this;
}

function emitErrorAndCloseNT(self, err) {
  emitErrorNT(self, err);
  emitCloseNT(self);
}

function emitCloseNT(self) {
  if (self._writableState && !self._writableState.emitClose) return;
  if (self._readableState && !self._readableState.emitClose) return;
  self.emit('close');
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finalCalled = false;
    this._writableState.prefinished = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

function errorOrDestroy(stream, err) {
  // We have tests that rely on errors being emitted
  // in the same tick, so changing this is semver major.
  // For now when you opt-in to autoDestroy we allow
  // the error to be emitted nextTick. In a future
  // semver major update we should change the default to this.
  var rState = stream._readableState;
  var wState = stream._writableState;
  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy,
  errorOrDestroy: errorOrDestroy
};
}).call(this)}).call(this,require('_process'))
},{"_process":116}],55:[function(require,module,exports){
// Ported from https://github.com/mafintosh/end-of-stream with
// permission from the author, Mathias Buus (@mafintosh).
'use strict';

var ERR_STREAM_PREMATURE_CLOSE = require('../../../errors').codes.ERR_STREAM_PREMATURE_CLOSE;

function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    callback.apply(this, args);
  };
}

function noop() {}

function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}

function eos(stream, opts, callback) {
  if (typeof opts === 'function') return eos(stream, null, opts);
  if (!opts) opts = {};
  callback = once(callback || noop);
  var readable = opts.readable || opts.readable !== false && stream.readable;
  var writable = opts.writable || opts.writable !== false && stream.writable;

  var onlegacyfinish = function onlegacyfinish() {
    if (!stream.writable) onfinish();
  };

  var writableEnded = stream._writableState && stream._writableState.finished;

  var onfinish = function onfinish() {
    writable = false;
    writableEnded = true;
    if (!readable) callback.call(stream);
  };

  var readableEnded = stream._readableState && stream._readableState.endEmitted;

  var onend = function onend() {
    readable = false;
    readableEnded = true;
    if (!writable) callback.call(stream);
  };

  var onerror = function onerror(err) {
    callback.call(stream, err);
  };

  var onclose = function onclose() {
    var err;

    if (readable && !readableEnded) {
      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }

    if (writable && !writableEnded) {
      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }
  };

  var onrequest = function onrequest() {
    stream.req.on('finish', onfinish);
  };

  if (isRequest(stream)) {
    stream.on('complete', onfinish);
    stream.on('abort', onclose);
    if (stream.req) onrequest();else stream.on('request', onrequest);
  } else if (writable && !stream._writableState) {
    // legacy streams
    stream.on('end', onlegacyfinish);
    stream.on('close', onlegacyfinish);
  }

  stream.on('end', onend);
  stream.on('finish', onfinish);
  if (opts.error !== false) stream.on('error', onerror);
  stream.on('close', onclose);
  return function () {
    stream.removeListener('complete', onfinish);
    stream.removeListener('abort', onclose);
    stream.removeListener('request', onrequest);
    if (stream.req) stream.req.removeListener('finish', onfinish);
    stream.removeListener('end', onlegacyfinish);
    stream.removeListener('close', onlegacyfinish);
    stream.removeListener('finish', onfinish);
    stream.removeListener('end', onend);
    stream.removeListener('error', onerror);
    stream.removeListener('close', onclose);
  };
}

module.exports = eos;
},{"../../../errors":46}],56:[function(require,module,exports){
module.exports = function () {
  throw new Error('Readable.from is not available in the browser')
};

},{}],57:[function(require,module,exports){
// Ported from https://github.com/mafintosh/pump with
// permission from the author, Mathias Buus (@mafintosh).
'use strict';

var eos;

function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;
    callback.apply(void 0, arguments);
  };
}

var _require$codes = require('../../../errors').codes,
    ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;

function noop(err) {
  // Rethrow the error if it exists to avoid swallowing it
  if (err) throw err;
}

function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}

function destroyer(stream, reading, writing, callback) {
  callback = once(callback);
  var closed = false;
  stream.on('close', function () {
    closed = true;
  });
  if (eos === undefined) eos = require('./end-of-stream');
  eos(stream, {
    readable: reading,
    writable: writing
  }, function (err) {
    if (err) return callback(err);
    closed = true;
    callback();
  });
  var destroyed = false;
  return function (err) {
    if (closed) return;
    if (destroyed) return;
    destroyed = true; // request.destroy just do .end - .abort is what we want

    if (isRequest(stream)) return stream.abort();
    if (typeof stream.destroy === 'function') return stream.destroy();
    callback(err || new ERR_STREAM_DESTROYED('pipe'));
  };
}

function call(fn) {
  fn();
}

function pipe(from, to) {
  return from.pipe(to);
}

function popCallback(streams) {
  if (!streams.length) return noop;
  if (typeof streams[streams.length - 1] !== 'function') return noop;
  return streams.pop();
}

function pipeline() {
  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
    streams[_key] = arguments[_key];
  }

  var callback = popCallback(streams);
  if (Array.isArray(streams[0])) streams = streams[0];

  if (streams.length < 2) {
    throw new ERR_MISSING_ARGS('streams');
  }

  var error;
  var destroys = streams.map(function (stream, i) {
    var reading = i < streams.length - 1;
    var writing = i > 0;
    return destroyer(stream, reading, writing, function (err) {
      if (!error) error = err;
      if (err) destroys.forEach(call);
      if (reading) return;
      destroys.forEach(call);
      callback(error);
    });
  });
  return streams.reduce(pipe);
}

module.exports = pipeline;
},{"../../../errors":46,"./end-of-stream":55}],58:[function(require,module,exports){
'use strict';

var ERR_INVALID_OPT_VALUE = require('../../../errors').codes.ERR_INVALID_OPT_VALUE;

function highWaterMarkFrom(options, isDuplex, duplexKey) {
  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}

function getHighWaterMark(state, options, duplexKey, isDuplex) {
  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);

  if (hwm != null) {
    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
      var name = isDuplex ? duplexKey : 'highWaterMark';
      throw new ERR_INVALID_OPT_VALUE(name, hwm);
    }

    return Math.floor(hwm);
  } // Default value


  return state.objectMode ? 16 : 16 * 1024;
}

module.exports = {
  getHighWaterMark: getHighWaterMark
};
},{"../../../errors":46}],59:[function(require,module,exports){
module.exports = require('events').EventEmitter;

},{"events":111}],60:[function(require,module,exports){
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');
exports.finished = require('./lib/internal/streams/end-of-stream.js');
exports.pipeline = require('./lib/internal/streams/pipeline.js');

},{"./lib/_stream_duplex.js":47,"./lib/_stream_passthrough.js":48,"./lib/_stream_readable.js":49,"./lib/_stream_transform.js":50,"./lib/_stream_writable.js":51,"./lib/internal/streams/end-of-stream.js":55,"./lib/internal/streams/pipeline.js":57}],61:[function(require,module,exports){
'use strict'
var Buffer = require('buffer').Buffer
var inherits = require('inherits')
var HashBase = require('hash-base')

var ARRAY16 = new Array(16)

var zl = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
]

var zr = [
  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
]

var sl = [
  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
]

var sr = [
  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
]

var hl = [0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e]
var hr = [0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000]

function RIPEMD160 () {
  HashBase.call(this, 64)

  // state
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
  this._e = 0xc3d2e1f0
}

inherits(RIPEMD160, HashBase)

RIPEMD160.prototype._update = function () {
  var words = ARRAY16
  for (var j = 0; j < 16; ++j) words[j] = this._block.readInt32LE(j * 4)

  var al = this._a | 0
  var bl = this._b | 0
  var cl = this._c | 0
  var dl = this._d | 0
  var el = this._e | 0

  var ar = this._a | 0
  var br = this._b | 0
  var cr = this._c | 0
  var dr = this._d | 0
  var er = this._e | 0

  // computation
  for (var i = 0; i < 80; i += 1) {
    var tl
    var tr
    if (i < 16) {
      tl = fn1(al, bl, cl, dl, el, words[zl[i]], hl[0], sl[i])
      tr = fn5(ar, br, cr, dr, er, words[zr[i]], hr[0], sr[i])
    } else if (i < 32) {
      tl = fn2(al, bl, cl, dl, el, words[zl[i]], hl[1], sl[i])
      tr = fn4(ar, br, cr, dr, er, words[zr[i]], hr[1], sr[i])
    } else if (i < 48) {
      tl = fn3(al, bl, cl, dl, el, words[zl[i]], hl[2], sl[i])
      tr = fn3(ar, br, cr, dr, er, words[zr[i]], hr[2], sr[i])
    } else if (i < 64) {
      tl = fn4(al, bl, cl, dl, el, words[zl[i]], hl[3], sl[i])
      tr = fn2(ar, br, cr, dr, er, words[zr[i]], hr[3], sr[i])
    } else { // if (i<80) {
      tl = fn5(al, bl, cl, dl, el, words[zl[i]], hl[4], sl[i])
      tr = fn1(ar, br, cr, dr, er, words[zr[i]], hr[4], sr[i])
    }

    al = el
    el = dl
    dl = rotl(cl, 10)
    cl = bl
    bl = tl

    ar = er
    er = dr
    dr = rotl(cr, 10)
    cr = br
    br = tr
  }

  // update state
  var t = (this._b + cl + dr) | 0
  this._b = (this._c + dl + er) | 0
  this._c = (this._d + el + ar) | 0
  this._d = (this._e + al + br) | 0
  this._e = (this._a + bl + cr) | 0
  this._a = t
}

RIPEMD160.prototype._digest = function () {
  // create padding and handle blocks
  this._block[this._blockOffset++] = 0x80
  if (this._blockOffset > 56) {
    this._block.fill(0, this._blockOffset, 64)
    this._update()
    this._blockOffset = 0
  }

  this._block.fill(0, this._blockOffset, 56)
  this._block.writeUInt32LE(this._length[0], 56)
  this._block.writeUInt32LE(this._length[1], 60)
  this._update()

  // produce result
  var buffer = Buffer.alloc ? Buffer.alloc(20) : new Buffer(20)
  buffer.writeInt32LE(this._a, 0)
  buffer.writeInt32LE(this._b, 4)
  buffer.writeInt32LE(this._c, 8)
  buffer.writeInt32LE(this._d, 12)
  buffer.writeInt32LE(this._e, 16)
  return buffer
}

function rotl (x, n) {
  return (x << n) | (x >>> (32 - n))
}

function fn1 (a, b, c, d, e, m, k, s) {
  return (rotl((a + (b ^ c ^ d) + m + k) | 0, s) + e) | 0
}

function fn2 (a, b, c, d, e, m, k, s) {
  return (rotl((a + ((b & c) | ((~b) & d)) + m + k) | 0, s) + e) | 0
}

function fn3 (a, b, c, d, e, m, k, s) {
  return (rotl((a + ((b | (~c)) ^ d) + m + k) | 0, s) + e) | 0
}

function fn4 (a, b, c, d, e, m, k, s) {
  return (rotl((a + ((b & d) | (c & (~d))) + m + k) | 0, s) + e) | 0
}

function fn5 (a, b, c, d, e, m, k, s) {
  return (rotl((a + (b ^ (c | (~d))) + m + k) | 0, s) + e) | 0
}

module.exports = RIPEMD160

},{"buffer":110,"hash-base":41,"inherits":42}],62:[function(require,module,exports){
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/* eslint-disable node/no-deprecated-api */
var buffer = require('buffer')
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.prototype = Object.create(Buffer.prototype)

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}

},{"buffer":110}],63:[function(require,module,exports){
var Buffer = require('safe-buffer').Buffer

// prototype class for hash functions
function Hash (blockSize, finalSize) {
  this._block = Buffer.alloc(blockSize)
  this._finalSize = finalSize
  this._blockSize = blockSize
  this._len = 0
}

Hash.prototype.update = function (data, enc) {
  if (typeof data === 'string') {
    enc = enc || 'utf8'
    data = Buffer.from(data, enc)
  }

  var block = this._block
  var blockSize = this._blockSize
  var length = data.length
  var accum = this._len

  for (var offset = 0; offset < length;) {
    var assigned = accum % blockSize
    var remainder = Math.min(length - offset, blockSize - assigned)

    for (var i = 0; i < remainder; i++) {
      block[assigned + i] = data[offset + i]
    }

    accum += remainder
    offset += remainder

    if ((accum % blockSize) === 0) {
      this._update(block)
    }
  }

  this._len += length
  return this
}

Hash.prototype.digest = function (enc) {
  var rem = this._len % this._blockSize

  this._block[rem] = 0x80

  // zero (rem + 1) trailing bits, where (rem + 1) is the smallest
  // non-negative solution to the equation (length + 1 + (rem + 1)) === finalSize mod blockSize
  this._block.fill(0, rem + 1)

  if (rem >= this._finalSize) {
    this._update(this._block)
    this._block.fill(0)
  }

  var bits = this._len * 8

  // uint32
  if (bits <= 0xffffffff) {
    this._block.writeUInt32BE(bits, this._blockSize - 4)

  // uint64
  } else {
    var lowBits = (bits & 0xffffffff) >>> 0
    var highBits = (bits - lowBits) / 0x100000000

    this._block.writeUInt32BE(highBits, this._blockSize - 8)
    this._block.writeUInt32BE(lowBits, this._blockSize - 4)
  }

  this._update(this._block)
  var hash = this._hash()

  return enc ? hash.toString(enc) : hash
}

Hash.prototype._update = function () {
  throw new Error('_update must be implemented by subclass')
}

module.exports = Hash

},{"safe-buffer":62}],64:[function(require,module,exports){
var exports = module.exports = function SHA (algorithm) {
  algorithm = algorithm.toLowerCase()

  var Algorithm = exports[algorithm]
  if (!Algorithm) throw new Error(algorithm + ' is not supported (we accept pull requests)')

  return new Algorithm()
}

exports.sha = require('./sha')
exports.sha1 = require('./sha1')
exports.sha224 = require('./sha224')
exports.sha256 = require('./sha256')
exports.sha384 = require('./sha384')
exports.sha512 = require('./sha512')

},{"./sha":65,"./sha1":66,"./sha224":67,"./sha256":68,"./sha384":69,"./sha512":70}],65:[function(require,module,exports){
/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-0, as defined
 * in FIPS PUB 180-1
 * This source code is derived from sha1.js of the same repository.
 * The difference between SHA-0 and SHA-1 is just a bitwise rotate left
 * operation was added.
 */

var inherits = require('inherits')
var Hash = require('./hash')
var Buffer = require('safe-buffer').Buffer

var K = [
  0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
]

var W = new Array(80)

function Sha () {
  this.init()
  this._w = W

  Hash.call(this, 64, 56)
}

inherits(Sha, Hash)

Sha.prototype.init = function () {
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
  this._e = 0xc3d2e1f0

  return this
}

function rotl5 (num) {
  return (num << 5) | (num >>> 27)
}

function rotl30 (num) {
  return (num << 30) | (num >>> 2)
}

function ft (s, b, c, d) {
  if (s === 0) return (b & c) | ((~b) & d)
  if (s === 2) return (b & c) | (b & d) | (c & d)
  return b ^ c ^ d
}

Sha.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 80; ++i) W[i] = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16]

  for (var j = 0; j < 80; ++j) {
    var s = ~~(j / 20)
    var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0

    e = d
    d = c
    c = rotl30(b)
    b = a
    a = t
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
}

Sha.prototype._hash = function () {
  var H = Buffer.allocUnsafe(20)

  H.writeInt32BE(this._a | 0, 0)
  H.writeInt32BE(this._b | 0, 4)
  H.writeInt32BE(this._c | 0, 8)
  H.writeInt32BE(this._d | 0, 12)
  H.writeInt32BE(this._e | 0, 16)

  return H
}

module.exports = Sha

},{"./hash":63,"inherits":42,"safe-buffer":62}],66:[function(require,module,exports){
/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

var inherits = require('inherits')
var Hash = require('./hash')
var Buffer = require('safe-buffer').Buffer

var K = [
  0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
]

var W = new Array(80)

function Sha1 () {
  this.init()
  this._w = W

  Hash.call(this, 64, 56)
}

inherits(Sha1, Hash)

Sha1.prototype.init = function () {
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
  this._e = 0xc3d2e1f0

  return this
}

function rotl1 (num) {
  return (num << 1) | (num >>> 31)
}

function rotl5 (num) {
  return (num << 5) | (num >>> 27)
}

function rotl30 (num) {
  return (num << 30) | (num >>> 2)
}

function ft (s, b, c, d) {
  if (s === 0) return (b & c) | ((~b) & d)
  if (s === 2) return (b & c) | (b & d) | (c & d)
  return b ^ c ^ d
}

Sha1.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 80; ++i) W[i] = rotl1(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16])

  for (var j = 0; j < 80; ++j) {
    var s = ~~(j / 20)
    var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0

    e = d
    d = c
    c = rotl30(b)
    b = a
    a = t
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
}

Sha1.prototype._hash = function () {
  var H = Buffer.allocUnsafe(20)

  H.writeInt32BE(this._a | 0, 0)
  H.writeInt32BE(this._b | 0, 4)
  H.writeInt32BE(this._c | 0, 8)
  H.writeInt32BE(this._d | 0, 12)
  H.writeInt32BE(this._e | 0, 16)

  return H
}

module.exports = Sha1

},{"./hash":63,"inherits":42,"safe-buffer":62}],67:[function(require,module,exports){
/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var inherits = require('inherits')
var Sha256 = require('./sha256')
var Hash = require('./hash')
var Buffer = require('safe-buffer').Buffer

var W = new Array(64)

function Sha224 () {
  this.init()

  this._w = W // new Array(64)

  Hash.call(this, 64, 56)
}

inherits(Sha224, Sha256)

Sha224.prototype.init = function () {
  this._a = 0xc1059ed8
  this._b = 0x367cd507
  this._c = 0x3070dd17
  this._d = 0xf70e5939
  this._e = 0xffc00b31
  this._f = 0x68581511
  this._g = 0x64f98fa7
  this._h = 0xbefa4fa4

  return this
}

Sha224.prototype._hash = function () {
  var H = Buffer.allocUnsafe(28)

  H.writeInt32BE(this._a, 0)
  H.writeInt32BE(this._b, 4)
  H.writeInt32BE(this._c, 8)
  H.writeInt32BE(this._d, 12)
  H.writeInt32BE(this._e, 16)
  H.writeInt32BE(this._f, 20)
  H.writeInt32BE(this._g, 24)

  return H
}

module.exports = Sha224

},{"./hash":63,"./sha256":68,"inherits":42,"safe-buffer":62}],68:[function(require,module,exports){
/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var inherits = require('inherits')
var Hash = require('./hash')
var Buffer = require('safe-buffer').Buffer

var K = [
  0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,
  0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,
  0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,
  0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,
  0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,
  0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,
  0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,
  0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,
  0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,
  0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,
  0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,
  0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,
  0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,
  0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,
  0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,
  0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2
]

var W = new Array(64)

function Sha256 () {
  this.init()

  this._w = W // new Array(64)

  Hash.call(this, 64, 56)
}

inherits(Sha256, Hash)

Sha256.prototype.init = function () {
  this._a = 0x6a09e667
  this._b = 0xbb67ae85
  this._c = 0x3c6ef372
  this._d = 0xa54ff53a
  this._e = 0x510e527f
  this._f = 0x9b05688c
  this._g = 0x1f83d9ab
  this._h = 0x5be0cd19

  return this
}

function ch (x, y, z) {
  return z ^ (x & (y ^ z))
}

function maj (x, y, z) {
  return (x & y) | (z & (x | y))
}

function sigma0 (x) {
  return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10)
}

function sigma1 (x) {
  return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7)
}

function gamma0 (x) {
  return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ (x >>> 3)
}

function gamma1 (x) {
  return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ (x >>> 10)
}

Sha256.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0
  var f = this._f | 0
  var g = this._g | 0
  var h = this._h | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 64; ++i) W[i] = (gamma1(W[i - 2]) + W[i - 7] + gamma0(W[i - 15]) + W[i - 16]) | 0

  for (var j = 0; j < 64; ++j) {
    var T1 = (h + sigma1(e) + ch(e, f, g) + K[j] + W[j]) | 0
    var T2 = (sigma0(a) + maj(a, b, c)) | 0

    h = g
    g = f
    f = e
    e = (d + T1) | 0
    d = c
    c = b
    b = a
    a = (T1 + T2) | 0
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
  this._f = (f + this._f) | 0
  this._g = (g + this._g) | 0
  this._h = (h + this._h) | 0
}

Sha256.prototype._hash = function () {
  var H = Buffer.allocUnsafe(32)

  H.writeInt32BE(this._a, 0)
  H.writeInt32BE(this._b, 4)
  H.writeInt32BE(this._c, 8)
  H.writeInt32BE(this._d, 12)
  H.writeInt32BE(this._e, 16)
  H.writeInt32BE(this._f, 20)
  H.writeInt32BE(this._g, 24)
  H.writeInt32BE(this._h, 28)

  return H
}

module.exports = Sha256

},{"./hash":63,"inherits":42,"safe-buffer":62}],69:[function(require,module,exports){
var inherits = require('inherits')
var SHA512 = require('./sha512')
var Hash = require('./hash')
var Buffer = require('safe-buffer').Buffer

var W = new Array(160)

function Sha384 () {
  this.init()
  this._w = W

  Hash.call(this, 128, 112)
}

inherits(Sha384, SHA512)

Sha384.prototype.init = function () {
  this._ah = 0xcbbb9d5d
  this._bh = 0x629a292a
  this._ch = 0x9159015a
  this._dh = 0x152fecd8
  this._eh = 0x67332667
  this._fh = 0x8eb44a87
  this._gh = 0xdb0c2e0d
  this._hh = 0x47b5481d

  this._al = 0xc1059ed8
  this._bl = 0x367cd507
  this._cl = 0x3070dd17
  this._dl = 0xf70e5939
  this._el = 0xffc00b31
  this._fl = 0x68581511
  this._gl = 0x64f98fa7
  this._hl = 0xbefa4fa4

  return this
}

Sha384.prototype._hash = function () {
  var H = Buffer.allocUnsafe(48)

  function writeInt64BE (h, l, offset) {
    H.writeInt32BE(h, offset)
    H.writeInt32BE(l, offset + 4)
  }

  writeInt64BE(this._ah, this._al, 0)
  writeInt64BE(this._bh, this._bl, 8)
  writeInt64BE(this._ch, this._cl, 16)
  writeInt64BE(this._dh, this._dl, 24)
  writeInt64BE(this._eh, this._el, 32)
  writeInt64BE(this._fh, this._fl, 40)

  return H
}

module.exports = Sha384

},{"./hash":63,"./sha512":70,"inherits":42,"safe-buffer":62}],70:[function(require,module,exports){
var inherits = require('inherits')
var Hash = require('./hash')
var Buffer = require('safe-buffer').Buffer

var K = [
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
]

var W = new Array(160)

function Sha512 () {
  this.init()
  this._w = W

  Hash.call(this, 128, 112)
}

inherits(Sha512, Hash)

Sha512.prototype.init = function () {
  this._ah = 0x6a09e667
  this._bh = 0xbb67ae85
  this._ch = 0x3c6ef372
  this._dh = 0xa54ff53a
  this._eh = 0x510e527f
  this._fh = 0x9b05688c
  this._gh = 0x1f83d9ab
  this._hh = 0x5be0cd19

  this._al = 0xf3bcc908
  this._bl = 0x84caa73b
  this._cl = 0xfe94f82b
  this._dl = 0x5f1d36f1
  this._el = 0xade682d1
  this._fl = 0x2b3e6c1f
  this._gl = 0xfb41bd6b
  this._hl = 0x137e2179

  return this
}

function Ch (x, y, z) {
  return z ^ (x & (y ^ z))
}

function maj (x, y, z) {
  return (x & y) | (z & (x | y))
}

function sigma0 (x, xl) {
  return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25)
}

function sigma1 (x, xl) {
  return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23)
}

function Gamma0 (x, xl) {
  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7)
}

function Gamma0l (x, xl) {
  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25)
}

function Gamma1 (x, xl) {
  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6)
}

function Gamma1l (x, xl) {
  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26)
}

function getCarry (a, b) {
  return (a >>> 0) < (b >>> 0) ? 1 : 0
}

Sha512.prototype._update = function (M) {
  var W = this._w

  var ah = this._ah | 0
  var bh = this._bh | 0
  var ch = this._ch | 0
  var dh = this._dh | 0
  var eh = this._eh | 0
  var fh = this._fh | 0
  var gh = this._gh | 0
  var hh = this._hh | 0

  var al = this._al | 0
  var bl = this._bl | 0
  var cl = this._cl | 0
  var dl = this._dl | 0
  var el = this._el | 0
  var fl = this._fl | 0
  var gl = this._gl | 0
  var hl = this._hl | 0

  for (var i = 0; i < 32; i += 2) {
    W[i] = M.readInt32BE(i * 4)
    W[i + 1] = M.readInt32BE(i * 4 + 4)
  }
  for (; i < 160; i += 2) {
    var xh = W[i - 15 * 2]
    var xl = W[i - 15 * 2 + 1]
    var gamma0 = Gamma0(xh, xl)
    var gamma0l = Gamma0l(xl, xh)

    xh = W[i - 2 * 2]
    xl = W[i - 2 * 2 + 1]
    var gamma1 = Gamma1(xh, xl)
    var gamma1l = Gamma1l(xl, xh)

    // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
    var Wi7h = W[i - 7 * 2]
    var Wi7l = W[i - 7 * 2 + 1]

    var Wi16h = W[i - 16 * 2]
    var Wi16l = W[i - 16 * 2 + 1]

    var Wil = (gamma0l + Wi7l) | 0
    var Wih = (gamma0 + Wi7h + getCarry(Wil, gamma0l)) | 0
    Wil = (Wil + gamma1l) | 0
    Wih = (Wih + gamma1 + getCarry(Wil, gamma1l)) | 0
    Wil = (Wil + Wi16l) | 0
    Wih = (Wih + Wi16h + getCarry(Wil, Wi16l)) | 0

    W[i] = Wih
    W[i + 1] = Wil
  }

  for (var j = 0; j < 160; j += 2) {
    Wih = W[j]
    Wil = W[j + 1]

    var majh = maj(ah, bh, ch)
    var majl = maj(al, bl, cl)

    var sigma0h = sigma0(ah, al)
    var sigma0l = sigma0(al, ah)
    var sigma1h = sigma1(eh, el)
    var sigma1l = sigma1(el, eh)

    // t1 = h + sigma1 + ch + K[j] + W[j]
    var Kih = K[j]
    var Kil = K[j + 1]

    var chh = Ch(eh, fh, gh)
    var chl = Ch(el, fl, gl)

    var t1l = (hl + sigma1l) | 0
    var t1h = (hh + sigma1h + getCarry(t1l, hl)) | 0
    t1l = (t1l + chl) | 0
    t1h = (t1h + chh + getCarry(t1l, chl)) | 0
    t1l = (t1l + Kil) | 0
    t1h = (t1h + Kih + getCarry(t1l, Kil)) | 0
    t1l = (t1l + Wil) | 0
    t1h = (t1h + Wih + getCarry(t1l, Wil)) | 0

    // t2 = sigma0 + maj
    var t2l = (sigma0l + majl) | 0
    var t2h = (sigma0h + majh + getCarry(t2l, sigma0l)) | 0

    hh = gh
    hl = gl
    gh = fh
    gl = fl
    fh = eh
    fl = el
    el = (dl + t1l) | 0
    eh = (dh + t1h + getCarry(el, dl)) | 0
    dh = ch
    dl = cl
    ch = bh
    cl = bl
    bh = ah
    bl = al
    al = (t1l + t2l) | 0
    ah = (t1h + t2h + getCarry(al, t1l)) | 0
  }

  this._al = (this._al + al) | 0
  this._bl = (this._bl + bl) | 0
  this._cl = (this._cl + cl) | 0
  this._dl = (this._dl + dl) | 0
  this._el = (this._el + el) | 0
  this._fl = (this._fl + fl) | 0
  this._gl = (this._gl + gl) | 0
  this._hl = (this._hl + hl) | 0

  this._ah = (this._ah + ah + getCarry(this._al, al)) | 0
  this._bh = (this._bh + bh + getCarry(this._bl, bl)) | 0
  this._ch = (this._ch + ch + getCarry(this._cl, cl)) | 0
  this._dh = (this._dh + dh + getCarry(this._dl, dl)) | 0
  this._eh = (this._eh + eh + getCarry(this._el, el)) | 0
  this._fh = (this._fh + fh + getCarry(this._fl, fl)) | 0
  this._gh = (this._gh + gh + getCarry(this._gl, gl)) | 0
  this._hh = (this._hh + hh + getCarry(this._hl, hl)) | 0
}

Sha512.prototype._hash = function () {
  var H = Buffer.allocUnsafe(64)

  function writeInt64BE (h, l, offset) {
    H.writeInt32BE(h, offset)
    H.writeInt32BE(l, offset + 4)
  }

  writeInt64BE(this._ah, this._al, 0)
  writeInt64BE(this._bh, this._bl, 8)
  writeInt64BE(this._ch, this._cl, 16)
  writeInt64BE(this._dh, this._dl, 24)
  writeInt64BE(this._eh, this._el, 32)
  writeInt64BE(this._fh, this._fl, 40)
  writeInt64BE(this._gh, this._gl, 48)
  writeInt64BE(this._hh, this._hl, 56)

  return H
}

module.exports = Sha512

},{"./hash":63,"inherits":42,"safe-buffer":62}],71:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}
},{"safe-buffer":62}],72:[function(require,module,exports){
var native = require('./native')

function getTypeName (fn) {
  return fn.name || fn.toString().match(/function (.*?)\s*\(/)[1]
}

function getValueTypeName (value) {
  return native.Nil(value) ? '' : getTypeName(value.constructor)
}

function getValue (value) {
  if (native.Function(value)) return ''
  if (native.String(value)) return JSON.stringify(value)
  if (value && native.Object(value)) return ''
  return value
}

function captureStackTrace (e, t) {
  if (Error.captureStackTrace) {
    Error.captureStackTrace(e, t)
  }
}

function tfJSON (type) {
  if (native.Function(type)) return type.toJSON ? type.toJSON() : getTypeName(type)
  if (native.Array(type)) return 'Array'
  if (type && native.Object(type)) return 'Object'

  return type !== undefined ? type : ''
}

function tfErrorString (type, value, valueTypeName) {
  var valueJson = getValue(value)

  return 'Expected ' + tfJSON(type) + ', got' +
    (valueTypeName !== '' ? ' ' + valueTypeName : '') +
    (valueJson !== '' ? ' ' + valueJson : '')
}

function TfTypeError (type, value, valueTypeName) {
  valueTypeName = valueTypeName || getValueTypeName(value)
  this.message = tfErrorString(type, value, valueTypeName)

  captureStackTrace(this, TfTypeError)
  this.__type = type
  this.__value = value
  this.__valueTypeName = valueTypeName
}

TfTypeError.prototype = Object.create(Error.prototype)
TfTypeError.prototype.constructor = TfTypeError

function tfPropertyErrorString (type, label, name, value, valueTypeName) {
  var description = '" of type '
  if (label === 'key') description = '" with key type '

  return tfErrorString('property "' + tfJSON(name) + description + tfJSON(type), value, valueTypeName)
}

function TfPropertyTypeError (type, property, label, value, valueTypeName) {
  if (type) {
    valueTypeName = valueTypeName || getValueTypeName(value)
    this.message = tfPropertyErrorString(type, label, property, value, valueTypeName)
  } else {
    this.message = 'Unexpected property "' + property + '"'
  }

  captureStackTrace(this, TfTypeError)
  this.__label = label
  this.__property = property
  this.__type = type
  this.__value = value
  this.__valueTypeName = valueTypeName
}

TfPropertyTypeError.prototype = Object.create(Error.prototype)
TfPropertyTypeError.prototype.constructor = TfTypeError

function tfCustomError (expected, actual) {
  return new TfTypeError(expected, {}, actual)
}

function tfSubError (e, property, label) {
  // sub child?
  if (e instanceof TfPropertyTypeError) {
    property = property + '.' + e.__property

    e = new TfPropertyTypeError(
      e.__type, property, e.__label, e.__value, e.__valueTypeName
    )

  // child?
  } else if (e instanceof TfTypeError) {
    e = new TfPropertyTypeError(
      e.__type, property, label, e.__value, e.__valueTypeName
    )
  }

  captureStackTrace(e)
  return e
}

module.exports = {
  TfTypeError: TfTypeError,
  TfPropertyTypeError: TfPropertyTypeError,
  tfCustomError: tfCustomError,
  tfSubError: tfSubError,
  tfJSON: tfJSON,
  getValueTypeName: getValueTypeName
}

},{"./native":75}],73:[function(require,module,exports){
(function (Buffer){(function (){
var NATIVE = require('./native')
var ERRORS = require('./errors')

function _Buffer (value) {
  return Buffer.isBuffer(value)
}

function Hex (value) {
  return typeof value === 'string' && /^([0-9a-f]{2})+$/i.test(value)
}

function _LengthN (type, length) {
  var name = type.toJSON()

  function Length (value) {
    if (!type(value)) return false
    if (value.length === length) return true

    throw ERRORS.tfCustomError(name + '(Length: ' + length + ')', name + '(Length: ' + value.length + ')')
  }
  Length.toJSON = function () { return name }

  return Length
}

var _ArrayN = _LengthN.bind(null, NATIVE.Array)
var _BufferN = _LengthN.bind(null, _Buffer)
var _HexN = _LengthN.bind(null, Hex)
var _StringN = _LengthN.bind(null, NATIVE.String)

function Range (a, b, f) {
  f = f || NATIVE.Number
  function _range (value, strict) {
    return f(value, strict) && (value > a) && (value < b)
  }
  _range.toJSON = function () {
    return `${f.toJSON()} between [${a}, ${b}]`
  }
  return _range
}

var INT53_MAX = Math.pow(2, 53) - 1

function Finite (value) {
  return typeof value === 'number' && isFinite(value)
}
function Int8 (value) { return ((value << 24) >> 24) === value }
function Int16 (value) { return ((value << 16) >> 16) === value }
function Int32 (value) { return (value | 0) === value }
function Int53 (value) {
  return typeof value === 'number' &&
    value >= -INT53_MAX &&
    value <= INT53_MAX &&
    Math.floor(value) === value
}
function UInt8 (value) { return (value & 0xff) === value }
function UInt16 (value) { return (value & 0xffff) === value }
function UInt32 (value) { return (value >>> 0) === value }
function UInt53 (value) {
  return typeof value === 'number' &&
    value >= 0 &&
    value <= INT53_MAX &&
    Math.floor(value) === value
}

var types = {
  ArrayN: _ArrayN,
  Buffer: _Buffer,
  BufferN: _BufferN,
  Finite: Finite,
  Hex: Hex,
  HexN: _HexN,
  Int8: Int8,
  Int16: Int16,
  Int32: Int32,
  Int53: Int53,
  Range: Range,
  StringN: _StringN,
  UInt8: UInt8,
  UInt16: UInt16,
  UInt32: UInt32,
  UInt53: UInt53
}

for (var typeName in types) {
  types[typeName].toJSON = function (t) {
    return t
  }.bind(null, typeName)
}

module.exports = types

}).call(this)}).call(this,{"isBuffer":require("../../../../../usr/local/lib/node_modules/browserify/node_modules/is-buffer/index.js")})
},{"../../../../../usr/local/lib/node_modules/browserify/node_modules/is-buffer/index.js":114,"./errors":72,"./native":75}],74:[function(require,module,exports){
var ERRORS = require('./errors')
var NATIVE = require('./native')

// short-hand
var tfJSON = ERRORS.tfJSON
var TfTypeError = ERRORS.TfTypeError
var TfPropertyTypeError = ERRORS.TfPropertyTypeError
var tfSubError = ERRORS.tfSubError
var getValueTypeName = ERRORS.getValueTypeName

var TYPES = {
  arrayOf: function arrayOf (type, options) {
    type = compile(type)
    options = options || {}

    function _arrayOf (array, strict) {
      if (!NATIVE.Array(array)) return false
      if (NATIVE.Nil(array)) return false
      if (options.minLength !== undefined && array.length < options.minLength) return false
      if (options.maxLength !== undefined && array.length > options.maxLength) return false
      if (options.length !== undefined && array.length !== options.length) return false

      return array.every(function (value, i) {
        try {
          return typeforce(type, value, strict)
        } catch (e) {
          throw tfSubError(e, i)
        }
      })
    }
    _arrayOf.toJSON = function () {
      var str = '[' + tfJSON(type) + ']'
      if (options.length !== undefined) {
        str += '{' + options.length + '}'
      } else if (options.minLength !== undefined || options.maxLength !== undefined) {
        str += '{' +
          (options.minLength === undefined ? 0 : options.minLength) + ',' +
          (options.maxLength === undefined ? Infinity : options.maxLength) + '}'
      }
      return str
    }

    return _arrayOf
  },

  maybe: function maybe (type) {
    type = compile(type)

    function _maybe (value, strict) {
      return NATIVE.Nil(value) || type(value, strict, maybe)
    }
    _maybe.toJSON = function () { return '?' + tfJSON(type) }

    return _maybe
  },

  map: function map (propertyType, propertyKeyType) {
    propertyType = compile(propertyType)
    if (propertyKeyType) propertyKeyType = compile(propertyKeyType)

    function _map (value, strict) {
      if (!NATIVE.Object(value)) return false
      if (NATIVE.Nil(value)) return false

      for (var propertyName in value) {
        try {
          if (propertyKeyType) {
            typeforce(propertyKeyType, propertyName, strict)
          }
        } catch (e) {
          throw tfSubError(e, propertyName, 'key')
        }

        try {
          var propertyValue = value[propertyName]
          typeforce(propertyType, propertyValue, strict)
        } catch (e) {
          throw tfSubError(e, propertyName)
        }
      }

      return true
    }

    if (propertyKeyType) {
      _map.toJSON = function () {
        return '{' + tfJSON(propertyKeyType) + ': ' + tfJSON(propertyType) + '}'
      }
    } else {
      _map.toJSON = function () { return '{' + tfJSON(propertyType) + '}' }
    }

    return _map
  },

  object: function object (uncompiled) {
    var type = {}

    for (var typePropertyName in uncompiled) {
      type[typePropertyName] = compile(uncompiled[typePropertyName])
    }

    function _object (value, strict) {
      if (!NATIVE.Object(value)) return false
      if (NATIVE.Nil(value)) return false

      var propertyName

      try {
        for (propertyName in type) {
          var propertyType = type[propertyName]
          var propertyValue = value[propertyName]

          typeforce(propertyType, propertyValue, strict)
        }
      } catch (e) {
        throw tfSubError(e, propertyName)
      }

      if (strict) {
        for (propertyName in value) {
          if (type[propertyName]) continue

          throw new TfPropertyTypeError(undefined, propertyName)
        }
      }

      return true
    }
    _object.toJSON = function () { return tfJSON(type) }

    return _object
  },

  anyOf: function anyOf () {
    var types = [].slice.call(arguments).map(compile)

    function _anyOf (value, strict) {
      return types.some(function (type) {
        try {
          return typeforce(type, value, strict)
        } catch (e) {
          return false
        }
      })
    }
    _anyOf.toJSON = function () { return types.map(tfJSON).join('|') }

    return _anyOf
  },

  allOf: function allOf () {
    var types = [].slice.call(arguments).map(compile)

    function _allOf (value, strict) {
      return types.every(function (type) {
        try {
          return typeforce(type, value, strict)
        } catch (e) {
          return false
        }
      })
    }
    _allOf.toJSON = function () { return types.map(tfJSON).join(' & ') }

    return _allOf
  },

  quacksLike: function quacksLike (type) {
    function _quacksLike (value) {
      return type === getValueTypeName(value)
    }
    _quacksLike.toJSON = function () { return type }

    return _quacksLike
  },

  tuple: function tuple () {
    var types = [].slice.call(arguments).map(compile)

    function _tuple (values, strict) {
      if (NATIVE.Nil(values)) return false
      if (NATIVE.Nil(values.length)) return false
      if (strict && (values.length !== types.length)) return false

      return types.every(function (type, i) {
        try {
          return typeforce(type, values[i], strict)
        } catch (e) {
          throw tfSubError(e, i)
        }
      })
    }
    _tuple.toJSON = function () { return '(' + types.map(tfJSON).join(', ') + ')' }

    return _tuple
  },

  value: function value (expected) {
    function _value (actual) {
      return actual === expected
    }
    _value.toJSON = function () { return expected }

    return _value
  }
}

// TODO: deprecate
TYPES.oneOf = TYPES.anyOf

function compile (type) {
  if (NATIVE.String(type)) {
    if (type[0] === '?') return TYPES.maybe(type.slice(1))

    return NATIVE[type] || TYPES.quacksLike(type)
  } else if (type && NATIVE.Object(type)) {
    if (NATIVE.Array(type)) {
      if (type.length !== 1) throw new TypeError('Expected compile() parameter of type Array of length 1')
      return TYPES.arrayOf(type[0])
    }

    return TYPES.object(type)
  } else if (NATIVE.Function(type)) {
    return type
  }

  return TYPES.value(type)
}

function typeforce (type, value, strict, surrogate) {
  if (NATIVE.Function(type)) {
    if (type(value, strict)) return true

    throw new TfTypeError(surrogate || type, value)
  }

  // JIT
  return typeforce(compile(type), value, strict)
}

// assign types to typeforce function
for (var typeName in NATIVE) {
  typeforce[typeName] = NATIVE[typeName]
}

for (typeName in TYPES) {
  typeforce[typeName] = TYPES[typeName]
}

var EXTRA = require('./extra')
for (typeName in EXTRA) {
  typeforce[typeName] = EXTRA[typeName]
}

typeforce.compile = compile
typeforce.TfTypeError = TfTypeError
typeforce.TfPropertyTypeError = TfPropertyTypeError

module.exports = typeforce

},{"./errors":72,"./extra":73,"./native":75}],75:[function(require,module,exports){
var types = {
  Array: function (value) { return value !== null && value !== undefined && value.constructor === Array },
  Boolean: function (value) { return typeof value === 'boolean' },
  Function: function (value) { return typeof value === 'function' },
  Nil: function (value) { return value === undefined || value === null },
  Number: function (value) { return typeof value === 'number' },
  Object: function (value) { return typeof value === 'object' },
  String: function (value) { return typeof value === 'string' },
  '': function () { return true }
}

// TODO: deprecate
types.Null = types.Nil

for (var typeName in types) {
  types[typeName].toJSON = function (t) {
    return t
  }.bind(null, typeName)
}

module.exports = types

},{}],76:[function(require,module,exports){
(function (global){(function (){

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],77:[function(require,module,exports){
'use strict'
var Buffer = require('safe-buffer').Buffer

// Number.MAX_SAFE_INTEGER
var MAX_SAFE_INTEGER = 9007199254740991

function checkUInt53 (n) {
  if (n < 0 || n > MAX_SAFE_INTEGER || n % 1 !== 0) throw new RangeError('value out of range')
}

function encode (number, buffer, offset) {
  checkUInt53(number)

  if (!buffer) buffer = Buffer.allocUnsafe(encodingLength(number))
  if (!Buffer.isBuffer(buffer)) throw new TypeError('buffer must be a Buffer instance')
  if (!offset) offset = 0

  // 8 bit
  if (number < 0xfd) {
    buffer.writeUInt8(number, offset)
    encode.bytes = 1

  // 16 bit
  } else if (number <= 0xffff) {
    buffer.writeUInt8(0xfd, offset)
    buffer.writeUInt16LE(number, offset + 1)
    encode.bytes = 3

  // 32 bit
  } else if (number <= 0xffffffff) {
    buffer.writeUInt8(0xfe, offset)
    buffer.writeUInt32LE(number, offset + 1)
    encode.bytes = 5

  // 64 bit
  } else {
    buffer.writeUInt8(0xff, offset)
    buffer.writeUInt32LE(number >>> 0, offset + 1)
    buffer.writeUInt32LE((number / 0x100000000) | 0, offset + 5)
    encode.bytes = 9
  }

  return buffer
}

function decode (buffer, offset) {
  if (!Buffer.isBuffer(buffer)) throw new TypeError('buffer must be a Buffer instance')
  if (!offset) offset = 0

  var first = buffer.readUInt8(offset)

  // 8 bit
  if (first < 0xfd) {
    decode.bytes = 1
    return first

  // 16 bit
  } else if (first === 0xfd) {
    decode.bytes = 3
    return buffer.readUInt16LE(offset + 1)

  // 32 bit
  } else if (first === 0xfe) {
    decode.bytes = 5
    return buffer.readUInt32LE(offset + 1)

  // 64 bit
  } else {
    decode.bytes = 9
    var lo = buffer.readUInt32LE(offset + 1)
    var hi = buffer.readUInt32LE(offset + 5)
    var number = hi * 0x0100000000 + lo
    checkUInt53(number)

    return number
  }
}

function encodingLength (number) {
  checkUInt53(number)

  return (
    number < 0xfd ? 1
      : number <= 0xffff ? 3
        : number <= 0xffffffff ? 5
          : 9
  )
}

module.exports = { encode: encode, decode: decode, encodingLength: encodingLength }

},{"safe-buffer":62}],78:[function(require,module,exports){
(function (Buffer){(function (){
var bs58check = require('bs58check')

function decodeRaw (buffer, version) {
  // check version only if defined
  if (version !== undefined && buffer[0] !== version) throw new Error('Invalid network version')

  // uncompressed
  if (buffer.length === 33) {
    return {
      version: buffer[0],
      privateKey: buffer.slice(1, 33),
      compressed: false
    }
  }

  // invalid length
  if (buffer.length !== 34) throw new Error('Invalid WIF length')

  // invalid compression flag
  if (buffer[33] !== 0x01) throw new Error('Invalid compression flag')

  return {
    version: buffer[0],
    privateKey: buffer.slice(1, 33),
    compressed: true
  }
}

function encodeRaw (version, privateKey, compressed) {
  var result = new Buffer(compressed ? 34 : 33)

  result.writeUInt8(version, 0)
  privateKey.copy(result, 1)

  if (compressed) {
    result[33] = 0x01
  }

  return result
}

function decode (string, version) {
  return decodeRaw(bs58check.decode(string), version)
}

function encode (version, privateKey, compressed) {
  if (typeof version === 'number') return bs58check.encode(encodeRaw(version, privateKey, compressed))

  return bs58check.encode(
    encodeRaw(
      version.version,
      version.privateKey,
      version.compressed
    )
  )
}

module.exports = {
  decode: decode,
  decodeRaw: decodeRaw,
  encode: encode,
  encodeRaw: encodeRaw
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"bs58check":33,"buffer":110}],79:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';
var __createBinding =
  (this && this.__createBinding) ||
  (Object.create
    ? function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (
          !desc ||
          ('get' in desc ? !m.__esModule : desc.writable || desc.configurable)
        ) {
          desc = {
            enumerable: true,
            get: function() {
              return m[k];
            },
          };
        }
        Object.defineProperty(o, k2, desc);
      }
    : function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
      });
var __setModuleDefault =
  (this && this.__setModuleDefault) ||
  (Object.create
    ? function(o, v) {
        Object.defineProperty(o, 'default', { enumerable: true, value: v });
      }
    : function(o, v) {
        o['default'] = v;
      });
var __importStar =
  (this && this.__importStar) ||
  function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null)
      for (var k in mod)
        if (k !== 'default' && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
  };
Object.defineProperty(exports, '__esModule', { value: true });
exports.isConfidential = exports.decodeType = exports.getNetwork = exports.toOutputScript = exports.fromOutputScript = exports.toConfidential = exports.toBlech32 = exports.toBech32 = exports.toBase58Check = exports.fromConfidential = exports.fromBlech32 = exports.fromBech32 = exports.fromBase58Check = void 0;
const networks = __importStar(require('./networks'));
const payments = __importStar(require('./payments'));
const bscript = __importStar(require('./script'));
const types = __importStar(require('./types'));
const blech32_1 = require('blech32');
const bech32_1 = require('bech32');
const bs58check = __importStar(require('bs58check'));
const { typeforce } = types;
const FUTURE_SEGWIT_MAX_SIZE = 40;
const FUTURE_SEGWIT_MIN_SIZE = 2;
const FUTURE_SEGWIT_MAX_VERSION = 16;
const FUTURE_SEGWIT_MIN_VERSION = 1;
const FUTURE_SEGWIT_VERSION_DIFF = 0x50;
function _toFutureSegwitAddress(output, network) {
  const data = output.slice(2);
  if (
    data.length < FUTURE_SEGWIT_MIN_SIZE ||
    data.length > FUTURE_SEGWIT_MAX_SIZE
  )
    throw new TypeError('Invalid program length for segwit address');
  const version = output[0] - FUTURE_SEGWIT_VERSION_DIFF;
  if (
    version < FUTURE_SEGWIT_MIN_VERSION ||
    version > FUTURE_SEGWIT_MAX_VERSION
  )
    throw new TypeError('Invalid version for segwit address');
  if (output[1] !== data.length)
    throw new TypeError('Invalid script for segwit address');
  return toBech32(data, version, network.bech32);
}
// negative value for confidential types
var AddressType;
(function(AddressType) {
  AddressType[(AddressType['P2Pkh'] = 0)] = 'P2Pkh';
  AddressType[(AddressType['P2Sh'] = 1)] = 'P2Sh';
  AddressType[(AddressType['P2Wpkh'] = 2)] = 'P2Wpkh';
  AddressType[(AddressType['P2Wsh'] = 3)] = 'P2Wsh';
  AddressType[(AddressType['ConfidentialP2Pkh'] = 4)] = 'ConfidentialP2Pkh';
  AddressType[(AddressType['ConfidentialP2Sh'] = 5)] = 'ConfidentialP2Sh';
  AddressType[(AddressType['ConfidentialP2Wpkh'] = 6)] = 'ConfidentialP2Wpkh';
  AddressType[(AddressType['ConfidentialP2Wsh'] = 7)] = 'ConfidentialP2Wsh';
})(AddressType || (AddressType = {}));
function isConfidentialAddressType(addressType) {
  return addressType >= 4;
}
function fromBase58Check(address) {
  const payload = bs58check.decode(address);
  // TODO: 4.0.0, move to "toOutputScript"
  if (payload.length < 21) throw new TypeError(address + ' is too short');
  if (payload.length > 21) throw new TypeError(address + ' is too long');
  const version = payload.readUInt8(0);
  const hash = payload.slice(1);
  return { version, hash };
}
exports.fromBase58Check = fromBase58Check;
function fromBech32(address) {
  let result;
  let version;
  try {
    result = bech32_1.bech32.decode(address);
  } catch (e) {}
  if (result) {
    version = result.words[0];
    if (version !== 0) throw new TypeError(address + ' uses wrong encoding');
  } else {
    result = bech32_1.bech32m.decode(address);
    version = result.words[0];
    if (version === 0) throw new TypeError(address + ' uses wrong encoding');
  }
  const data = bech32_1.bech32.fromWords(result.words.slice(1));
  return {
    version,
    prefix: result.prefix,
    data: Buffer.from(data),
  };
}
exports.fromBech32 = fromBech32;
function fromBlech32(address) {
  let result;
  try {
    result = blech32_1.Blech32Address.fromString(address, blech32_1.BLECH32);
  } catch {
    result = blech32_1.Blech32Address.fromString(address, blech32_1.BLECH32M);
  }
  const pubkey = Buffer.from(result.blindingPublicKey, 'hex');
  const prg = Buffer.from(result.witness, 'hex');
  const data = Buffer.concat([
    Buffer.from([
      result.witnessVersion
        ? result.witnessVersion + FUTURE_SEGWIT_VERSION_DIFF
        : result.witnessVersion,
      prg.length,
    ]),
    prg,
  ]);
  return {
    version: result.witnessVersion,
    pubkey,
    data,
  };
}
exports.fromBlech32 = fromBlech32;
function fromConfidential(address) {
  const network = getNetwork(address);
  if (address.startsWith(network.blech32))
    return fromConfidentialSegwit(address, network);
  return fromConfidentialLegacy(address, network);
}
exports.fromConfidential = fromConfidential;
function toBase58Check(hash, version) {
  typeforce(types.tuple(types.Hash160bit, types.UInt8), arguments);
  const payload = Buffer.allocUnsafe(21);
  payload.writeUInt8(version, 0);
  hash.copy(payload, 1);
  return bs58check.encode(payload);
}
exports.toBase58Check = toBase58Check;
function toBech32(data, version, prefix) {
  const words = bech32_1.bech32.toWords(data);
  words.unshift(version);
  return version === 0
    ? bech32_1.bech32.encode(prefix, words)
    : bech32_1.bech32m.encode(prefix, words);
}
exports.toBech32 = toBech32;
function toBlech32(data, pubkey, prefix, witnessVersion) {
  return blech32_1.Blech32Address.from(
    data.slice(2).toString('hex'),
    pubkey.toString('hex'),
    prefix,
    witnessVersion,
  ).address;
}
exports.toBlech32 = toBlech32;
function toConfidential(address, blindingKey) {
  const network = getNetwork(address);
  if (address.startsWith(network.bech32))
    return toConfidentialSegwit(address, blindingKey, network);
  return toConfidentialLegacy(address, blindingKey, network);
}
exports.toConfidential = toConfidential;
function fromOutputScript(output, network) {
  // TODO: Network
  network = network || networks.liquid;
  try {
    return payments.p2pkh({ output, network }).address;
  } catch (e) {}
  try {
    return payments.p2sh({ output, network }).address;
  } catch (e) {}
  try {
    return payments.p2wpkh({ output, network }).address;
  } catch (e) {}
  try {
    return payments.p2wsh({ output, network }).address;
  } catch (e) {}
  try {
    return _toFutureSegwitAddress(output, network);
  } catch (e) {}
  throw new Error(bscript.toASM(output) + ' has no matching Address');
}
exports.fromOutputScript = fromOutputScript;
function toOutputScript(address, network) {
  network = network || getNetwork(address);
  let decodedBase58;
  let decodedBech32;
  let decodedConfidential;
  try {
    decodedBase58 = fromBase58Check(address);
  } catch (e) {}
  if (decodedBase58) {
    if (decodedBase58.version === network.pubKeyHash)
      return payments.p2pkh({ hash: decodedBase58.hash }).output;
    if (decodedBase58.version === network.scriptHash)
      return payments.p2sh({ hash: decodedBase58.hash }).output;
  } else {
    try {
      decodedBech32 = fromBech32(address);
    } catch (e) {}
    if (decodedBech32) {
      if (decodedBech32.prefix !== network.bech32)
        throw new Error(address + ' has an invalid prefix');
      if (decodedBech32.version === 0) {
        if (decodedBech32.data.length === 20)
          return payments.p2wpkh({ hash: decodedBech32.data }).output;
        if (decodedBech32.data.length === 32)
          return payments.p2wsh({ hash: decodedBech32.data }).output;
      } else if (
        decodedBech32.version >= FUTURE_SEGWIT_MIN_VERSION &&
        decodedBech32.version <= FUTURE_SEGWIT_MAX_VERSION &&
        decodedBech32.data.length >= FUTURE_SEGWIT_MIN_SIZE &&
        decodedBech32.data.length <= FUTURE_SEGWIT_MAX_SIZE
      ) {
        return bscript.compile([
          decodedBech32.version + FUTURE_SEGWIT_VERSION_DIFF,
          decodedBech32.data,
        ]);
      }
    } else {
      try {
        decodedConfidential = fromConfidential(address);
      } catch (e) {}
      if (decodedConfidential) {
        return toOutputScript(
          decodedConfidential.unconfidentialAddress,
          network,
        );
      }
    }
  }
  throw new Error(address + ' has no matching Script');
}
exports.toOutputScript = toOutputScript;
function isNetwork(network, address) {
  if (address.startsWith(network.blech32) || address.startsWith(network.bech32))
    return true;
  try {
    const payload = bs58check.decode(address);
    const prefix = payload.readUInt8(0);
    if (
      prefix === network.confidentialPrefix ||
      prefix === network.pubKeyHash ||
      prefix === network.scriptHash
    )
      return true;
  } catch {
    return false;
  }
  return false;
}
// determines the network of a given address
function getNetwork(address) {
  const allNetworks = [networks.liquid, networks.regtest, networks.testnet];
  for (const network of allNetworks) {
    if (isNetwork(network, address)) return network;
  }
  throw new Error(address + ' has an invalid prefix');
}
exports.getNetwork = getNetwork;
function fromConfidentialLegacy(address, network) {
  const payload = bs58check.decode(address);
  const prefix = payload.readUInt8(1);
  // Check if address has valid length and prefix
  if (prefix !== network.pubKeyHash && prefix !== network.scriptHash)
    throw new TypeError(address + 'is not valid');
  if (payload.length < 55) throw new TypeError(address + ' is too short');
  if (payload.length > 55) throw new TypeError(address + ' is too long');
  // Blinded decoded haddress has the form:
  // BLIND_PREFIX|ADDRESS_PREFIX|BLINDING_KEY|SCRIPT_HASH
  // Prefixes are 1 byte long, thus blinding key always starts at 3rd byte
  const blindingKey = payload.slice(2, 35);
  const unconfidential = payload.slice(35, payload.length);
  const versionBuf = Buffer.alloc(1);
  versionBuf[0] = prefix;
  const unconfidentialAddressBuffer = Buffer.concat([
    versionBuf,
    unconfidential,
  ]);
  const unconfidentialAddress = bs58check.encode(unconfidentialAddressBuffer);
  return { blindingKey, unconfidentialAddress };
}
function fromConfidentialSegwit(address, network) {
  const result = fromBlech32(address);
  const unconfidentialAddress = fromOutputScript(result.data, network);
  return { blindingKey: result.pubkey, unconfidentialAddress };
}
function toConfidentialLegacy(address, blindingKey, network) {
  const payload = bs58check.decode(address);
  const prefix = payload.readUInt8(0);
  // Check if address has valid length and prefix
  if (
    payload.length !== 21 ||
    (prefix !== network.pubKeyHash && prefix !== network.scriptHash)
  )
    throw new TypeError(address + 'is not valid');
  // Check if blind key has valid length
  if (blindingKey.length < 33) throw new TypeError('Blinding key is too short');
  if (blindingKey.length > 33) throw new TypeError('Blinding key is too long');
  const prefixBuf = Buffer.alloc(2);
  prefixBuf[0] = network.confidentialPrefix;
  prefixBuf[1] = prefix;
  const confidentialAddress = Buffer.concat([
    prefixBuf,
    blindingKey,
    Buffer.from(payload.slice(1)),
  ]);
  return bs58check.encode(confidentialAddress);
}
function toConfidentialSegwit(address, blindingKey, network) {
  const data = toOutputScript(address, network);
  const version = fromBech32(address).version;
  return toBlech32(data, blindingKey, network.blech32, version);
}
function isBlech32(address, network) {
  return address.startsWith(network.blech32);
}
function decodeBlech32(address) {
  const blech32addr = fromBlech32(address);
  switch (blech32addr.data.length - 2) {
    case 20:
      return AddressType.ConfidentialP2Wpkh;
    case 32:
      return AddressType.ConfidentialP2Wsh;
    default:
      throw new Error(
        `invalid blech32 program length: ${blech32addr.data.length - 2}`,
      );
  }
}
function isBech32(address, network) {
  return address.startsWith(network.bech32);
}
function decodeBech32(address) {
  const bech32addr = fromBech32(address);
  switch (bech32addr.data.length) {
    case 20:
      return AddressType.P2Wpkh;
    case 32:
      return AddressType.P2Wsh;
    default:
      throw new Error('invalid program length');
  }
}
function UnkownPrefixError(prefix, network) {
  return new Error(
    `unknown address prefix (${prefix}), need ${network.pubKeyHash} or ${
      network.scriptHash
    }`,
  );
}
function decodeBase58(address, network) {
  const payload = bs58check.decode(address);
  // Blinded decoded haddress has the form:
  // BLIND_PREFIX|ADDRESS_PREFIX|BLINDING_KEY|SCRIPT_HASH
  // Prefixes are 1 byte long, thus blinding key always starts at 3rd byte
  const prefix = payload.readUInt8(1);
  if (payload.readUInt8(0) === network.confidentialPrefix) {
    const unconfidentialPart = payload.slice(35); // ignore the blinding key
    if (unconfidentialPart.length !== 20) {
      // ripem160 hash size
      throw new Error('decoded address is of unknown size');
    }
    switch (prefix) {
      case network.pubKeyHash:
        return AddressType.ConfidentialP2Pkh;
      case network.scriptHash:
        return AddressType.ConfidentialP2Sh;
      default:
        throw UnkownPrefixError(prefix, network);
    }
  }
  // unconf case
  const unconfidential = payload.slice(2);
  if (unconfidential.length !== 20) {
    // ripem160 hash size
    throw new Error('decoded address is of unknown size');
  }
  switch (prefix) {
    case network.pubKeyHash:
      return AddressType.P2Pkh;
    case network.scriptHash:
      return AddressType.P2Sh;
    default:
      throw UnkownPrefixError(prefix, network);
  }
}
function decodeType(address, network) {
  network = network || getNetwork(address);
  if (isBech32(address, network)) {
    return decodeBech32(address);
  }
  if (isBlech32(address, network)) {
    return decodeBlech32(address);
  }
  return decodeBase58(address, network);
}
exports.decodeType = decodeType;
/**
 * A quick check used to verify if a string could be a valid confidential address.
 * @param address address to check.
 */
function isConfidential(address) {
  const type = decodeType(address);
  return isConfidentialAddressType(type);
}
exports.isConfidential = isConfidential;

}).call(this)}).call(this,require("buffer").Buffer)
},{"./networks":88,"./payments":91,"./script":101,"./types":106,"bech32":4,"blech32":30,"bs58check":33,"buffer":110}],80:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
exports.AssetHash = void 0;
class AssetHash {
  constructor(prefix, value) {
    this.prefix = prefix;
    this.value = value;
  }
  static fromHex(hex, isConfidential) {
    const prefix = isConfidential
      ? AssetHash.CONFIDENTIAL_ASSET_PREFIX
      : AssetHash.UNCONFIDENTIAL_ASSET_PREFIX;
    const value = Buffer.from(hex, 'hex').reverse();
    return new AssetHash(prefix, value);
  }
  static fromBytes(bytes) {
    if (bytes.length !== 1 + 32) {
      throw new Error('Invalid asset hash length');
    }
    const prefix = bytes.slice(0, 1);
    const value = bytes.slice(1);
    return new AssetHash(prefix, value);
  }
  get hex() {
    return reverseWithoutMutate(this.value).toString('hex');
  }
  get bytes() {
    return Buffer.concat([this.prefix, this.value]);
  }
}
exports.AssetHash = AssetHash;
AssetHash.CONFIDENTIAL_ASSET_PREFIX = Buffer.of(0x0a);
AssetHash.UNCONFIDENTIAL_ASSET_PREFIX = Buffer.of(0x01);
function reverseWithoutMutate(buf) {
  return Buffer.from(buf).reverse();
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":110}],81:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
exports.findScriptPath = exports.toHashTree = exports.tapLeafHash = exports.BIP341Factory = void 0;
const crypto_1 = require('./crypto');
const ecpair_1 = require('ecpair');
const bufferutils_1 = require('./bufferutils');
const LEAF_VERSION_TAPSCRIPT = 0xc4;
function BIP341Factory(ecc) {
  return {
    taprootSignKey: taprootSignKey(ecc),
    taprootSignScriptStack: taprootSignScriptStack(ecc),
    taprootOutputScript: taprootOutputScript(ecc),
  };
}
exports.BIP341Factory = BIP341Factory;
// hash TaprootLeaf object, could be use to identify a leaf in a MAST tree
function tapLeafHash(leaf) {
  const leafVersion = leaf.version || LEAF_VERSION_TAPSCRIPT;
  const script = Buffer.from(leaf.scriptHex, 'hex');
  const bufferWriter = bufferutils_1.BufferWriter.withCapacity(
    1 + (0, bufferutils_1.varSliceSize)(script),
  );
  bufferWriter.writeUInt8(leafVersion);
  bufferWriter.writeVarSlice(script);
  return (0, crypto_1.taggedHash)('TapLeaf/elements', bufferWriter.end());
}
exports.tapLeafHash = tapLeafHash;
// recursively build the Taproot tree from a ScriptTree structure
function toHashTree(leaves, withScriptHex = false) {
  switch (leaves.length) {
    case 0:
      return { hash: Buffer.alloc(32) };
    case 1:
      const leaf = leaves[0];
      const version = leaf.version || LEAF_VERSION_TAPSCRIPT;
      if ((version & 1) !== 0) {
        throw new Error('Invalid leaf version');
      }
      return {
        hash: tapLeafHash(leaf),
        scriptHex: withScriptHex ? leaf.scriptHex : undefined,
      };
    default:
      // 2 or more entries
      const middleIndex = Math.ceil(leaves.length / 2);
      const left = toHashTree(leaves.slice(0, middleIndex), withScriptHex);
      const right = toHashTree(leaves.slice(middleIndex), withScriptHex);
      let leftHash = left.hash;
      let rightHash = right.hash;
      // check if left is greater than right
      if (left.hash.compare(right.hash) > 0) {
        [leftHash, rightHash] = [rightHash, leftHash];
      }
      return {
        left,
        right,
        hash: (0, crypto_1.taggedHash)(
          'TapBranch/elements',
          Buffer.concat([leftHash, rightHash]),
        ),
      };
  }
}
exports.toHashTree = toHashTree;
/**
 * Given a MAST tree, it finds the path of a particular hash.
 * @param node - the root of the tree
 * @param hash - the hash to search for
 * @returns - and array of hashes representing the path, or an empty array if no pat is found
 */
function findScriptPath(node, hash) {
  if (node.left) {
    if (node.left.hash.equals(hash)) return node.right ? [node.right.hash] : [];
    const leftPath = findScriptPath(node.left, hash);
    if (leftPath.length)
      return node.right ? leftPath.concat([node.right.hash]) : leftPath;
  }
  if (node.right) {
    if (node.right.hash.equals(hash)) return node.left ? [node.left.hash] : [];
    const rightPath = findScriptPath(node.right, hash);
    if (rightPath.length)
      return node.left ? rightPath.concat([node.left.hash]) : rightPath;
  }
  return [];
}
exports.findScriptPath = findScriptPath;
function tweakPublicKey(publicKey, hash, ecc) {
  const XOnlyPubKey = publicKey.slice(1, 33);
  const toTweak = Buffer.concat([XOnlyPubKey, hash]);
  const tweakHash = (0, crypto_1.taggedHash)('TapTweak/elements', toTweak);
  const tweaked = ecc.xOnlyPointAddTweak(XOnlyPubKey, tweakHash);
  if (!tweaked) throw new Error('Invalid tweaked key');
  return tweaked;
}
// compute a segwit V1 output script
function taprootOutputScript(ecc) {
  return (internalPublicKey, tree) => {
    let treeHash = Buffer.alloc(0);
    if (tree) {
      treeHash = tree.hash;
    }
    const { xOnlyPubkey } = tweakPublicKey(internalPublicKey, treeHash, ecc);
    return Buffer.concat([Buffer.from([0x51, 0x20]), xOnlyPubkey]);
  };
}
/**
 * Compute the taproot part of the witness stack needed to spend a P2TR output via script path
 * TAPROOT_WITNESS = [SCRIPT, CONTROL_BLOCK]
 * WITNESS_STACK = [...INPUTS, TAPROOT_WITNESS] <- u need to add the script's inputs to the stack
 * @param internalPublicKey the taproot internal public key
 * @param leaf the leaf to use to sign the taproot coin
 * @param path the path to the leaf in the MAST tree see findScriptPath function
 */
function taprootSignScriptStack(ecc) {
  return (internalPublicKey, leaf, treeRootHash, path) => {
    const { parity } = tweakPublicKey(internalPublicKey, treeRootHash, ecc);
    const parityBit = Buffer.of(
      leaf.version || LEAF_VERSION_TAPSCRIPT + parity,
    );
    const control = Buffer.concat([
      parityBit,
      internalPublicKey.slice(1),
      ...path,
    ]);
    return [Buffer.from(leaf.scriptHex, 'hex'), control];
  };
}
// Order of the curve (N) - 1
const N_LESS_1 = Buffer.from(
  'fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140',
  'hex',
);
// 1 represented as 32 bytes BE
const ONE = Buffer.from(
  '0000000000000000000000000000000000000000000000000000000000000001',
  'hex',
);
// Compute the witness signature for a P2TR output (key path)
function taprootSignKey(ecc) {
  return (messageHash, key) => {
    const signingEcPair = (0, ecpair_1.ECPairFactory)(ecc).fromPrivateKey(key);
    const privateKey =
      signingEcPair.publicKey[0] === 2
        ? signingEcPair.privateKey
        : ecc.privateAdd(ecc.privateSub(N_LESS_1, key), ONE);
    const tweakHash = (0, crypto_1.taggedHash)(
      'TapTweak/elements',
      signingEcPair.publicKey.slice(1, 33),
    );
    const newPrivateKey = ecc.privateAdd(privateKey, tweakHash);
    if (newPrivateKey === null) throw new Error('Invalid Tweak');
    const signed = ecc.signSchnorr(
      messageHash,
      newPrivateKey,
      Buffer.alloc(32),
    );
    const ok = ecc.verifySchnorr(
      messageHash,
      (0, ecpair_1.ECPairFactory)(ecc)
        .fromPrivateKey(Buffer.from(newPrivateKey))
        .publicKey.slice(1),
      signed,
    );
    if (!ok) throw new Error('Invalid Signature');
    return Buffer.from(signed);
  };
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"./bufferutils":83,"./crypto":85,"buffer":110,"ecpair":37}],82:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';
// Reference https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki
// Format: 0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S]
// NOTE: SIGHASH byte ignored AND restricted, truncate before use
Object.defineProperty(exports, '__esModule', { value: true });
exports.encode = exports.decode = exports.check = void 0;
function check(buffer) {
  if (buffer.length < 8) return false;
  if (buffer.length > 72) return false;
  if (buffer[0] !== 0x30) return false;
  if (buffer[1] !== buffer.length - 2) return false;
  if (buffer[2] !== 0x02) return false;
  const lenR = buffer[3];
  if (lenR === 0) return false;
  if (5 + lenR >= buffer.length) return false;
  if (buffer[4 + lenR] !== 0x02) return false;
  const lenS = buffer[5 + lenR];
  if (lenS === 0) return false;
  if (6 + lenR + lenS !== buffer.length) return false;
  if (buffer[4] & 0x80) return false;
  if (lenR > 1 && buffer[4] === 0x00 && !(buffer[5] & 0x80)) return false;
  if (buffer[lenR + 6] & 0x80) return false;
  if (lenS > 1 && buffer[lenR + 6] === 0x00 && !(buffer[lenR + 7] & 0x80))
    return false;
  return true;
}
exports.check = check;
function decode(buffer) {
  if (buffer.length < 8) throw new Error('DER sequence length is too short');
  if (buffer.length > 72) throw new Error('DER sequence length is too long');
  if (buffer[0] !== 0x30) throw new Error('Expected DER sequence');
  if (buffer[1] !== buffer.length - 2)
    throw new Error('DER sequence length is invalid');
  if (buffer[2] !== 0x02) throw new Error('Expected DER integer');
  const lenR = buffer[3];
  if (lenR === 0) throw new Error('R length is zero');
  if (5 + lenR >= buffer.length) throw new Error('R length is too long');
  if (buffer[4 + lenR] !== 0x02) throw new Error('Expected DER integer (2)');
  const lenS = buffer[5 + lenR];
  if (lenS === 0) throw new Error('S length is zero');
  if (6 + lenR + lenS !== buffer.length) throw new Error('S length is invalid');
  if (buffer[4] & 0x80) throw new Error('R value is negative');
  if (lenR > 1 && buffer[4] === 0x00 && !(buffer[5] & 0x80))
    throw new Error('R value excessively padded');
  if (buffer[lenR + 6] & 0x80) throw new Error('S value is negative');
  if (lenS > 1 && buffer[lenR + 6] === 0x00 && !(buffer[lenR + 7] & 0x80))
    throw new Error('S value excessively padded');
  // non-BIP66 - extract R, S values
  return {
    r: buffer.slice(4, 4 + lenR),
    s: buffer.slice(6 + lenR),
  };
}
exports.decode = decode;
/*
 * Expects r and s to be positive DER integers.
 *
 * The DER format uses the most significant bit as a sign bit (& 0x80).
 * If the significant bit is set AND the integer is positive, a 0x00 is prepended.
 *
 * Examples:
 *
 *      0 =>     0x00
 *      1 =>     0x01
 *     -1 =>     0xff
 *    127 =>     0x7f
 *   -127 =>     0x81
 *    128 =>   0x0080
 *   -128 =>     0x80
 *    255 =>   0x00ff
 *   -255 =>   0xff01
 *  16300 =>   0x3fac
 * -16300 =>   0xc054
 *  62300 => 0x00f35c
 * -62300 => 0xff0ca4
 */
function encode(r, s) {
  const lenR = r.length;
  const lenS = s.length;
  if (lenR === 0) throw new Error('R length is zero');
  if (lenS === 0) throw new Error('S length is zero');
  if (lenR > 33) throw new Error('R length is too long');
  if (lenS > 33) throw new Error('S length is too long');
  if (r[0] & 0x80) throw new Error('R value is negative');
  if (s[0] & 0x80) throw new Error('S value is negative');
  if (lenR > 1 && r[0] === 0x00 && !(r[1] & 0x80))
    throw new Error('R value excessively padded');
  if (lenS > 1 && s[0] === 0x00 && !(s[1] & 0x80))
    throw new Error('S value excessively padded');
  const signature = Buffer.allocUnsafe(6 + lenR + lenS);
  // 0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S]
  signature[0] = 0x30;
  signature[1] = signature.length - 2;
  signature[2] = 0x02;
  signature[3] = r.length;
  r.copy(signature, 4);
  signature[4 + lenR] = 0x02;
  signature[5 + lenR] = s.length;
  s.copy(signature, 6 + lenR);
  return signature;
}
exports.encode = encode;

}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":110}],83:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';
var __createBinding =
  (this && this.__createBinding) ||
  (Object.create
    ? function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (
          !desc ||
          ('get' in desc ? !m.__esModule : desc.writable || desc.configurable)
        ) {
          desc = {
            enumerable: true,
            get: function() {
              return m[k];
            },
          };
        }
        Object.defineProperty(o, k2, desc);
      }
    : function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
      });
var __setModuleDefault =
  (this && this.__setModuleDefault) ||
  (Object.create
    ? function(o, v) {
        Object.defineProperty(o, 'default', { enumerable: true, value: v });
      }
    : function(o, v) {
        o['default'] = v;
      });
var __importStar =
  (this && this.__importStar) ||
  function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null)
      for (var k in mod)
        if (k !== 'default' && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
  };
Object.defineProperty(exports, '__esModule', { value: true });
exports.BufferReader = exports.BufferWriter = exports.cloneBuffer = exports.reverseBuffer = exports.writeUInt64LE = exports.readUInt64LE = exports.varSliceSize = exports.varuint = void 0;
const types = __importStar(require('./types'));
const { typeforce } = types;
const varuint = __importStar(require('varuint-bitcoin'));
exports.varuint = varuint;
const CONFIDENTIAL_COMMITMENT = 33; // default size of confidential commitments (i.e. asset, value, nonce)
const CONFIDENTIAL_VALUE = 9; // explicit size of confidential values
// https://github.com/feross/buffer/blob/master/index.js#L1127
function verifuint(value, max) {
  if (typeof value !== 'number')
    throw new Error('cannot write a non-number as a number');
  if (value < 0)
    throw new Error('specified a negative value for writing an unsigned value');
  if (value > max) throw new Error('RangeError: value out of range');
  if (Math.floor(value) !== value)
    throw new Error('value has a fractional component');
}
function varSliceSize(someScript) {
  const length = someScript.length;
  return varuint.encodingLength(length) + length;
}
exports.varSliceSize = varSliceSize;
function readUInt64LE(buffer, offset) {
  const a = buffer.readUInt32LE(offset);
  let b = buffer.readUInt32LE(offset + 4);
  b *= 0x100000000;
  verifuint(b + a, 0x001fffffffffffff);
  return b + a;
}
exports.readUInt64LE = readUInt64LE;
function writeUInt64LE(buffer, value, offset) {
  verifuint(value, 0x001fffffffffffff);
  buffer.writeInt32LE(value & -1, offset);
  buffer.writeUInt32LE(Math.floor(value / 0x100000000), offset + 4);
  return offset + 8;
}
exports.writeUInt64LE = writeUInt64LE;
function reverseBuffer(buffer) {
  if (buffer.length < 1) return buffer;
  let j = buffer.length - 1;
  let tmp = 0;
  for (let i = 0; i < buffer.length / 2; i++) {
    tmp = buffer[i];
    buffer[i] = buffer[j];
    buffer[j] = tmp;
    j--;
  }
  return buffer;
}
exports.reverseBuffer = reverseBuffer;
function cloneBuffer(buffer) {
  const clone = Buffer.allocUnsafe(buffer.length);
  buffer.copy(clone);
  return clone;
}
exports.cloneBuffer = cloneBuffer;
/**
 * Helper class for serialization of bitcoin data types into a pre-allocated buffer.
 */
class BufferWriter {
  constructor(buffer, offset = 0) {
    this.buffer = buffer;
    this.offset = offset;
    typeforce(types.tuple(types.Buffer, types.UInt32), [buffer, offset]);
  }
  static withCapacity(size) {
    return new BufferWriter(Buffer.alloc(size));
  }
  writeUInt8(i) {
    this.offset = this.buffer.writeUInt8(i, this.offset);
  }
  writeInt32(i) {
    this.offset = this.buffer.writeInt32LE(i, this.offset);
  }
  writeUInt32(i) {
    this.offset = this.buffer.writeUInt32LE(i, this.offset);
  }
  writeUInt64(i) {
    this.offset = writeUInt64LE(this.buffer, i, this.offset);
  }
  writeVarInt(i) {
    varuint.encode(i, this.buffer, this.offset);
    this.offset += varuint.encode.bytes;
  }
  writeSlice(slice) {
    if (this.buffer.length < this.offset + slice.length) {
      throw new Error('Cannot write slice out of bounds');
    }
    this.offset += slice.copy(this.buffer, this.offset);
  }
  writeVarSlice(slice) {
    this.writeVarInt(slice.length);
    this.writeSlice(slice);
  }
  writeVector(vector) {
    this.writeVarInt(vector.length);
    vector.forEach(buf => this.writeVarSlice(buf));
  }
  writeConfidentialInFields(input) {
    this.writeVarSlice(input.issuanceRangeProof || Buffer.alloc(0));
    this.writeVarSlice(input.inflationRangeProof || Buffer.alloc(0));
    this.writeVector(input.witness);
    this.writeVector(input.peginWitness || []);
  }
  writeConfidentialOutFields(output) {
    this.writeVarSlice(output.surjectionProof || Buffer.alloc(0));
    this.writeVarSlice(output.rangeProof || Buffer.alloc(0));
  }
  end() {
    if (this.buffer.length === this.offset) {
      return this.buffer;
    }
    throw new Error(`buffer size ${this.buffer.length}, offset ${this.offset}`);
  }
}
exports.BufferWriter = BufferWriter;
/**
 * Helper class for reading of bitcoin data types from a buffer.
 */
class BufferReader {
  constructor(buffer, offset = 0) {
    this.buffer = buffer;
    this.offset = offset;
    typeforce(types.tuple(types.Buffer, types.UInt32), [buffer, offset]);
  }
  readUInt8() {
    const result = this.buffer.readUInt8(this.offset);
    this.offset++;
    return result;
  }
  readInt32() {
    const result = this.buffer.readInt32LE(this.offset);
    this.offset += 4;
    return result;
  }
  readUInt32() {
    const result = this.buffer.readUInt32LE(this.offset);
    this.offset += 4;
    return result;
  }
  readUInt64() {
    const result = readUInt64LE(this.buffer, this.offset);
    this.offset += 8;
    return result;
  }
  readVarInt() {
    const vi = varuint.decode(this.buffer, this.offset);
    this.offset += varuint.decode.bytes;
    return vi;
  }
  readSlice(n) {
    if (this.buffer.length < this.offset + n) {
      throw new Error('Cannot read slice out of bounds');
    }
    const result = this.buffer.slice(this.offset, this.offset + n);
    this.offset += n;
    return result;
  }
  readVarSlice() {
    return this.readSlice(this.readVarInt());
  }
  readVector() {
    const count = this.readVarInt();
    const vector = [];
    for (let i = 0; i < count; i++) vector.push(this.readVarSlice());
    return vector;
  }
  // CConfidentialAsset size 33, prefixA 10, prefixB 11
  readConfidentialAsset() {
    const version = this.readUInt8();
    const versionBuffer = this.buffer.slice(this.offset - 1, this.offset);
    if (version === 1 || version === 0xff)
      return Buffer.concat([
        versionBuffer,
        this.readSlice(CONFIDENTIAL_COMMITMENT - 1),
      ]);
    else if (version === 10 || version === 11)
      return Buffer.concat([
        versionBuffer,
        this.readSlice(CONFIDENTIAL_COMMITMENT - 1),
      ]);
    return versionBuffer;
  }
  // CConfidentialNonce size 33, prefixA 2, prefixB 3
  readConfidentialNonce() {
    const version = this.readUInt8();
    const versionBuffer = this.buffer.slice(this.offset - 1, this.offset);
    if (version === 1 || version === 0xff)
      return Buffer.concat([
        versionBuffer,
        this.readSlice(CONFIDENTIAL_COMMITMENT - 1),
      ]);
    else if (version === 2 || version === 3)
      return Buffer.concat([
        versionBuffer,
        this.readSlice(CONFIDENTIAL_COMMITMENT - 1),
      ]);
    return versionBuffer;
  }
  // CConfidentialValue size 9, prefixA 8, prefixB 9
  readConfidentialValue() {
    const version = this.readUInt8();
    const versionBuffer = this.buffer.slice(this.offset - 1, this.offset);
    if (version === 1 || version === 0xff)
      return Buffer.concat([
        versionBuffer,
        this.readSlice(CONFIDENTIAL_VALUE - 1),
      ]);
    else if (version === 8 || version === 9)
      return Buffer.concat([
        versionBuffer,
        this.readSlice(CONFIDENTIAL_COMMITMENT - 1),
      ]);
    return versionBuffer;
  }
  readConfidentialInFields() {
    const issuanceRangeProof = this.readVarSlice();
    const inflationRangeProof = this.readVarSlice();
    const witness = this.readVector();
    const peginWitness = this.readVector();
    return {
      issuanceRangeProof,
      inflationRangeProof,
      witness,
      peginWitness,
    };
  }
  readConfidentialOutFields() {
    const surjectionProof = this.readVarSlice();
    const rangeProof = this.readVarSlice();
    return { surjectionProof, rangeProof };
  }
  readIssuance() {
    const issuanceNonce = this.readSlice(32);
    const issuanceEntropy = this.readSlice(32);
    const amount = this.readConfidentialValue();
    const inflation = this.readConfidentialValue();
    return {
      assetBlindingNonce: issuanceNonce,
      assetEntropy: issuanceEntropy,
      assetAmount: amount,
      tokenAmount: inflation,
    };
  }
}
exports.BufferReader = BufferReader;

}).call(this)}).call(this,require("buffer").Buffer)
},{"./types":106,"buffer":110,"varuint-bitcoin":77}],84:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';
var __createBinding =
  (this && this.__createBinding) ||
  (Object.create
    ? function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (
          !desc ||
          ('get' in desc ? !m.__esModule : desc.writable || desc.configurable)
        ) {
          desc = {
            enumerable: true,
            get: function() {
              return m[k];
            },
          };
        }
        Object.defineProperty(o, k2, desc);
      }
    : function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
      });
var __setModuleDefault =
  (this && this.__setModuleDefault) ||
  (Object.create
    ? function(o, v) {
        Object.defineProperty(o, 'default', { enumerable: true, value: v });
      }
    : function(o, v) {
        o['default'] = v;
      });
var __importStar =
  (this && this.__importStar) ||
  function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null)
      for (var k in mod)
        if (k !== 'default' && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
  };
var __importDefault =
  (this && this.__importDefault) ||
  function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
Object.defineProperty(exports, '__esModule', { value: true });
exports.isUnconfidentialValue = exports.satoshiToConfidentialValue = exports.confidentialValueToSatoshi = exports.surjectionProof = exports.rangeProof = exports.rangeProofWithNonceHash = exports.rangeProofInfo = exports.unblindOutputWithNonce = exports.unblindOutputWithKey = exports.assetCommitment = exports.valueCommitment = exports.valueBlindingFactor = void 0;
const bufferutils = __importStar(require('./bufferutils'));
const crypto = __importStar(require('./crypto'));
const secp256k1_zkp_1 = __importDefault(
  require('@vulpemventures/secp256k1-zkp'),
);
const secp256k1Promise = (0, secp256k1_zkp_1.default)();
async function nonceHash(pubkey, privkey) {
  const { ecdh } = await secp256k1Promise;
  return crypto.sha256(ecdh(pubkey, privkey));
}
async function valueBlindingFactor(
  inValues,
  outValues,
  inGenerators,
  outGenerators,
  inFactors,
  outFactors,
) {
  const { pedersen } = await secp256k1Promise;
  const values = inValues.concat(outValues);
  const nInputs = inValues.length;
  const generators = inGenerators.concat(outGenerators);
  const factors = inFactors.concat(outFactors);
  return pedersen.blindGeneratorBlindSum(values, nInputs, generators, factors);
}
exports.valueBlindingFactor = valueBlindingFactor;
async function valueCommitment(value, gen, factor) {
  const { generator, pedersen } = await secp256k1Promise;
  const generatorParsed = generator.parse(gen);
  const commit = pedersen.commit(factor, value, generatorParsed);
  return pedersen.commitSerialize(commit);
}
exports.valueCommitment = valueCommitment;
async function assetCommitment(asset, factor) {
  const { generator } = await secp256k1Promise;
  const gen = generator.generateBlinded(asset, factor);
  return generator.serialize(gen);
}
exports.assetCommitment = assetCommitment;
async function unblindOutputWithKey(out, blindingPrivKey) {
  const nonce = await nonceHash(out.nonce, blindingPrivKey);
  return unblindOutputWithNonce(out, nonce);
}
exports.unblindOutputWithKey = unblindOutputWithKey;
async function unblindOutputWithNonce(out, nonce) {
  const secp = await secp256k1Promise;
  const gen = secp.generator.parse(out.asset);
  const { value, blindFactor, message } = secp.rangeproof.rewind(
    out.value,
    out.rangeProof,
    nonce,
    gen,
    out.script,
  );
  return {
    value,
    asset: message.slice(0, 32),
    valueBlindingFactor: blindFactor,
    assetBlindingFactor: message.slice(32),
  };
}
exports.unblindOutputWithNonce = unblindOutputWithNonce;
async function rangeProofInfo(proof) {
  const { rangeproof } = await secp256k1Promise;
  const { exp, mantissa, minValue, maxValue } = rangeproof.info(proof);
  return {
    minValue: parseInt(minValue, 10),
    maxValue: parseInt(maxValue, 10),
    ctExp: exp,
    ctBits: parseInt(mantissa, 10),
  };
}
exports.rangeProofInfo = rangeProofInfo;
/**
 *  nonceHash from blinding key + ephemeral key and then rangeProof computation
 */
async function rangeProofWithNonceHash(
  value,
  blindingPubkey,
  ephemeralPrivkey,
  asset,
  assetBlindingFactor,
  valueBlindFactor,
  valueCommit,
  scriptPubkey,
  minValue,
  exp,
  minBits,
) {
  const nonce = await nonceHash(blindingPubkey, ephemeralPrivkey);
  return rangeProof(
    value,
    nonce,
    asset,
    assetBlindingFactor,
    valueBlindFactor,
    valueCommit,
    scriptPubkey,
    minValue,
    exp,
    minBits,
  );
}
exports.rangeProofWithNonceHash = rangeProofWithNonceHash;
/**
 *  rangeProof computation without nonceHash step.
 */
async function rangeProof(
  value,
  nonce,
  asset,
  assetBlindingFactor,
  valueBlindFactor,
  valueCommit,
  scriptPubkey,
  minValue,
  exp,
  minBits,
) {
  const { generator, pedersen, rangeproof } = await secp256k1Promise;
  const gen = generator.generateBlinded(asset, assetBlindingFactor);
  const message = Buffer.concat([asset, assetBlindingFactor]);
  const commit = pedersen.commitParse(valueCommit);
  const mv = minValue ? minValue : '1';
  const e = exp ? exp : 0;
  const mb = minBits ? minBits : 36;
  return rangeproof.sign(
    commit,
    valueBlindFactor,
    nonce,
    value,
    gen,
    mv,
    e,
    mb,
    message,
    scriptPubkey,
  );
}
exports.rangeProof = rangeProof;
async function surjectionProof(
  outputAsset,
  outputAssetBlindingFactor,
  inputAssets,
  inputAssetBlindingFactors,
  seed,
) {
  const { generator, surjectionproof } = await secp256k1Promise;
  const outputGenerator = generator.generateBlinded(
    outputAsset,
    outputAssetBlindingFactor,
  );
  const inputGenerators = inputAssets.map((v, i) =>
    generator.generateBlinded(v, inputAssetBlindingFactors[i]),
  );
  const nInputsToUse = inputAssets.length > 3 ? 3 : inputAssets.length;
  const maxIterations = 100;
  const init = surjectionproof.initialize(
    inputAssets,
    nInputsToUse,
    outputAsset,
    maxIterations,
    seed,
  );
  const proof = surjectionproof.generate(
    init.proof,
    inputGenerators,
    outputGenerator,
    init.inputIndex,
    inputAssetBlindingFactors[init.inputIndex],
    outputAssetBlindingFactor,
  );
  return surjectionproof.serialize(proof);
}
exports.surjectionProof = surjectionProof;
const CONFIDENTIAL_VALUE = 9; // explicit size of confidential values
function confidentialValueToSatoshi(value) {
  if (!isUnconfidentialValue(value)) {
    throw new Error(
      'Value must be unconfidential, length or the prefix are not valid',
    );
  }
  const reverseValueBuffer = Buffer.allocUnsafe(CONFIDENTIAL_VALUE - 1);
  value.slice(1, CONFIDENTIAL_VALUE).copy(reverseValueBuffer, 0);
  bufferutils.reverseBuffer(reverseValueBuffer);
  return bufferutils.readUInt64LE(reverseValueBuffer, 0);
}
exports.confidentialValueToSatoshi = confidentialValueToSatoshi;
function satoshiToConfidentialValue(amount) {
  const unconfPrefix = Buffer.allocUnsafe(1);
  const valueBuffer = Buffer.allocUnsafe(CONFIDENTIAL_VALUE - 1);
  unconfPrefix.writeUInt8(1, 0);
  bufferutils.writeUInt64LE(valueBuffer, amount, 0);
  return Buffer.concat([unconfPrefix, bufferutils.reverseBuffer(valueBuffer)]);
}
exports.satoshiToConfidentialValue = satoshiToConfidentialValue;
function isUnconfidentialValue(value) {
  return value.length === CONFIDENTIAL_VALUE && value.readUInt8(0) === 1;
}
exports.isUnconfidentialValue = isUnconfidentialValue;

}).call(this)}).call(this,require("buffer").Buffer)
},{"./bufferutils":83,"./crypto":85,"@vulpemventures/secp256k1-zkp":2,"buffer":110}],85:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';
var __importDefault =
  (this && this.__importDefault) ||
  function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
Object.defineProperty(exports, '__esModule', { value: true });
exports.taggedHash = exports.hash256 = exports.hash160 = exports.sha256 = exports.sha1 = exports.ripemd160 = void 0;
const create_hash_1 = __importDefault(require('create-hash'));
function ripemd160(buffer) {
  try {
    return (0, create_hash_1.default)('rmd160')
      .update(buffer)
      .digest();
  } catch (err) {
    return (0, create_hash_1.default)('ripemd160')
      .update(buffer)
      .digest();
  }
}
exports.ripemd160 = ripemd160;
function sha1(buffer) {
  return (0, create_hash_1.default)('sha1')
    .update(buffer)
    .digest();
}
exports.sha1 = sha1;
function sha256(buffer) {
  return (0, create_hash_1.default)('sha256')
    .update(buffer)
    .digest();
}
exports.sha256 = sha256;
function hash160(buffer) {
  return ripemd160(sha256(buffer));
}
exports.hash160 = hash160;
function hash256(buffer) {
  return sha256(sha256(buffer));
}
exports.hash256 = hash256;
const TAGS = [
  'BIP0340/challenge',
  'BIP0340/aux',
  'BIP0340/nonce',
  'TapLeaf',
  'TapLeaf/elements',
  'TapBranch/elements',
  'TapSighash',
  'TapSighash/elements',
  'TapTweak',
  'TapTweak/elements',
  'KeyAgg list',
  'KeyAgg coefficient',
];
/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */
const TAGGED_HASH_PREFIXES = Object.fromEntries(
  TAGS.map(tag => {
    const tagHash = sha256(Buffer.from(tag, 'utf-8'));
    return [tag, Buffer.concat([tagHash, tagHash])];
  }),
);
function taggedHash(prefix, data) {
  return sha256(Buffer.concat([TAGGED_HASH_PREFIXES[prefix], data]));
}
exports.taggedHash = taggedHash;

}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":110,"create-hash":35}],86:[function(require,module,exports){
'use strict';
var __createBinding =
  (this && this.__createBinding) ||
  (Object.create
    ? function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (
          !desc ||
          ('get' in desc ? !m.__esModule : desc.writable || desc.configurable)
        ) {
          desc = {
            enumerable: true,
            get: function() {
              return m[k];
            },
          };
        }
        Object.defineProperty(o, k2, desc);
      }
    : function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
      });
var __setModuleDefault =
  (this && this.__setModuleDefault) ||
  (Object.create
    ? function(o, v) {
        Object.defineProperty(o, 'default', { enumerable: true, value: v });
      }
    : function(o, v) {
        o['default'] = v;
      });
var __importStar =
  (this && this.__importStar) ||
  function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null)
      for (var k in mod)
        if (k !== 'default' && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
  };
var __exportStar =
  (this && this.__exportStar) ||
  function(m, exports) {
    for (var p in m)
      if (p !== 'default' && !Object.prototype.hasOwnProperty.call(exports, p))
        __createBinding(exports, m, p);
  };
Object.defineProperty(exports, '__esModule', { value: true });
exports.Transaction = exports.opcodes = exports.witnessStackToScriptWitness = exports.Psbt = exports.bip341 = exports.issuance = exports.confidential = exports.script = exports.payments = exports.networks = exports.crypto = exports.address = void 0;
const address = __importStar(require('./address'));
exports.address = address;
const confidential = __importStar(require('./confidential'));
exports.confidential = confidential;
const crypto = __importStar(require('./crypto'));
exports.crypto = crypto;
const networks = __importStar(require('./networks'));
exports.networks = networks;
const payments = __importStar(require('./payments'));
exports.payments = payments;
const script = __importStar(require('./script'));
exports.script = script;
const issuance = __importStar(require('./issuance'));
exports.issuance = issuance;
const bip341 = __importStar(require('./bip341'));
exports.bip341 = bip341;
__exportStar(require('./asset'), exports);
var psbt_1 = require('./psbt');
Object.defineProperty(exports, 'Psbt', {
  enumerable: true,
  get: function() {
    return psbt_1.Psbt;
  },
});
Object.defineProperty(exports, 'witnessStackToScriptWitness', {
  enumerable: true,
  get: function() {
    return psbt_1.witnessStackToScriptWitness;
  },
});
var ops_1 = require('./ops');
Object.defineProperty(exports, 'opcodes', {
  enumerable: true,
  get: function() {
    return ops_1.OPS;
  },
});
var transaction_1 = require('./transaction');
Object.defineProperty(exports, 'Transaction', {
  enumerable: true,
  get: function() {
    return transaction_1.Transaction;
  },
});

},{"./address":79,"./asset":80,"./bip341":81,"./confidential":84,"./crypto":85,"./issuance":87,"./networks":88,"./ops":89,"./payments":91,"./psbt":99,"./script":101,"./transaction":105}],87:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';
var __createBinding =
  (this && this.__createBinding) ||
  (Object.create
    ? function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (
          !desc ||
          ('get' in desc ? !m.__esModule : desc.writable || desc.configurable)
        ) {
          desc = {
            enumerable: true,
            get: function() {
              return m[k];
            },
          };
        }
        Object.defineProperty(o, k2, desc);
      }
    : function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
      });
var __setModuleDefault =
  (this && this.__setModuleDefault) ||
  (Object.create
    ? function(o, v) {
        Object.defineProperty(o, 'default', { enumerable: true, value: v });
      }
    : function(o, v) {
        o['default'] = v;
      });
var __importStar =
  (this && this.__importStar) ||
  function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null)
      for (var k in mod)
        if (k !== 'default' && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
  };
Object.defineProperty(exports, '__esModule', { value: true });
exports.amountWithPrecisionToSatoshis = exports.calculateReissuanceToken = exports.calculateAsset = exports.issuanceEntropyFromInput = exports.generateEntropy = exports.isReissuance = exports.newIssuance = exports.hashContract = exports.validateIssuanceContract = exports.hasTokenAmount = void 0;
const bufferutils_1 = require('./bufferutils');
const confidential_1 = require('./confidential');
const bcrypto = __importStar(require('./crypto'));
const sha256d_1 = require('./sha256d');
/**
 * returns true if the issuance's token amount is not 0x00 or null buffer.
 * @param issuance issuance to test
 */
function hasTokenAmount(issuance) {
  if (issuance.tokenAmount && issuance.tokenAmount.length > 1) return true;
  return false;
}
exports.hasTokenAmount = hasTokenAmount;
/**
 * Checks if a contract given as parameter is valid or not.
 * @param contract contract to validate.
 */
function validateIssuanceContract(contract) {
  const precisionIsValid = contract.precision >= 0 && contract.precision <= 8;
  return precisionIsValid;
}
exports.validateIssuanceContract = validateIssuanceContract;
/**
 * Returns the SHA256 value of the JSON encoded Issuance contract.
 * @param contract the contract to digest.
 */
function hashContract(contract) {
  if (!validateIssuanceContract(contract))
    throw new Error('Invalid asset contract');
  const sortedKeys = Object.keys(contract).sort();
  const sortedContract = sortedKeys.reduce(
    (obj, key) => ({ ...obj, [key]: contract[key] }),
    {},
  );
  return bcrypto
    .sha256(Buffer.from(JSON.stringify(sortedContract)))
    .slice()
    .reverse();
}
exports.hashContract = hashContract;
/**
 * Returns an unblinded Issuance object for issuance transaction input.
 * @param assetSats the number of asset to issue.
 * @param tokenSats the number of token to issue.
 * @param contract the asset ricarding contract of the issuance.
 */
function newIssuance(assetSats, tokenSats, contract) {
  if (assetSats < 0) throw new Error('Invalid asset amount');
  if (tokenSats < 0) throw new Error('Invalid token amount');
  const contractHash = contract ? hashContract(contract) : Buffer.alloc(32);
  const issuanceObject = {
    assetAmount:
      assetSats === 0
        ? Buffer.of(0x00)
        : (0, confidential_1.satoshiToConfidentialValue)(assetSats),
    tokenAmount:
      tokenSats === 0
        ? Buffer.of(0x00)
        : (0, confidential_1.satoshiToConfidentialValue)(tokenSats),
    assetBlindingNonce: Buffer.alloc(32),
    // in case of issuance, the asset entropy = the contract hash.
    assetEntropy: contractHash,
  };
  return issuanceObject;
}
exports.newIssuance = newIssuance;
function isReissuance(issuance) {
  return !issuance.assetBlindingNonce.equals(Buffer.alloc(32));
}
exports.isReissuance = isReissuance;
/**
 * Generate the entropy.
 * @param outPoint the prevout point used to compute the entropy.
 * @param contractHash the 32 bytes contract hash.
 */
function generateEntropy(outPoint, contractHash = Buffer.alloc(32)) {
  if (outPoint.txHash.length !== 32) {
    throw new Error('Invalid txHash length');
  }
  const tBuffer = Buffer.allocUnsafe(36);
  const s = new bufferutils_1.BufferWriter(tBuffer, 0);
  s.writeSlice(outPoint.txHash);
  s.writeInt32(outPoint.vout);
  const prevoutHash = bcrypto.hash256(s.buffer);
  const concatened = Buffer.concat([prevoutHash, contractHash]);
  return (0, sha256d_1.sha256Midstate)(concatened);
}
exports.generateEntropy = generateEntropy;
/**
 * compute entropy from an input with issuance.
 * @param input reissuance or issuance input.
 */
function issuanceEntropyFromInput(input) {
  if (!input.issuance) throw new Error('input does not contain issuance data');
  return isReissuance(input.issuance)
    ? input.issuance.assetEntropy
    : generateEntropy(
        { txHash: input.hash, vout: input.index },
        input.issuance.assetEntropy,
      );
}
exports.issuanceEntropyFromInput = issuanceEntropyFromInput;
/**
 * calculate the asset tag from a given entropy.
 * @param entropy the entropy used to compute the asset tag.
 */
function calculateAsset(entropy) {
  if (entropy.length !== 32) throw new Error('Invalid entropy length');
  const kZero = Buffer.alloc(32);
  return (0, sha256d_1.sha256Midstate)(Buffer.concat([entropy, kZero]));
}
exports.calculateAsset = calculateAsset;
/**
 * Compute the reissuance token.
 * @param entropy the entropy used to compute the reissuance token.
 * @param confidential true if confidential.
 */
function calculateReissuanceToken(entropy, confidential = false) {
  if (entropy.length !== 32) throw new Error('Invalid entropy length');
  return (0, sha256d_1.sha256Midstate)(
    Buffer.concat([
      entropy,
      Buffer.of(getTokenFlag(confidential) + 1),
      Buffer.alloc(31),
    ]),
  );
}
exports.calculateReissuanceToken = calculateReissuanceToken;
function getTokenFlag(confidential) {
  if (confidential) return 1;
  return 0;
}
/**
 * converts asset amount to satoshis.
 * satoshis = assetAmount * 10^precision
 * @param assetAmount the asset amount.
 * @param precision the precision, 8 by default (like L-BTC).
 */
function amountWithPrecisionToSatoshis(assetAmount, precision = 8) {
  return Math.pow(10, precision) * assetAmount;
}
exports.amountWithPrecisionToSatoshis = amountWithPrecisionToSatoshis;

}).call(this)}).call(this,require("buffer").Buffer)
},{"./bufferutils":83,"./confidential":84,"./crypto":85,"./sha256d":104,"buffer":110}],88:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
exports.testnet = exports.regtest = exports.liquid = void 0;
const strToGenesisHash = str => Buffer.from(str, 'hex').reverse();
const RegtestGenesisBlockHash = strToGenesisHash(
  '00902a6b70c2ca83b5d9c815d96a0e2f4202179316970d14ea1847dae5b1ca21',
);
const TestnetGenesisBlockHash = strToGenesisHash(
  'a771da8e52ee6ad581ed1e9a99825e5b3b7992225534eaa2ae23244fe26ab1c1',
);
const LiquidGenesisBlockHash = strToGenesisHash(
  '1466275836220db2944ca059a3a10ef6fd2ea684b0688d2c379296888a206003',
);
exports.liquid = {
  messagePrefix: '\x18Liquid Signed Message:\n',
  bech32: 'ex',
  blech32: 'lq',
  bip32: {
    public: 0x0488b21e,
    private: 0x0488ade4,
  },
  pubKeyHash: 57,
  scriptHash: 39,
  wif: 0x80,
  confidentialPrefix: 12,
  assetHash: '6f0279e9ed041c3d710a9f57d0c02928416460c4b722ae3457a11eec381c526d',
  genesisBlockHash: LiquidGenesisBlockHash,
};
exports.regtest = {
  messagePrefix: '\x18Liquid Signed Message:\n',
  bech32: 'ert',
  blech32: 'el',
  bip32: {
    public: 0x043587cf,
    private: 0x04358394,
  },
  pubKeyHash: 235,
  scriptHash: 75,
  wif: 0xef,
  confidentialPrefix: 4,
  assetHash: '5ac9f65c0efcc4775e0baec4ec03abdde22473cd3cf33c0419ca290e0751b225',
  genesisBlockHash: RegtestGenesisBlockHash,
};
exports.testnet = {
  ...exports.regtest,
  bech32: 'tex',
  blech32: 'tlq',
  pubKeyHash: 36,
  scriptHash: 19,
  confidentialPrefix: 23,
  assetHash: '144c654344aa716d6f3abcc1ca90e5641e4e2a7f633bc09fe3baf64585819a49',
  genesisBlockHash: TestnetGenesisBlockHash,
};

}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":110}],89:[function(require,module,exports){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
exports.REVERSE_OPS = exports.OPS = void 0;
const OPS = {
  // push value
  OP_FALSE: 0x00,
  OP_0: 0x00,
  OP_PUSHDATA1: 0x4c,
  OP_PUSHDATA2: 0x4d,
  OP_PUSHDATA4: 0x4e,
  OP_1NEGATE: 0x4f,
  OP_RESERVED: 0x50,
  OP_TRUE: 0x51,
  OP_1: 0x51,
  OP_2: 0x52,
  OP_3: 0x53,
  OP_4: 0x54,
  OP_5: 0x55,
  OP_6: 0x56,
  OP_7: 0x57,
  OP_8: 0x58,
  OP_9: 0x59,
  OP_10: 0x5a,
  OP_11: 0x5b,
  OP_12: 0x5c,
  OP_13: 0x5d,
  OP_14: 0x5e,
  OP_15: 0x5f,
  OP_16: 0x60,
  // control
  OP_NOP: 0x61,
  OP_VER: 0x62,
  OP_IF: 0x63,
  OP_NOTIF: 0x64,
  OP_VERIF: 0x65,
  OP_VERNOTIF: 0x66,
  OP_ELSE: 0x67,
  OP_ENDIF: 0x68,
  OP_VERIFY: 0x69,
  OP_RETURN: 0x6a,
  // stack ops
  OP_TOALTSTACK: 0x6b,
  OP_FROMALTSTACK: 0x6c,
  OP_2DROP: 0x6d,
  OP_2DUP: 0x6e,
  OP_3DUP: 0x6f,
  OP_2OVER: 0x70,
  OP_2ROT: 0x71,
  OP_2SWAP: 0x72,
  OP_IFDUP: 0x73,
  OP_DEPTH: 0x74,
  OP_DROP: 0x75,
  OP_DUP: 0x76,
  OP_NIP: 0x77,
  OP_OVER: 0x78,
  OP_PICK: 0x79,
  OP_ROLL: 0x7a,
  OP_ROT: 0x7b,
  OP_SWAP: 0x7c,
  OP_TUCK: 0x7d,
  // splice ops
  OP_CAT: 0x7e,
  OP_SUBSTR: 0x7f,
  OP_SUBSTR_LAZY: 0xc3,
  OP_LEFT: 0x80,
  OP_RIGHT: 0x81,
  OP_SIZE: 0x82,
  // bit logic
  OP_INVERT: 0x83,
  OP_AND: 0x84,
  OP_OR: 0x85,
  OP_XOR: 0x86,
  OP_EQUAL: 0x87,
  OP_EQUALVERIFY: 0x88,
  OP_RESERVED1: 0x89,
  OP_RESERVED2: 0x8a,
  // numeric
  OP_1ADD: 0x8b,
  OP_1SUB: 0x8c,
  OP_2MUL: 0x8d,
  OP_2DIV: 0x8e,
  OP_NEGATE: 0x8f,
  OP_ABS: 0x90,
  OP_NOT: 0x91,
  OP_0NOTEQUAL: 0x92,
  OP_ADD: 0x93,
  OP_SUB: 0x94,
  OP_MUL: 0x95,
  OP_DIV: 0x96,
  OP_MOD: 0x97,
  OP_LSHIFT: 0x98,
  OP_RSHIFT: 0x99,
  OP_BOOLAND: 0x9a,
  OP_BOOLOR: 0x9b,
  OP_NUMEQUAL: 0x9c,
  OP_NUMEQUALVERIFY: 0x9d,
  OP_NUMNOTEQUAL: 0x9e,
  OP_LESSTHAN: 0x9f,
  OP_GREATERTHAN: 0xa0,
  OP_LESSTHANOREQUAL: 0xa1,
  OP_GREATERTHANOREQUAL: 0xa2,
  OP_MIN: 0xa3,
  OP_MAX: 0xa4,
  OP_WITHIN: 0xa5,
  // crypto
  OP_RIPEMD160: 0xa6,
  OP_SHA1: 0xa7,
  OP_SHA256: 0xa8,
  OP_HASH160: 0xa9,
  OP_HASH256: 0xaa,
  OP_CODESEPARATOR: 0xab,
  OP_CHECKSIG: 0xac,
  OP_CHECKSIGVERIFY: 0xad,
  OP_CHECKMULTISIG: 0xae,
  OP_CHECKMULTISIGVERIFY: 0xaf,
  OP_DETERMINISTICRANDOM: 0xc0,
  OP_CHECKSIGFROMSTACK: 0xc1,
  OP_CHECKSIGFROMSTACKVERIFY: 0xc2,
  // expansion
  OP_NOP1: 0xb0,
  OP_CHECKLOCKTIMEVERIFY: 0xb1,
  OP_NOP2: 0xb1,
  OP_CHECKSEQUENCEVERIFY: 0xb2,
  OP_NOP3: 0xb2,
  OP_NOP4: 0xb3,
  OP_NOP5: 0xb4,
  OP_NOP6: 0xb5,
  OP_NOP7: 0xb6,
  OP_NOP8: 0xb7,
  OP_NOP9: 0xb8,
  OP_NOP10: 0xb9,
  // Elements: Tapscript (Streaming sha2 opcodes)
  OP_SHA256INITIALIZE: 0xc4,
  OP_SHA256UPDATE: 0xc5,
  OP_SHA256FINALIZE: 0xc6,
  // Introspection opcodes
  // inputs
  OP_INSPECTINPUTOUTPOINT: 0xc7,
  OP_INSPECTINPUTASSET: 0xc8,
  OP_INSPECTINPUTVALUE: 0xc9,
  OP_INSPECTINPUTSCRIPTPUBKEY: 0xca,
  OP_INSPECTINPUTSEQUENCE: 0xcb,
  OP_INSPECTINPUTISSUANCE: 0xcc,
  // current index
  OP_PUSHCURRENTINPUTINDEX: 0xcd,
  // outputs
  OP_INSPECTOUTPUTASSET: 0xce,
  OP_INSPECTOUTPUTVALUE: 0xcf,
  OP_INSPECTOUTPUTNONCE: 0xd0,
  OP_INSPECTOUTPUTSCRIPTPUBKEY: 0xd1,
  // transaction
  OP_INSPECTVERSION: 0xd2,
  OP_INSPECTLOCKTIME: 0xd3,
  OP_INSPECTNUMINPUTS: 0xd4,
  OP_INSPECTNUMOUTPUTS: 0xd5,
  OP_TXWEIGHT: 0xd6,
  // Arithmetic opcodes
  OP_ADD64: 0xd7,
  OP_SUB64: 0xd8,
  OP_MUL64: 0xd9,
  OP_DIV64: 0xda,
  OP_NEG64: 0xdb,
  OP_LESSTHAN64: 0xdc,
  OP_LESSTHANOREQUAL64: 0xdd,
  OP_GREATERTHAN64: 0xde,
  OP_GREATERTHANOREQUAL64: 0xdf,
  // Conversion opcodes
  OP_SCRIPTNUMTOLE64: 0xe0,
  OP_LE64TOSCRIPTNUM: 0xe1,
  OP_LE32TOLE64: 0xe2,
  // Crypto opcodes
  OP_ECMULSCALARVERIFY: 0xe3,
  OP_TWEAKVERIFY: 0xe4,
  OP_PUBKEYHASH: 253,
  OP_PUBKEY: 254,
  OP_INVALIDOPCODE: 255,
};
exports.OPS = OPS;
const REVERSE_OPS = {};
exports.REVERSE_OPS = REVERSE_OPS;
for (const op of Object.keys(OPS)) {
  const code = OPS[op];
  REVERSE_OPS[code] = op;
}

},{}],90:[function(require,module,exports){
'use strict';
var __createBinding =
  (this && this.__createBinding) ||
  (Object.create
    ? function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (
          !desc ||
          ('get' in desc ? !m.__esModule : desc.writable || desc.configurable)
        ) {
          desc = {
            enumerable: true,
            get: function() {
              return m[k];
            },
          };
        }
        Object.defineProperty(o, k2, desc);
      }
    : function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
      });
var __setModuleDefault =
  (this && this.__setModuleDefault) ||
  (Object.create
    ? function(o, v) {
        Object.defineProperty(o, 'default', { enumerable: true, value: v });
      }
    : function(o, v) {
        o['default'] = v;
      });
var __importStar =
  (this && this.__importStar) ||
  function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null)
      for (var k in mod)
        if (k !== 'default' && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
  };
Object.defineProperty(exports, '__esModule', { value: true });
exports.p2data = void 0;
const networks_1 = require('../networks');
const bscript = __importStar(require('../script'));
const types_1 = require('../types');
const lazy = __importStar(require('./lazy'));
const OPS = bscript.OPS;
function stacksEqual(a, b) {
  if (a.length !== b.length) return false;
  return a.every((x, i) => {
    return x.equals(b[i]);
  });
}
// output: OP_RETURN ...
function p2data(a, opts) {
  if (!a.data && !a.output) throw new TypeError('Not enough data');
  opts = Object.assign({ validate: true }, opts || {});
  (0, types_1.typeforce)(
    {
      network: types_1.typeforce.maybe(types_1.typeforce.Object),
      output: types_1.typeforce.maybe(types_1.typeforce.Buffer),
      data: types_1.typeforce.maybe(
        types_1.typeforce.arrayOf(types_1.typeforce.Buffer),
      ),
    },
    a,
  );
  const network = a.network || networks_1.liquid;
  const o = { name: 'embed', network };
  lazy.prop(o, 'output', () => {
    if (!a.data) return;
    return bscript.compile([OPS.OP_RETURN].concat(a.data));
  });
  lazy.prop(o, 'data', () => {
    if (!a.output) return;
    return bscript.decompile(a.output).slice(1);
  });
  // extended validation
  if (opts.validate) {
    if (a.output) {
      const chunks = bscript.decompile(a.output);
      if (chunks[0] !== OPS.OP_RETURN) throw new TypeError('Output is invalid');
      if (!chunks.slice(1).every(types_1.typeforce.Buffer))
        throw new TypeError('Output is invalid');
      if (a.data && !stacksEqual(a.data, o.data))
        throw new TypeError('Data mismatch');
    }
  }
  return Object.assign(o, a);
}
exports.p2data = p2data;

},{"../networks":88,"../script":101,"../types":106,"./lazy":92}],91:[function(require,module,exports){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
exports.p2wsh = exports.p2wpkh = exports.p2sh = exports.p2pkh = exports.p2pk = exports.p2ms = exports.embed = void 0;
const embed_1 = require('./embed');
Object.defineProperty(exports, 'embed', {
  enumerable: true,
  get: function() {
    return embed_1.p2data;
  },
});
const p2ms_1 = require('./p2ms');
Object.defineProperty(exports, 'p2ms', {
  enumerable: true,
  get: function() {
    return p2ms_1.p2ms;
  },
});
const p2pk_1 = require('./p2pk');
Object.defineProperty(exports, 'p2pk', {
  enumerable: true,
  get: function() {
    return p2pk_1.p2pk;
  },
});
const p2pkh_1 = require('./p2pkh');
Object.defineProperty(exports, 'p2pkh', {
  enumerable: true,
  get: function() {
    return p2pkh_1.p2pkh;
  },
});
const p2sh_1 = require('./p2sh');
Object.defineProperty(exports, 'p2sh', {
  enumerable: true,
  get: function() {
    return p2sh_1.p2sh;
  },
});
const p2wpkh_1 = require('./p2wpkh');
Object.defineProperty(exports, 'p2wpkh', {
  enumerable: true,
  get: function() {
    return p2wpkh_1.p2wpkh;
  },
});
const p2wsh_1 = require('./p2wsh');
Object.defineProperty(exports, 'p2wsh', {
  enumerable: true,
  get: function() {
    return p2wsh_1.p2wsh;
  },
});
// TODO
// witness commitment

},{"./embed":90,"./p2ms":93,"./p2pk":94,"./p2pkh":95,"./p2sh":96,"./p2wpkh":97,"./p2wsh":98}],92:[function(require,module,exports){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
exports.value = exports.prop = void 0;
function prop(object, name, f) {
  Object.defineProperty(object, name, {
    configurable: true,
    enumerable: true,
    get() {
      const _value = f.call(this);
      this[name] = _value;
      return _value;
    },
    set(_value) {
      Object.defineProperty(this, name, {
        configurable: true,
        enumerable: true,
        value: _value,
        writable: true,
      });
    },
  });
}
exports.prop = prop;
function value(f) {
  let _value;
  return () => {
    if (_value !== undefined) return _value;
    _value = f();
    return _value;
  };
}
exports.value = value;

},{}],93:[function(require,module,exports){
'use strict';
var __createBinding =
  (this && this.__createBinding) ||
  (Object.create
    ? function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (
          !desc ||
          ('get' in desc ? !m.__esModule : desc.writable || desc.configurable)
        ) {
          desc = {
            enumerable: true,
            get: function() {
              return m[k];
            },
          };
        }
        Object.defineProperty(o, k2, desc);
      }
    : function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
      });
var __setModuleDefault =
  (this && this.__setModuleDefault) ||
  (Object.create
    ? function(o, v) {
        Object.defineProperty(o, 'default', { enumerable: true, value: v });
      }
    : function(o, v) {
        o['default'] = v;
      });
var __importStar =
  (this && this.__importStar) ||
  function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null)
      for (var k in mod)
        if (k !== 'default' && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
  };
Object.defineProperty(exports, '__esModule', { value: true });
exports.p2ms = void 0;
const networks_1 = require('../networks');
const bscript = __importStar(require('../script'));
const types_1 = require('../types');
const lazy = __importStar(require('./lazy'));
const OPS = bscript.OPS;
const OP_INT_BASE = OPS.OP_RESERVED; // OP_1 - 1
function stacksEqual(a, b) {
  if (a.length !== b.length) return false;
  return a.every((x, i) => {
    return x.equals(b[i]);
  });
}
// input: OP_0 [signatures ...]
// output: m [pubKeys ...] n OP_CHECKMULTISIG
function p2ms(a, opts) {
  if (
    !a.input &&
    !a.output &&
    !(a.pubkeys && a.m !== undefined) &&
    !a.signatures
  )
    throw new TypeError('Not enough data');
  opts = Object.assign({ validate: true }, opts || {});
  function isAcceptableSignature(x) {
    return (
      bscript.isCanonicalScriptSignature(x) ||
      (opts.allowIncomplete && x === OPS.OP_0) !== undefined
    );
  }
  (0, types_1.typeforce)(
    {
      network: types_1.typeforce.maybe(types_1.typeforce.Object),
      m: types_1.typeforce.maybe(types_1.typeforce.Number),
      n: types_1.typeforce.maybe(types_1.typeforce.Number),
      output: types_1.typeforce.maybe(types_1.typeforce.Buffer),
      pubkeys: types_1.typeforce.maybe(
        types_1.typeforce.arrayOf(types_1.isPoint),
      ),
      signatures: types_1.typeforce.maybe(
        types_1.typeforce.arrayOf(isAcceptableSignature),
      ),
      input: types_1.typeforce.maybe(types_1.typeforce.Buffer),
    },
    a,
  );
  const network = a.network || networks_1.liquid;
  const o = { network };
  let chunks = [];
  let decoded = false;
  function decode(output) {
    if (decoded) return;
    decoded = true;
    chunks = bscript.decompile(output);
    o.m = chunks[0] - OP_INT_BASE;
    o.n = chunks[chunks.length - 2] - OP_INT_BASE;
    o.pubkeys = chunks.slice(1, -2);
  }
  lazy.prop(o, 'output', () => {
    if (!a.m) return;
    if (!o.n) return;
    if (!a.pubkeys) return;
    return bscript.compile(
      [].concat(
        OP_INT_BASE + a.m,
        a.pubkeys,
        OP_INT_BASE + o.n,
        OPS.OP_CHECKMULTISIG,
      ),
    );
  });
  lazy.prop(o, 'm', () => {
    if (!o.output) return;
    decode(o.output);
    return o.m;
  });
  lazy.prop(o, 'n', () => {
    if (!o.pubkeys) return;
    return o.pubkeys.length;
  });
  lazy.prop(o, 'pubkeys', () => {
    if (!a.output) return;
    decode(a.output);
    return o.pubkeys;
  });
  lazy.prop(o, 'signatures', () => {
    if (!a.input) return;
    return bscript.decompile(a.input).slice(1);
  });
  lazy.prop(o, 'input', () => {
    if (!a.signatures) return;
    return bscript.compile([OPS.OP_0].concat(a.signatures));
  });
  lazy.prop(o, 'witness', () => {
    if (!o.input) return;
    return [];
  });
  lazy.prop(o, 'name', () => {
    if (!o.m || !o.n) return;
    return `p2ms(${o.m} of ${o.n})`;
  });
  // extended validation
  if (opts.validate) {
    if (a.output) {
      decode(a.output);
      if (!types_1.typeforce.Number(chunks[0]))
        throw new TypeError('Output is invalid');
      if (!types_1.typeforce.Number(chunks[chunks.length - 2]))
        throw new TypeError('Output is invalid');
      if (chunks[chunks.length - 1] !== OPS.OP_CHECKMULTISIG)
        throw new TypeError('Output is invalid');
      if (o.m <= 0 || o.n > 16 || o.m > o.n || o.n !== chunks.length - 3)
        throw new TypeError('Output is invalid');
      if (!o.pubkeys.every(x => (0, types_1.isPoint)(x)))
        throw new TypeError('Output is invalid');
      if (a.m !== undefined && a.m !== o.m) throw new TypeError('m mismatch');
      if (a.n !== undefined && a.n !== o.n) throw new TypeError('n mismatch');
      if (a.pubkeys && !stacksEqual(a.pubkeys, o.pubkeys))
        throw new TypeError('Pubkeys mismatch');
    }
    if (a.pubkeys) {
      if (a.n !== undefined && a.n !== a.pubkeys.length)
        throw new TypeError('Pubkey count mismatch');
      o.n = a.pubkeys.length;
      if (o.n < o.m) throw new TypeError('Pubkey count cannot be less than m');
    }
    if (a.signatures) {
      if (a.signatures.length < o.m)
        throw new TypeError('Not enough signatures provided');
      if (a.signatures.length > o.m)
        throw new TypeError('Too many signatures provided');
    }
    if (a.input) {
      if (a.input[0] !== OPS.OP_0) throw new TypeError('Input is invalid');
      if (
        o.signatures.length === 0 ||
        !o.signatures.every(isAcceptableSignature)
      )
        throw new TypeError('Input has invalid signature(s)');
      if (a.signatures && !stacksEqual(a.signatures, o.signatures))
        throw new TypeError('Signature mismatch');
      if (a.m !== undefined && a.m !== a.signatures.length)
        throw new TypeError('Signature count mismatch');
    }
  }
  return Object.assign(o, a);
}
exports.p2ms = p2ms;

},{"../networks":88,"../script":101,"../types":106,"./lazy":92}],94:[function(require,module,exports){
'use strict';
var __createBinding =
  (this && this.__createBinding) ||
  (Object.create
    ? function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (
          !desc ||
          ('get' in desc ? !m.__esModule : desc.writable || desc.configurable)
        ) {
          desc = {
            enumerable: true,
            get: function() {
              return m[k];
            },
          };
        }
        Object.defineProperty(o, k2, desc);
      }
    : function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
      });
var __setModuleDefault =
  (this && this.__setModuleDefault) ||
  (Object.create
    ? function(o, v) {
        Object.defineProperty(o, 'default', { enumerable: true, value: v });
      }
    : function(o, v) {
        o['default'] = v;
      });
var __importStar =
  (this && this.__importStar) ||
  function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null)
      for (var k in mod)
        if (k !== 'default' && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
  };
Object.defineProperty(exports, '__esModule', { value: true });
exports.p2pk = void 0;
const networks_1 = require('../networks');
const bscript = __importStar(require('../script'));
const types_1 = require('../types');
const lazy = __importStar(require('./lazy'));
const OPS = bscript.OPS;
// input: {signature}
// output: {pubKey} OP_CHECKSIG
function p2pk(a, opts) {
  if (!a.input && !a.output && !a.pubkey && !a.input && !a.signature)
    throw new TypeError('Not enough data');
  opts = Object.assign({ validate: true }, opts || {});
  (0, types_1.typeforce)(
    {
      network: types_1.typeforce.maybe(types_1.typeforce.Object),
      output: types_1.typeforce.maybe(types_1.typeforce.Buffer),
      pubkey: types_1.typeforce.maybe(types_1.isPoint),
      signature: types_1.typeforce.maybe(bscript.isCanonicalScriptSignature),
      input: types_1.typeforce.maybe(types_1.typeforce.Buffer),
    },
    a,
  );
  const _chunks = lazy.value(() => {
    return bscript.decompile(a.input);
  });
  const network = a.network || networks_1.liquid;
  const o = { name: 'p2pk', network };
  lazy.prop(o, 'output', () => {
    if (!a.pubkey) return;
    return bscript.compile([a.pubkey, OPS.OP_CHECKSIG]);
  });
  lazy.prop(o, 'pubkey', () => {
    if (!a.output) return;
    return a.output.slice(1, -1);
  });
  lazy.prop(o, 'signature', () => {
    if (!a.input) return;
    return _chunks()[0];
  });
  lazy.prop(o, 'input', () => {
    if (!a.signature) return;
    return bscript.compile([a.signature]);
  });
  lazy.prop(o, 'witness', () => {
    if (!o.input) return;
    return [];
  });
  // extended validation
  if (opts.validate) {
    if (a.output) {
      if (a.output[a.output.length - 1] !== OPS.OP_CHECKSIG)
        throw new TypeError('Output is invalid');
      if (!(0, types_1.isPoint)(o.pubkey))
        throw new TypeError('Output pubkey is invalid');
      if (a.pubkey && !a.pubkey.equals(o.pubkey))
        throw new TypeError('Pubkey mismatch');
    }
    if (a.signature) {
      if (a.input && !a.input.equals(o.input))
        throw new TypeError('Signature mismatch');
    }
    if (a.input) {
      if (_chunks().length !== 1) throw new TypeError('Input is invalid');
      if (!bscript.isCanonicalScriptSignature(o.signature))
        throw new TypeError('Input has invalid signature');
    }
  }
  return Object.assign(o, a);
}
exports.p2pk = p2pk;

},{"../networks":88,"../script":101,"../types":106,"./lazy":92}],95:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';
var __createBinding =
  (this && this.__createBinding) ||
  (Object.create
    ? function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (
          !desc ||
          ('get' in desc ? !m.__esModule : desc.writable || desc.configurable)
        ) {
          desc = {
            enumerable: true,
            get: function() {
              return m[k];
            },
          };
        }
        Object.defineProperty(o, k2, desc);
      }
    : function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
      });
var __setModuleDefault =
  (this && this.__setModuleDefault) ||
  (Object.create
    ? function(o, v) {
        Object.defineProperty(o, 'default', { enumerable: true, value: v });
      }
    : function(o, v) {
        o['default'] = v;
      });
var __importStar =
  (this && this.__importStar) ||
  function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null)
      for (var k in mod)
        if (k !== 'default' && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
  };
var __importDefault =
  (this && this.__importDefault) ||
  function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
Object.defineProperty(exports, '__esModule', { value: true });
exports.p2pkh = void 0;
const bcrypto = __importStar(require('../crypto'));
const networks_1 = require('../networks');
const bscript = __importStar(require('../script'));
const types_1 = require('../types');
const lazy = __importStar(require('./lazy'));
const bs58check_1 = __importDefault(require('bs58check'));
const OPS = bscript.OPS;
// input: {signature} {pubkey}
// output: OP_DUP OP_HASH160 {hash160(pubkey)} OP_EQUALVERIFY OP_CHECKSIG
function p2pkh(a, opts) {
  if (
    !a.address &&
    !a.hash &&
    !a.output &&
    !a.pubkey &&
    !a.input &&
    !a.confidentialAddress
  )
    throw new TypeError('Not enough data');
  opts = Object.assign({ validate: true }, opts || {});
  (0, types_1.typeforce)(
    {
      network: types_1.typeforce.maybe(types_1.typeforce.Object),
      address: types_1.typeforce.maybe(types_1.typeforce.String),
      hash: types_1.typeforce.maybe(types_1.typeforce.BufferN(20)),
      output: types_1.typeforce.maybe(types_1.typeforce.BufferN(25)),
      pubkey: types_1.typeforce.maybe(types_1.isPoint),
      signature: types_1.typeforce.maybe(bscript.isCanonicalScriptSignature),
      input: types_1.typeforce.maybe(types_1.typeforce.Buffer),
      blindkey: types_1.typeforce.maybe(types_1.isPoint),
      confidentialAddress: types_1.typeforce.maybe(types_1.typeforce.String),
    },
    a,
  );
  const _address = lazy.value(() => {
    const payload = bs58check_1.default.decode(a.address);
    const version = payload.readUInt8(0);
    const hash = payload.slice(1);
    return { version, hash };
  });
  const _chunks = lazy.value(() => {
    return bscript.decompile(a.input);
  });
  const _confidentialAddress = lazy.value(() => {
    const payload = bs58check_1.default.decode(a.confidentialAddress);
    const blindkey = payload.slice(2, 35);
    const unconfidentialAddressBuffer = Buffer.concat([
      Buffer.from([payload.readUInt8(1)]),
      payload.slice(35),
    ]);
    const unconfidentialAddress = bs58check_1.default.encode(
      unconfidentialAddressBuffer,
    );
    return { blindkey, unconfidentialAddress };
  });
  const network = a.network || networks_1.liquid;
  const o = { name: 'p2pkh', network };
  lazy.prop(o, 'address', () => {
    if (!o.hash) return;
    const payload = Buffer.allocUnsafe(21);
    payload.writeUInt8(network.pubKeyHash, 0);
    o.hash.copy(payload, 1);
    return bs58check_1.default.encode(payload);
  });
  lazy.prop(o, 'hash', () => {
    if (a.output) return a.output.slice(3, 23);
    if (a.address) return _address().hash;
    if (a.pubkey || o.pubkey) return bcrypto.hash160(a.pubkey || o.pubkey);
    if (a.confidentialAddress) {
      const address = _confidentialAddress().unconfidentialAddress;
      return bs58check_1.default.decode(address).slice(1);
    }
  });
  lazy.prop(o, 'output', () => {
    if (!o.hash) return;
    return bscript.compile([
      OPS.OP_DUP,
      OPS.OP_HASH160,
      o.hash,
      OPS.OP_EQUALVERIFY,
      OPS.OP_CHECKSIG,
    ]);
  });
  lazy.prop(o, 'pubkey', () => {
    if (!a.input) return;
    return _chunks()[1];
  });
  lazy.prop(o, 'signature', () => {
    if (!a.input) return;
    return _chunks()[0];
  });
  lazy.prop(o, 'input', () => {
    if (!a.pubkey) return;
    if (!a.signature) return;
    return bscript.compile([a.signature, a.pubkey]);
  });
  lazy.prop(o, 'witness', () => {
    if (!o.input) return;
    return [];
  });
  lazy.prop(o, 'blindkey', () => {
    if (a.confidentialAddress) return _confidentialAddress().blindkey;
    if (a.blindkey) return a.blindkey;
  });
  lazy.prop(o, 'confidentialAddress', () => {
    if (!o.address) return;
    if (!o.blindkey) return;
    const payload = bs58check_1.default.decode(o.address);
    const confidentialAddress = Buffer.concat([
      Buffer.from([network.confidentialPrefix, payload.readUInt8(0)]),
      o.blindkey,
      Buffer.from(payload.slice(1)),
    ]);
    return bs58check_1.default.encode(confidentialAddress);
  });
  // extended validation
  if (opts.validate) {
    let hash = Buffer.from([]);
    let blindkey = Buffer.from([]);
    if (a.address) {
      if (_address().version !== network.pubKeyHash)
        throw new TypeError('Invalid version or Network mismatch');
      if (_address().hash.length !== 20) throw new TypeError('Invalid address');
      hash = _address().hash;
    }
    if (a.hash) {
      if (hash.length > 0 && !hash.equals(a.hash))
        throw new TypeError('Hash mismatch');
      else hash = a.hash;
    }
    if (a.output) {
      if (
        a.output.length !== 25 ||
        a.output[0] !== OPS.OP_DUP ||
        a.output[1] !== OPS.OP_HASH160 ||
        a.output[2] !== 0x14 ||
        a.output[23] !== OPS.OP_EQUALVERIFY ||
        a.output[24] !== OPS.OP_CHECKSIG
      )
        throw new TypeError('Output is invalid');
      const hash2 = a.output.slice(3, 23);
      if (hash.length > 0 && !hash.equals(hash2))
        throw new TypeError('Hash mismatch');
      else hash = hash2;
    }
    if (a.pubkey) {
      const pkh = bcrypto.hash160(a.pubkey);
      if (hash.length > 0 && !hash.equals(pkh))
        throw new TypeError('Hash mismatch');
      else hash = pkh;
    }
    if (a.input) {
      const chunks = _chunks();
      if (chunks.length !== 2) throw new TypeError('Input is invalid');
      if (!bscript.isCanonicalScriptSignature(chunks[0]))
        throw new TypeError('Input has invalid signature');
      if (!(0, types_1.isPoint)(chunks[1]))
        throw new TypeError('Input has invalid pubkey');
      if (a.signature && !a.signature.equals(chunks[0]))
        throw new TypeError('Signature mismatch');
      if (a.pubkey && !a.pubkey.equals(chunks[1]))
        throw new TypeError('Pubkey mismatch');
      const pkh = bcrypto.hash160(chunks[1]);
      if (hash.length > 0 && !hash.equals(pkh))
        throw new TypeError('Hash mismatch');
    }
    if (a.confidentialAddress) {
      if (
        a.address &&
        a.address !== _confidentialAddress().unconfidentialAddress
      )
        throw new TypeError('Address mismatch');
      if (
        blindkey.length > 0 &&
        !blindkey.equals(_confidentialAddress().blindkey)
      )
        throw new TypeError('Blindkey mismatch');
      else blindkey = _confidentialAddress().blindkey;
    }
    if (a.blindkey) {
      if (!(0, types_1.isPoint)(a.blindkey))
        throw new TypeError('Blindkey is invalid');
      if (blindkey.length > 0 && !blindkey.equals(a.blindkey))
        throw new TypeError('Blindkey mismatch');
      else blindkey = a.blindkey;
    }
  }
  return Object.assign(o, a);
}
exports.p2pkh = p2pkh;

}).call(this)}).call(this,require("buffer").Buffer)
},{"../crypto":85,"../networks":88,"../script":101,"../types":106,"./lazy":92,"bs58check":33,"buffer":110}],96:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';
var __createBinding =
  (this && this.__createBinding) ||
  (Object.create
    ? function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (
          !desc ||
          ('get' in desc ? !m.__esModule : desc.writable || desc.configurable)
        ) {
          desc = {
            enumerable: true,
            get: function() {
              return m[k];
            },
          };
        }
        Object.defineProperty(o, k2, desc);
      }
    : function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
      });
var __setModuleDefault =
  (this && this.__setModuleDefault) ||
  (Object.create
    ? function(o, v) {
        Object.defineProperty(o, 'default', { enumerable: true, value: v });
      }
    : function(o, v) {
        o['default'] = v;
      });
var __importStar =
  (this && this.__importStar) ||
  function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null)
      for (var k in mod)
        if (k !== 'default' && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
  };
Object.defineProperty(exports, '__esModule', { value: true });
exports.p2sh = void 0;
const bcrypto = __importStar(require('../crypto'));
const networks_1 = require('../networks');
const bscript = __importStar(require('../script'));
const types_1 = require('../types');
const lazy = __importStar(require('./lazy'));
const bs58check = __importStar(require('bs58check'));
const OPS = bscript.OPS;
function stacksEqual(a, b) {
  if (a.length !== b.length) return false;
  return a.every((x, i) => {
    return x.equals(b[i]);
  });
}
// input: [redeemScriptSig ...] {redeemScript}
// witness: <?>
// output: OP_HASH160 {hash160(redeemScript)} OP_EQUAL
function p2sh(a, opts) {
  if (
    !a.address &&
    !a.hash &&
    !a.output &&
    !a.redeem &&
    !a.input &&
    !a.confidentialAddress
  )
    throw new TypeError('Not enough data');
  opts = Object.assign({ validate: true }, opts || {});
  (0, types_1.typeforce)(
    {
      network: types_1.typeforce.maybe(types_1.typeforce.Object),
      address: types_1.typeforce.maybe(types_1.typeforce.String),
      hash: types_1.typeforce.maybe(types_1.typeforce.BufferN(20)),
      output: types_1.typeforce.maybe(types_1.typeforce.BufferN(23)),
      redeem: types_1.typeforce.maybe({
        network: types_1.typeforce.maybe(types_1.typeforce.Object),
        output: types_1.typeforce.maybe(types_1.typeforce.Buffer),
        input: types_1.typeforce.maybe(types_1.typeforce.Buffer),
        witness: types_1.typeforce.maybe(
          types_1.typeforce.arrayOf(types_1.typeforce.Buffer),
        ),
      }),
      input: types_1.typeforce.maybe(types_1.typeforce.Buffer),
      witness: types_1.typeforce.maybe(
        types_1.typeforce.arrayOf(types_1.typeforce.Buffer),
      ),
      blindkey: types_1.typeforce.maybe(types_1.isPoint),
      confidentialAddress: types_1.typeforce.maybe(types_1.typeforce.String),
    },
    a,
  );
  let network = a.network;
  if (!network) {
    network = (a.redeem && a.redeem.network) || networks_1.liquid;
  }
  const o = { network };
  const _address = lazy.value(() => {
    const payload = bs58check.decode(a.address);
    const version = payload.readUInt8(0);
    const hash = payload.slice(1);
    return { version, hash };
  });
  const _chunks = lazy.value(() => {
    return bscript.decompile(a.input);
  });
  const _redeem = lazy.value(() => {
    const chunks = _chunks();
    return {
      network,
      output: chunks[chunks.length - 1],
      input: bscript.compile(chunks.slice(0, -1)),
      witness: a.witness || [],
    };
  });
  const _confidentialAddress = lazy.value(() => {
    const payload = bs58check.decode(a.confidentialAddress);
    const blindkey = payload.slice(2, 35);
    const unconfidentialAddressBuffer = Buffer.concat([
      Buffer.from([payload.readUInt8(1)]),
      payload.slice(35),
    ]);
    const unconfidentialAddress = bs58check.encode(unconfidentialAddressBuffer);
    return { blindkey, unconfidentialAddress };
  });
  // output dependents
  lazy.prop(o, 'address', () => {
    if (!o.hash) return;
    const payload = Buffer.allocUnsafe(21);
    payload.writeUInt8(o.network.scriptHash, 0);
    o.hash.copy(payload, 1);
    return bs58check.encode(payload);
  });
  lazy.prop(o, 'hash', () => {
    // in order of least effort
    if (a.output) return a.output.slice(2, 22);
    if (a.address) return _address().hash;
    if (o.redeem && o.redeem.output) return bcrypto.hash160(o.redeem.output);
    if (a.confidentialAddress) {
      const address = _confidentialAddress().unconfidentialAddress;
      return bs58check.decode(address).slice(1);
    }
  });
  lazy.prop(o, 'output', () => {
    if (!o.hash) return;
    return bscript.compile([OPS.OP_HASH160, o.hash, OPS.OP_EQUAL]);
  });
  // input dependents
  lazy.prop(o, 'redeem', () => {
    if (!a.input) return;
    return _redeem();
  });
  lazy.prop(o, 'input', () => {
    if (!a.redeem || !a.redeem.input || !a.redeem.output) return;
    return bscript.compile(
      [].concat(bscript.decompile(a.redeem.input), a.redeem.output),
    );
  });
  lazy.prop(o, 'witness', () => {
    if (o.redeem && o.redeem.witness) return o.redeem.witness;
    if (o.input) return [];
  });
  lazy.prop(o, 'name', () => {
    const nameParts = ['p2sh'];
    if (o.redeem !== undefined && o.redeem.name !== undefined)
      nameParts.push(o.redeem.name);
    return nameParts.join('-');
  });
  lazy.prop(o, 'blindkey', () => {
    if (a.confidentialAddress) return _confidentialAddress().blindkey;
    if (a.blindkey) return a.blindkey;
  });
  lazy.prop(o, 'confidentialAddress', () => {
    if (!o.address) return;
    if (!o.blindkey) return;
    const payload = bs58check.decode(o.address);
    const confidentialAddress = Buffer.concat([
      Buffer.from([network.confidentialPrefix, payload.readUInt8(0)]),
      o.blindkey,
      Buffer.from(payload.slice(1)),
    ]);
    return bs58check.encode(confidentialAddress);
  });
  if (opts.validate) {
    let hash = Buffer.from([]);
    let blindkey = Buffer.from([]);
    if (a.address) {
      if (_address().version !== network.scriptHash)
        throw new TypeError('Invalid version or Network mismatch');
      if (_address().hash.length !== 20) throw new TypeError('Invalid address');
      hash = _address().hash;
    }
    if (a.hash) {
      if (hash.length > 0 && !hash.equals(a.hash))
        throw new TypeError('Hash mismatch');
      else hash = a.hash;
    }
    if (a.output) {
      if (
        a.output.length !== 23 ||
        a.output[0] !== OPS.OP_HASH160 ||
        a.output[1] !== 0x14 ||
        a.output[22] !== OPS.OP_EQUAL
      )
        throw new TypeError('Output is invalid');
      const hash2 = a.output.slice(2, 22);
      if (hash.length > 0 && !hash.equals(hash2))
        throw new TypeError('Hash mismatch');
      else hash = hash2;
    }
    // inlined to prevent 'no-inner-declarations' failing
    const checkRedeem = redeem => {
      // is the redeem output empty/invalid?
      if (redeem.output) {
        const decompile = bscript.decompile(redeem.output);
        if (!decompile || decompile.length < 1)
          throw new TypeError('Redeem.output too short');
        // match hash against other sources
        const hash2 = bcrypto.hash160(redeem.output);
        if (hash.length > 0 && !hash.equals(hash2))
          throw new TypeError('Hash mismatch');
        else hash = hash2;
      }
      if (redeem.input) {
        const hasInput = redeem.input.length > 0;
        const hasWitness = redeem.witness && redeem.witness.length > 0;
        if (!hasInput && !hasWitness) throw new TypeError('Empty input');
        if (hasInput && hasWitness)
          throw new TypeError('Input and witness provided');
        if (hasInput) {
          const richunks = bscript.decompile(redeem.input);
          if (!bscript.isPushOnly(richunks))
            throw new TypeError('Non push-only scriptSig');
        }
      }
    };
    if (a.input) {
      const chunks = _chunks();
      if (!chunks || chunks.length < 1) throw new TypeError('Input too short');
      if (!Buffer.isBuffer(_redeem().output))
        throw new TypeError('Input is invalid');
      checkRedeem(_redeem());
    }
    if (a.redeem) {
      if (a.redeem.network && a.redeem.network !== network)
        throw new TypeError('Network mismatch');
      if (a.input) {
        const redeem = _redeem();
        if (a.redeem.output && !a.redeem.output.equals(redeem.output))
          throw new TypeError('Redeem.output mismatch');
        if (a.redeem.input && !a.redeem.input.equals(redeem.input))
          throw new TypeError('Redeem.input mismatch');
      }
      checkRedeem(a.redeem);
    }
    if (a.witness) {
      if (
        a.redeem &&
        a.redeem.witness &&
        !stacksEqual(a.redeem.witness, a.witness)
      )
        throw new TypeError('Witness and redeem.witness mismatch');
    }
    if (a.confidentialAddress) {
      if (
        a.address &&
        a.address !== _confidentialAddress().unconfidentialAddress
      )
        throw new TypeError('Address mismatch');
      if (
        blindkey.length > 0 &&
        !blindkey.equals(_confidentialAddress().blindkey)
      )
        throw new TypeError('Blindkey mismatch');
      else blindkey = _confidentialAddress().blindkey;
    }
    if (a.blindkey) {
      if (!(0, types_1.isPoint)(a.blindkey))
        throw new TypeError('Blindkey is invalid');
      if (blindkey.length > 0 && !blindkey.equals(a.blindkey))
        throw new TypeError('Blindkey mismatch');
      else blindkey = a.blindkey;
    }
  }
  return Object.assign(o, a);
}
exports.p2sh = p2sh;

}).call(this)}).call(this,require("buffer").Buffer)
},{"../crypto":85,"../networks":88,"../script":101,"../types":106,"./lazy":92,"bs58check":33,"buffer":110}],97:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';
var __createBinding =
  (this && this.__createBinding) ||
  (Object.create
    ? function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (
          !desc ||
          ('get' in desc ? !m.__esModule : desc.writable || desc.configurable)
        ) {
          desc = {
            enumerable: true,
            get: function() {
              return m[k];
            },
          };
        }
        Object.defineProperty(o, k2, desc);
      }
    : function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
      });
var __setModuleDefault =
  (this && this.__setModuleDefault) ||
  (Object.create
    ? function(o, v) {
        Object.defineProperty(o, 'default', { enumerable: true, value: v });
      }
    : function(o, v) {
        o['default'] = v;
      });
var __importStar =
  (this && this.__importStar) ||
  function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null)
      for (var k in mod)
        if (k !== 'default' && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
  };
Object.defineProperty(exports, '__esModule', { value: true });
exports.p2wpkh = void 0;
const baddress = __importStar(require('../address'));
const bcrypto = __importStar(require('../crypto'));
const networks_1 = require('../networks');
const bscript = __importStar(require('../script'));
const types_1 = require('../types');
const lazy = __importStar(require('./lazy'));
const bech32_1 = require('bech32');
const OPS = bscript.OPS;
const EMPTY_BUFFER = Buffer.alloc(0);
// witness: {signature} {pubKey}
// input: <>
// output: OP_0 {pubKeyHash}
function p2wpkh(a, opts) {
  if (
    !a.address &&
    !a.hash &&
    !a.output &&
    !a.pubkey &&
    !a.witness &&
    !a.confidentialAddress
  )
    throw new TypeError('Not enough data');
  opts = Object.assign({ validate: true }, opts || {});
  (0, types_1.typeforce)(
    {
      address: types_1.typeforce.maybe(types_1.typeforce.String),
      hash: types_1.typeforce.maybe(types_1.typeforce.BufferN(20)),
      input: types_1.typeforce.maybe(types_1.typeforce.BufferN(0)),
      network: types_1.typeforce.maybe(types_1.typeforce.Object),
      output: types_1.typeforce.maybe(types_1.typeforce.BufferN(22)),
      pubkey: types_1.typeforce.maybe(types_1.isPoint),
      signature: types_1.typeforce.maybe(bscript.isCanonicalScriptSignature),
      witness: types_1.typeforce.maybe(
        types_1.typeforce.arrayOf(types_1.typeforce.Buffer),
      ),
    },
    a,
  );
  const network = a.network || networks_1.liquid;
  const _address = lazy.value(() => {
    const result = bech32_1.bech32.decode(a.address);
    const version = result.words.shift();
    const data = bech32_1.bech32.fromWords(result.words);
    return {
      version,
      prefix: result.prefix,
      data: Buffer.from(data),
    };
  });
  const _confidentialAddress = lazy.value(() => {
    const result = baddress.fromBlech32(a.confidentialAddress);
    return {
      blindingKey: result.pubkey,
      unconfidentialAddress: baddress.toBech32(
        result.data.slice(2),
        result.version,
        network.bech32,
      ),
    };
  });
  const o = { name: 'p2wpkh', network };
  lazy.prop(o, 'address', () => {
    if (!o.hash) return;
    const words = bech32_1.bech32.toWords(o.hash);
    words.unshift(0x00);
    return bech32_1.bech32.encode(network.bech32, words);
  });
  lazy.prop(o, 'hash', () => {
    if (a.output) return a.output.slice(2, 22);
    if (a.address) return _address().data;
    if (a.pubkey || o.pubkey) return bcrypto.hash160(a.pubkey || o.pubkey);
    if (a.confidentialAddress) {
      const addr = _confidentialAddress().unconfidentialAddress;
      return baddress.fromBech32(addr).data;
    }
  });
  lazy.prop(o, 'output', () => {
    if (!o.hash) return;
    return bscript.compile([OPS.OP_0, o.hash]);
  });
  lazy.prop(o, 'pubkey', () => {
    if (a.pubkey) return a.pubkey;
    if (!a.witness) return;
    return a.witness[1];
  });
  lazy.prop(o, 'signature', () => {
    if (!a.witness) return;
    return a.witness[0];
  });
  lazy.prop(o, 'input', () => {
    if (!o.witness) return;
    return EMPTY_BUFFER;
  });
  lazy.prop(o, 'witness', () => {
    if (!a.pubkey) return;
    if (!a.signature) return;
    return [a.signature, a.pubkey];
  });
  lazy.prop(o, 'blindkey', () => {
    if (a.confidentialAddress) return _confidentialAddress().blindingKey;
    if (a.blindkey) return a.blindkey;
  });
  lazy.prop(o, 'confidentialAddress', () => {
    if (!o.address) return;
    if (!o.blindkey) return;
    if (!o.network) return;
    const res = baddress.fromBech32(o.address);
    const data = Buffer.concat([
      Buffer.from([res.version, res.data.length]),
      res.data,
    ]);
    if (res.version !== 0) return;
    return baddress.toBlech32(data, o.blindkey, o.network.blech32, 0);
  });
  // extended validation
  if (opts.validate) {
    let hash = Buffer.from([]);
    let blindkey = Buffer.from([]);
    if (a.address) {
      if (network && network.bech32 !== _address().prefix)
        throw new TypeError('Invalid prefix or Network mismatch');
      if (_address().version !== 0x00)
        throw new TypeError('Invalid address version');
      if (_address().data.length !== 20)
        throw new TypeError('Invalid address data');
      hash = _address().data;
    }
    if (a.hash) {
      if (hash.length > 0 && !hash.equals(a.hash))
        throw new TypeError('Hash mismatch');
      else hash = a.hash;
    }
    if (a.output) {
      if (
        a.output.length !== 22 ||
        a.output[0] !== OPS.OP_0 ||
        a.output[1] !== 0x14
      )
        throw new TypeError('Output is invalid');
      if (hash.length > 0 && !hash.equals(a.output.slice(2)))
        throw new TypeError('Hash mismatch');
      else hash = a.output.slice(2);
    }
    if (a.pubkey) {
      const pkh = bcrypto.hash160(a.pubkey);
      if (hash.length > 0 && !hash.equals(pkh))
        throw new TypeError('Hash mismatch');
      else hash = pkh;
      if (!(0, types_1.isPoint)(a.pubkey) || a.pubkey.length !== 33)
        throw new TypeError('Invalid pubkey for p2wpkh');
    }
    if (a.witness) {
      if (a.witness.length !== 2) throw new TypeError('Witness is invalid');
      if (!bscript.isCanonicalScriptSignature(a.witness[0]))
        throw new TypeError('Witness has invalid signature');
      if (!(0, types_1.isPoint)(a.witness[1]) || a.witness[1].length !== 33)
        throw new TypeError('Witness has invalid pubkey');
      if (a.signature && !a.signature.equals(a.witness[0]))
        throw new TypeError('Signature mismatch');
      if (a.pubkey && !a.pubkey.equals(a.witness[1]))
        throw new TypeError('Pubkey mismatch');
      const pkh = bcrypto.hash160(a.witness[1]);
      if (hash.length > 0 && !hash.equals(pkh))
        throw new TypeError('Hash mismatch');
    }
    if (a.confidentialAddress) {
      if (
        a.address &&
        a.address !== _confidentialAddress().unconfidentialAddress
      )
        throw new TypeError('Address mismatch');
      if (
        blindkey.length > 0 &&
        !blindkey.equals(_confidentialAddress().blindingKey)
      )
        throw new TypeError('Blindkey mismatch');
      else blindkey = _confidentialAddress().blindingKey;
    }
    if (a.blindkey) {
      if (!(0, types_1.isPoint)(a.blindkey))
        throw new TypeError('Blindkey is invalid');
      if (blindkey.length > 0 && !blindkey.equals(a.blindkey))
        throw new TypeError('Blindkey mismatch');
      else blindkey = a.blindkey;
    }
  }
  return Object.assign(o, a);
}
exports.p2wpkh = p2wpkh;

}).call(this)}).call(this,require("buffer").Buffer)
},{"../address":79,"../crypto":85,"../networks":88,"../script":101,"../types":106,"./lazy":92,"bech32":4,"buffer":110}],98:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';
var __createBinding =
  (this && this.__createBinding) ||
  (Object.create
    ? function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (
          !desc ||
          ('get' in desc ? !m.__esModule : desc.writable || desc.configurable)
        ) {
          desc = {
            enumerable: true,
            get: function() {
              return m[k];
            },
          };
        }
        Object.defineProperty(o, k2, desc);
      }
    : function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
      });
var __setModuleDefault =
  (this && this.__setModuleDefault) ||
  (Object.create
    ? function(o, v) {
        Object.defineProperty(o, 'default', { enumerable: true, value: v });
      }
    : function(o, v) {
        o['default'] = v;
      });
var __importStar =
  (this && this.__importStar) ||
  function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null)
      for (var k in mod)
        if (k !== 'default' && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
  };
Object.defineProperty(exports, '__esModule', { value: true });
exports.p2wsh = void 0;
const baddress = __importStar(require('../address'));
const bcrypto = __importStar(require('../crypto'));
const networks_1 = require('../networks');
const bscript = __importStar(require('../script'));
const types_1 = require('../types');
const lazy = __importStar(require('./lazy'));
const bech32_1 = require('bech32');
const OPS = bscript.OPS;
const EMPTY_BUFFER = Buffer.alloc(0);
function stacksEqual(a, b) {
  if (a.length !== b.length) return false;
  return a.every((x, i) => {
    return x.equals(b[i]);
  });
}
function chunkHasUncompressedPubkey(chunk) {
  if (
    Buffer.isBuffer(chunk) &&
    chunk.length === 65 &&
    chunk[0] === 0x04 &&
    (0, types_1.isPoint)(chunk)
  ) {
    return true;
  } else {
    return false;
  }
}
// input: <>
// witness: [redeemScriptSig ...] {redeemScript}
// output: OP_0 {sha256(redeemScript)}
function p2wsh(a, opts) {
  if (
    !a.address &&
    !a.hash &&
    !a.output &&
    !a.redeem &&
    !a.witness &&
    !a.confidentialAddress
  )
    throw new TypeError('Not enough data');
  opts = Object.assign({ validate: true }, opts || {});
  (0, types_1.typeforce)(
    {
      network: types_1.typeforce.maybe(types_1.typeforce.Object),
      address: types_1.typeforce.maybe(types_1.typeforce.String),
      hash: types_1.typeforce.maybe(types_1.typeforce.BufferN(32)),
      output: types_1.typeforce.maybe(types_1.typeforce.BufferN(34)),
      redeem: types_1.typeforce.maybe({
        input: types_1.typeforce.maybe(types_1.typeforce.Buffer),
        network: types_1.typeforce.maybe(types_1.typeforce.Object),
        output: types_1.typeforce.maybe(types_1.typeforce.Buffer),
        witness: types_1.typeforce.maybe(
          types_1.typeforce.arrayOf(types_1.typeforce.Buffer),
        ),
      }),
      input: types_1.typeforce.maybe(types_1.typeforce.BufferN(0)),
      witness: types_1.typeforce.maybe(
        types_1.typeforce.arrayOf(types_1.typeforce.Buffer),
      ),
      blindkey: types_1.typeforce.maybe(types_1.isPoint),
      confidentialAddress: types_1.typeforce.maybe(types_1.typeforce.String),
    },
    a,
  );
  let network = a.network;
  if (!network) {
    network = (a.redeem && a.redeem.network) || networks_1.liquid;
  }
  const _address = lazy.value(() => {
    const result = bech32_1.bech32.decode(a.address);
    const version = result.words.shift();
    const data = bech32_1.bech32.fromWords(result.words);
    return {
      version,
      prefix: result.prefix,
      data: Buffer.from(data),
    };
  });
  const _rchunks = lazy.value(() => {
    return bscript.decompile(a.redeem.input);
  });
  const _confidentialAddress = lazy.value(() => {
    const result = baddress.fromBlech32(a.confidentialAddress);
    return {
      blindingKey: result.pubkey,
      unconfidentialAddress: baddress.toBech32(
        result.data.slice(2),
        result.version,
        network.bech32,
      ),
    };
  });
  const o = { network };
  lazy.prop(o, 'address', () => {
    if (!o.hash) return;
    const words = bech32_1.bech32.toWords(o.hash);
    words.unshift(0x00);
    return bech32_1.bech32.encode(network.bech32, words);
  });
  lazy.prop(o, 'hash', () => {
    if (a.output) return a.output.slice(2);
    if (a.address) return _address().data;
    if (o.redeem && o.redeem.output) return bcrypto.sha256(o.redeem.output);
    if (a.confidentialAddress) {
      const addr = _confidentialAddress().unconfidentialAddress;
      return baddress.fromBech32(addr).data;
    }
  });
  lazy.prop(o, 'output', () => {
    if (!o.hash) return;
    return bscript.compile([OPS.OP_0, o.hash]);
  });
  lazy.prop(o, 'redeem', () => {
    if (!a.witness) return;
    return {
      output: a.witness[a.witness.length - 1],
      input: EMPTY_BUFFER,
      witness: a.witness.slice(0, -1),
    };
  });
  lazy.prop(o, 'input', () => {
    if (!o.witness) return;
    return EMPTY_BUFFER;
  });
  lazy.prop(o, 'witness', () => {
    // transform redeem input to witness stack?
    if (
      a.redeem &&
      a.redeem.input &&
      a.redeem.input.length > 0 &&
      a.redeem.output &&
      a.redeem.output.length > 0
    ) {
      const stack = bscript.toStack(_rchunks());
      // assign, and blank the existing input
      o.redeem = Object.assign({ witness: stack }, a.redeem);
      o.redeem.input = EMPTY_BUFFER;
      return [].concat(stack, a.redeem.output);
    }
    if (!a.redeem) return;
    if (!a.redeem.output) return;
    if (!a.redeem.witness) return;
    return [].concat(a.redeem.witness, a.redeem.output);
  });
  lazy.prop(o, 'name', () => {
    const nameParts = ['p2wsh'];
    if (o.redeem !== undefined && o.redeem.name !== undefined)
      nameParts.push(o.redeem.name);
    return nameParts.join('-');
  });
  lazy.prop(o, 'blindkey', () => {
    if (a.confidentialAddress) return _confidentialAddress().blindingKey;
    if (a.blindkey) return a.blindkey;
  });
  lazy.prop(o, 'confidentialAddress', () => {
    if (!o.address) return;
    if (!o.blindkey) return;
    const res = baddress.fromBech32(o.address);
    const data = Buffer.concat([
      Buffer.from([res.version, res.data.length]),
      res.data,
    ]);
    return baddress.toBlech32(data, o.blindkey, o.network.blech32, 0);
  });
  // extended validation
  if (opts.validate) {
    let hash = Buffer.from([]);
    let blindkey = Buffer.from([]);
    if (a.address) {
      if (_address().prefix !== network.bech32)
        throw new TypeError('Invalid prefix or Network mismatch');
      if (_address().version !== 0x00)
        throw new TypeError('Invalid address version');
      if (_address().data.length !== 32)
        throw new TypeError('Invalid address data');
      hash = _address().data;
    }
    if (a.hash) {
      if (hash.length > 0 && !hash.equals(a.hash))
        throw new TypeError('Hash mismatch');
      else hash = a.hash;
    }
    if (a.output) {
      if (
        a.output.length !== 34 ||
        a.output[0] !== OPS.OP_0 ||
        a.output[1] !== 0x20
      )
        throw new TypeError('Output is invalid');
      const hash2 = a.output.slice(2);
      if (hash.length > 0 && !hash.equals(hash2))
        throw new TypeError('Hash mismatch');
      else hash = hash2;
    }
    if (a.redeem) {
      if (a.redeem.network && a.redeem.network !== network)
        throw new TypeError('Network mismatch');
      // is there two redeem sources?
      if (
        a.redeem.input &&
        a.redeem.input.length > 0 &&
        a.redeem.witness &&
        a.redeem.witness.length > 0
      )
        throw new TypeError('Ambiguous witness source');
      // is the redeem output non-empty?
      if (a.redeem.output) {
        if (bscript.decompile(a.redeem.output).length === 0)
          throw new TypeError('Redeem.output is invalid');
        // match hash against other sources
        const hash2 = bcrypto.sha256(a.redeem.output);
        if (hash.length > 0 && !hash.equals(hash2))
          throw new TypeError('Hash mismatch');
        else hash = hash2;
      }
      if (a.redeem.input && !bscript.isPushOnly(_rchunks()))
        throw new TypeError('Non push-only scriptSig');
      if (
        a.witness &&
        a.redeem.witness &&
        !stacksEqual(a.witness, a.redeem.witness)
      )
        throw new TypeError('Witness and redeem.witness mismatch');
      if (
        (a.redeem.input && _rchunks().some(chunkHasUncompressedPubkey)) ||
        (a.redeem.output &&
          (bscript.decompile(a.redeem.output) || []).some(
            chunkHasUncompressedPubkey,
          ))
      ) {
        throw new TypeError(
          'redeem.input or redeem.output contains uncompressed pubkey',
        );
      }
    }
    if (a.witness && a.witness.length > 0) {
      const wScript = a.witness[a.witness.length - 1];
      if (a.redeem && a.redeem.output && !a.redeem.output.equals(wScript))
        throw new TypeError('Witness and redeem.output mismatch');
      if (
        a.witness.some(chunkHasUncompressedPubkey) ||
        (bscript.decompile(wScript) || []).some(chunkHasUncompressedPubkey)
      )
        throw new TypeError('Witness contains uncompressed pubkey');
    }
    if (a.confidentialAddress) {
      if (
        a.address &&
        a.address !== _confidentialAddress().unconfidentialAddress
      )
        throw new TypeError('Address mismatch');
      if (
        blindkey.length > 0 &&
        !blindkey.equals(_confidentialAddress().blindingKey)
      )
        throw new TypeError('Blindkey mismatch');
      else blindkey = _confidentialAddress().blindingKey;
    }
    if (a.blindkey) {
      if (!(0, types_1.isPoint)(a.blindkey))
        throw new TypeError('Blindkey is invalid');
      if (blindkey.length > 0 && !blindkey.equals(a.blindkey))
        throw new TypeError('Blindkey mismatch');
      else blindkey = a.blindkey;
    }
  }
  return Object.assign(o, a);
}
exports.p2wsh = p2wsh;

}).call(this)}).call(this,require("buffer").Buffer)
},{"../address":79,"../crypto":85,"../networks":88,"../script":101,"../types":106,"./lazy":92,"bech32":4,"buffer":110}],99:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';
var __createBinding =
  (this && this.__createBinding) ||
  (Object.create
    ? function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (
          !desc ||
          ('get' in desc ? !m.__esModule : desc.writable || desc.configurable)
        ) {
          desc = {
            enumerable: true,
            get: function() {
              return m[k];
            },
          };
        }
        Object.defineProperty(o, k2, desc);
      }
    : function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
      });
var __setModuleDefault =
  (this && this.__setModuleDefault) ||
  (Object.create
    ? function(o, v) {
        Object.defineProperty(o, 'default', { enumerable: true, value: v });
      }
    : function(o, v) {
        o['default'] = v;
      });
var __importStar =
  (this && this.__importStar) ||
  function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null)
      for (var k in mod)
        if (k !== 'default' && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
  };
Object.defineProperty(exports, '__esModule', { value: true });
exports.validateAddReissuanceArgs = exports.validateAddIssuanceArgs = exports.toBlindingData = exports.computeOutputsBlindingData = exports.witnessStackToScriptWitness = exports.Psbt = void 0;
const confidential = __importStar(require('./confidential'));
const varuint = __importStar(require('bip174-liquid/src/lib/converter/varint'));
const address_1 = require('./address');
const bufferutils_1 = require('./bufferutils');
const crypto_1 = require('./crypto');
const networks_1 = require('./networks');
const transaction_1 = require('./transaction');
const issuance_1 = require('./issuance');
const address_2 = require('./address');
const bufferutils_2 = require('./bufferutils');
const payments = __importStar(require('./payments'));
const bscript = __importStar(require('./script'));
const bip174_liquid_1 = require('bip174-liquid');
const utils_1 = require('bip174-liquid/src/lib/utils');
const ecpair_1 = require('ecpair');
const _randomBytes = require('randombytes');
const issuancePrefix = Buffer.of(0x01);
/**
 * These are the default arguments for a Psbt instance.
 */
const DEFAULT_OPTS = {
  /**
   * A bitcoinjs Network object. This is only used if you pass an `address`
   * parameter to addOutput. Otherwise it is not needed and can be left default.
   */
  network: networks_1.liquid,
  /**
   * When extractTransaction is called, the fee rate is checked.
   * THIS IS NOT TO BE RELIED ON.
   * It is only here as a last ditch effort to prevent sending a 500 BTC fee etc.
   */
  maximumFeeRate: 5000, // satoshi per byte
};
/**
 * Psbt class can parse and generate a PSBT binary based off of the BIP174.
 * There are 6 roles that this class fulfills. (Explained in BIP174)
 *
 * Creator: This can be done with `new Psbt()`
 * Updater: This can be done with `psbt.addInput(input)`, `psbt.addInputs(inputs)`,
 *   `psbt.addOutput(output)`, `psbt.addOutputs(outputs)` when you are looking to
 *   add new inputs and outputs to the PSBT, and `psbt.updateGlobal(itemObject)`,
 *   `psbt.updateInput(itemObject)`, `psbt.updateOutput(itemObject)`
 *   addInput requires hash: Buffer | string; and index: number; as attributes
 *   and can also include any attributes that are used in updateInput method.
 *   addOutput requires script: Buffer; and value: number; and likewise can include
 *   data for updateOutput.
 *   For a list of what attributes should be what types. Check the bip174 library.
 *   Also, check the integration tests for some examples of usage.
 * Signer: There are a few methods. signAllInputs and signAllInputsAsync, which will search all input
 *   information for your pubkey or pubkeyhash, and only sign inputs where it finds
 *   your info. Or you can explicitly sign a specific input with signInput and
 *   signInputAsync. For the async methods you can create a SignerAsync object
 *   and use something like a hardware wallet to sign with. (You must implement this)
 * Combiner: psbts can be combined easily with `psbt.combine(psbt2, psbt3, psbt4 ...)`
 *   the psbt calling combine will always have precedence when a conflict occurs.
 *   Combine checks if the internal bitcoin transaction is the same, so be sure that
 *   all sequences, version, locktime, etc. are the same before combining.
 * Input Finalizer: This role is fairly important. Not only does it need to construct
 *   the input scriptSigs and witnesses, but it SHOULD verify the signatures etc.
 *   Before running `psbt.finalizeAllInputs()` please run `psbt.validateSignaturesOfAllInputs()`
 *   Running any finalize method will delete any data in the input(s) that are no longer
 *   needed due to the finalized scripts containing the information.
 * Transaction Extractor: This role will perform some checks before returning a
 *   Transaction object. Such as fee rate not being larger than maximumFeeRate etc.
 */
class Psbt {
  constructor(
    opts = {},
    data = new bip174_liquid_1.Psbt(new PsbtTransaction()),
  ) {
    this.data = data;
    // set defaults
    this.opts = Object.assign({}, DEFAULT_OPTS, opts);
    this.__CACHE = {
      __NON_WITNESS_UTXO_TX_CACHE: [],
      __NON_WITNESS_UTXO_BUF_CACHE: [],
      __TX_IN_CACHE: {},
      __TX: this.data.globalMap.unsignedTx.tx,
      // Psbt's predecesor (TransactionBuilder - now removed) behavior
      // was to not confirm input values  before signing.
      // Even though we highly encourage people to get
      // the full parent transaction to verify values, the ability to
      // sign non-segwit inputs without the full transaction was often
      // requested. So the only way to activate is to use @ts-ignore.
      // We will disable exporting the Psbt when unsafe sign is active.
      // because it is not BIP174 compliant.
      __UNSAFE_SIGN_NONSEGWIT: false,
    };
    if (this.data.inputs.length === 0) this.setVersion(2);
    // Make data hidden when enumerating
    const dpew = (obj, attr, enumerable, writable) =>
      Object.defineProperty(obj, attr, {
        enumerable,
        writable,
      });
    dpew(this, '__CACHE', false, true);
    dpew(this, 'opts', false, true);
  }
  static fromBase64(data, opts = {}) {
    const buffer = Buffer.from(data, 'base64');
    return this.fromBuffer(buffer, opts);
  }
  static fromHex(data, opts = {}) {
    const buffer = Buffer.from(data, 'hex');
    return this.fromBuffer(buffer, opts);
  }
  static fromBuffer(buffer, opts = {}) {
    const psbtBase = bip174_liquid_1.Psbt.fromBuffer(
      buffer,
      transactionFromBuffer,
    );
    const psbt = new Psbt(opts, psbtBase);
    checkTxForDupeIns(psbt.__CACHE.__TX, psbt.__CACHE);
    return psbt;
  }
  get TX() {
    return this.__CACHE.__TX;
  }
  get inputCount() {
    return this.data.inputs.length;
  }
  get version() {
    return this.__CACHE.__TX.version;
  }
  set version(version) {
    this.setVersion(version);
  }
  get locktime() {
    return this.__CACHE.__TX.locktime;
  }
  set locktime(locktime) {
    this.setLocktime(locktime);
  }
  get txInputs() {
    return this.__CACHE.__TX.ins.map(input => ({
      hash: (0, bufferutils_2.cloneBuffer)(input.hash),
      index: input.index,
      sequence: input.sequence,
    }));
  }
  get txOutputs() {
    return this.__CACHE.__TX.outs.map(output => {
      let address;
      try {
        address = (0, address_2.fromOutputScript)(
          output.script,
          this.opts.network,
        );
      } catch (_) {}
      return {
        ...output,
        address,
      };
    });
  }
  combine(...those) {
    this.data.combine(...those.map(o => o.data));
    return this;
  }
  clone() {
    // TODO: more efficient cloning
    const res = Psbt.fromBuffer(this.data.toBuffer());
    res.opts = JSON.parse(JSON.stringify(this.opts));
    return res;
  }
  setMaximumFeeRate(satoshiPerByte) {
    check32Bit(satoshiPerByte); // 42.9 BTC per byte IS excessive... so throw
    this.opts.maximumFeeRate = satoshiPerByte;
  }
  setVersion(version) {
    check32Bit(version);
    checkInputsForPartialSig(this.data.inputs, 'setVersion');
    const c = this.__CACHE;
    c.__TX.version = version;
    c.__EXTRACTED_TX = undefined;
    return this;
  }
  setLocktime(locktime) {
    check32Bit(locktime);
    checkInputsForPartialSig(this.data.inputs, 'setLocktime');
    const c = this.__CACHE;
    c.__TX.locktime = locktime;
    c.__EXTRACTED_TX = undefined;
    return this;
  }
  setInputSequence(inputIndex, sequence) {
    check32Bit(sequence);
    checkInputsForPartialSig(this.data.inputs, 'setInputSequence');
    const c = this.__CACHE;
    if (c.__TX.ins.length <= inputIndex) {
      throw new Error('Input index too high');
    }
    c.__TX.ins[inputIndex].sequence = sequence;
    c.__EXTRACTED_TX = undefined;
    return this;
  }
  addInputs(inputDatas) {
    inputDatas.forEach(inputData => this.addInput(inputData));
    return this;
  }
  addInput(inputData) {
    if (
      arguments.length > 1 ||
      !inputData ||
      inputData.hash === undefined ||
      inputData.index === undefined
    ) {
      throw new Error(
        `Invalid arguments for Psbt.addInput. ` +
          `Requires single object with at least [hash] and [index]`,
      );
    }
    checkInputsForPartialSig(this.data.inputs, 'addInput');
    if (inputData.witnessScript) checkInvalidP2WSH(inputData.witnessScript);
    const c = this.__CACHE;
    this.data.addInput(inputData);
    const txIn = c.__TX.ins[c.__TX.ins.length - 1];
    checkTxInputCache(c, txIn);
    const inputIndex = this.data.inputs.length - 1;
    const input = this.data.inputs[inputIndex];
    if (input.nonWitnessUtxo) {
      addNonWitnessTxCache(this.__CACHE, input, inputIndex);
    }
    c.__FEE = undefined;
    c.__FEE_RATE = undefined;
    c.__EXTRACTED_TX = undefined;
    return this;
  }
  addIssuance(args, inputIndex) {
    validateAddIssuanceArgs(args); // throw an error if args are invalid
    inputIndex = this.searchInputIndexForIssuance(inputIndex);
    const { hash, index } = this.__CACHE.__TX.ins[inputIndex];
    // create an issuance object using the vout and the args
    const issuance = (0, issuance_1.newIssuance)(
      args.assetSats,
      args.tokenSats,
      args.contract,
    );
    const entropy = (0, issuance_1.generateEntropy)(
      { txHash: hash, vout: index },
      issuance.assetEntropy,
    );
    // add the issuance to the input.
    this.__CACHE.__TX.ins[inputIndex].issuance = issuance;
    if (args.assetSats > 0) {
      if (!args.assetAddress)
        throw new Error(
          'assetAddress is required when assetSats is greater than 0',
        );
      const asset = Buffer.concat([
        issuancePrefix,
        (0, issuance_1.calculateAsset)(entropy),
      ]);
      const assetScript = (0, address_1.toOutputScript)(args.assetAddress);
      // send the asset amount to the asset address.
      this.addOutput({
        value: issuance.assetAmount,
        script: assetScript,
        asset,
        nonce: Buffer.of(0x00),
      });
    }
    // check if the token amount is not 0
    if (args.tokenSats > 0) {
      if (!args.tokenAddress)
        throw new Error(
          'tokenAddress is required when tokenSats is greater than 0',
        );
      const token = (0, issuance_1.calculateReissuanceToken)(
        entropy,
        args.blindedIssuance,
      );
      const tokenScript = (0, address_1.toOutputScript)(args.tokenAddress);
      // send the token amount to the token address.
      this.addOutput({
        script: tokenScript,
        value: issuance.tokenAmount,
        asset: Buffer.concat([issuancePrefix, token]),
        nonce: Buffer.of(0x00),
      });
    }
    return this;
  }
  addReissuance(args) {
    validateAddReissuanceArgs(args);
    const inputIndex = this.data.inputs.length;
    const inputData = {
      hash: args.tokenPrevout.txHash,
      index: args.tokenPrevout.vout,
    };
    if (args.witnessUtxo) {
      inputData.witnessUtxo = args.witnessUtxo;
    }
    if (args.nonWitnessUtxo) {
      inputData.nonWitnessUtxo = args.nonWitnessUtxo;
    }
    this.addInput(inputData);
    const satsToReissue = confidential.satoshiToConfidentialValue(
      args.assetSats,
    );
    // add the issuance object to input
    this.__CACHE.__TX.ins[inputIndex].issuance = {
      assetBlindingNonce: args.prevoutBlinder,
      tokenAmount: Buffer.of(0x00),
      assetAmount: satsToReissue,
      assetEntropy: args.entropy,
    };
    const asset = Buffer.concat([
      issuancePrefix,
      (0, issuance_1.calculateAsset)(args.entropy),
    ]);
    // send the asset amount to the asset address.
    this.addOutput({
      value: satsToReissue,
      script: (0, address_1.toOutputScript)(args.assetAddress),
      asset,
      nonce: Buffer.of(0x00),
    });
    const token = Buffer.concat([
      issuancePrefix,
      (0, issuance_1.calculateReissuanceToken)(
        args.entropy,
        args.blindedIssuance,
      ),
    ]);
    // send the token amount to the token address.
    this.addOutput({
      value:
        args.tokenSats === 0
          ? Buffer.of(0x00)
          : confidential.satoshiToConfidentialValue(args.tokenSats),
      script: (0, address_1.toOutputScript)(args.tokenAddress),
      asset: token,
      nonce: Buffer.of(0x00),
    });
    return this;
  }
  addOutputs(outputDatas) {
    outputDatas.forEach(outputData => this.addOutput(outputData));
    return this;
  }
  addOutput(outputData) {
    if (
      arguments.length > 1 ||
      !outputData ||
      outputData.value === undefined ||
      (outputData.address === undefined && outputData.script === undefined)
    ) {
      throw new Error(
        `Invalid arguments for Psbt.addOutput. ` +
          `Requires single object with at least [script or address] and [value]`,
      );
    }
    checkInputsForPartialSig(this.data.inputs, 'addOutput');
    const { address } = outputData;
    if (typeof address === 'string') {
      const { network } = this.opts;
      const script = (0, address_1.toOutputScript)(address, network);
      outputData = Object.assign(outputData, { script });
    }
    const c = this.__CACHE;
    this.data.addOutput(outputData);
    c.__FEE = undefined;
    c.__FEE_RATE = undefined;
    c.__EXTRACTED_TX = undefined;
    return this;
  }
  extractTransaction(disableFeeCheck) {
    if (!this.data.inputs.every(isFinalized)) throw new Error('Not finalized');
    const c = this.__CACHE;
    if (!disableFeeCheck) {
      checkFees(this, c, this.opts);
    }
    if (c.__EXTRACTED_TX) return c.__EXTRACTED_TX;
    const tx = c.__TX.clone();
    inputFinalizeGetAmts(this.data.inputs, tx, c, true);
    return tx;
  }
  getFeeRate() {
    return getTxCacheValue(
      '__FEE_RATE',
      'fee rate',
      this.data.inputs,
      this.__CACHE,
    );
  }
  getFee() {
    return getTxCacheValue('__FEE', 'fee', this.data.inputs, this.__CACHE);
  }
  finalizeAllInputs() {
    (0, utils_1.checkForInput)(this.data.inputs, 0); // making sure we have at least one
    range(this.data.inputs.length).forEach(idx => this.finalizeInput(idx));
    return this;
  }
  finalizeInput(inputIndex, finalScriptsFunc = getFinalScripts) {
    const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
    const { script, isP2SH, isP2WSH, isSegwit } = getScriptFromInput(
      inputIndex,
      input,
      this.__CACHE,
    );
    if (!script) {
      // this is a trick to allow us to support segwitv1
      // should be removed in the future
      if (!input.finalScriptWitness)
        throw new Error(`No script found for input #${inputIndex}`);
    } else {
      checkPartialSigSighashes(input);
      const { finalScriptSig, finalScriptWitness } = finalScriptsFunc(
        inputIndex,
        input,
        script,
        isSegwit,
        isP2SH,
        isP2WSH,
      );
      if (finalScriptSig) this.data.updateInput(inputIndex, { finalScriptSig });
      if (finalScriptWitness)
        this.data.updateInput(inputIndex, { finalScriptWitness });
      if (!finalScriptSig && !finalScriptWitness) {
        if (!input.finalScriptWitness)
          throw new Error(`Unknown error finalizing input #${inputIndex}`);
      }
      this.data.clearFinalizedInput(inputIndex);
    }
    return this;
  }
  getInputType(inputIndex) {
    const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
    const script = getScriptFromUtxo(inputIndex, input, this.__CACHE);
    const result = getMeaningfulScript(
      script,
      inputIndex,
      'input',
      input.redeemScript || redeemFromFinalScriptSig(input.finalScriptSig),
      input.witnessScript ||
        redeemFromFinalWitnessScript(input.finalScriptWitness),
    );
    const type = result.type === 'raw' ? '' : result.type + '-';
    const mainType = classifyScript(result.meaningfulScript);
    return type + mainType;
  }
  inputHasPubkey(inputIndex, pubkey) {
    const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
    return pubkeyInInput(pubkey, input, inputIndex, this.__CACHE);
  }
  inputHasHDKey(inputIndex, root) {
    const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
    const derivationIsMine = bip32DerivationIsMine(root);
    return (
      !!input.bip32Derivation && input.bip32Derivation.some(derivationIsMine)
    );
  }
  outputHasPubkey(outputIndex, pubkey) {
    const output = checkForOutput(this.data.outputs, outputIndex);
    return pubkeyInOutput(pubkey, output, outputIndex, this.__CACHE);
  }
  outputHasHDKey(outputIndex, root) {
    const output = checkForOutput(this.data.outputs, outputIndex);
    const derivationIsMine = bip32DerivationIsMine(root);
    return (
      !!output.bip32Derivation && output.bip32Derivation.some(derivationIsMine)
    );
  }
  static ECDSASigValidator(ecc) {
    return (pubkey, msghash, signature) => {
      return (0, ecpair_1.ECPairFactory)(ecc)
        .fromPublicKey(pubkey)
        .verify(msghash, signature);
    };
  }
  static SchnorrSigValidator(ecc) {
    return (pubkey, msghash, signature) => {
      return (0, ecpair_1.ECPairFactory)(ecc)
        .fromPublicKey(pubkey)
        .verifySchnorr(msghash, signature);
    };
  }
  validateSignaturesOfAllInputs(validator) {
    (0, utils_1.checkForInput)(this.data.inputs, 0); // making sure we have at least one
    const results = range(this.data.inputs.length).map(idx =>
      this.validateSignaturesOfInput(idx, validator),
    );
    return results.reduce((final, res) => res === true && final, true);
  }
  validateSignaturesOfInput(inputIndex, validator, pubkey) {
    const input = this.data.inputs[inputIndex];
    const partialSig = (input || {}).partialSig;
    if (!input || !partialSig || partialSig.length < 1)
      throw new Error('No signatures to validate');
    if (typeof validator !== 'function')
      throw new Error('Need validator function to validate signatures');
    const mySigs = pubkey
      ? partialSig.filter(sig => sig.pubkey.equals(pubkey))
      : partialSig;
    if (mySigs.length < 1) throw new Error('No signatures for this pubkey');
    const results = [];
    let hashCache;
    let scriptCache;
    let sighashCache;
    for (const pSig of mySigs) {
      const sig = bscript.signature.decode(pSig.signature);
      const { hash, script } =
        sighashCache !== sig.hashType
          ? getHashForSig(
              inputIndex,
              Object.assign({}, input, { sighashType: sig.hashType }),
              this.__CACHE,
              true,
            )
          : { hash: hashCache, script: scriptCache };
      sighashCache = sig.hashType;
      hashCache = hash;
      scriptCache = script;
      checkScriptForPubkey(pSig.pubkey, script, 'verify');
      results.push(validator(pSig.pubkey, hash, sig.signature));
    }
    return results.every(res => res === true);
  }
  signAllInputsHD(
    hdKeyPair,
    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],
  ) {
    if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {
      throw new Error('Need HDSigner to sign input');
    }
    const results = [];
    for (const i of range(this.data.inputs.length)) {
      try {
        this.signInputHD(i, hdKeyPair, sighashTypes);
        results.push(true);
      } catch (err) {
        results.push(false);
      }
    }
    if (results.every(v => v === false)) {
      throw new Error('No inputs were signed');
    }
    return this;
  }
  signAllInputsHDAsync(
    hdKeyPair,
    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],
  ) {
    return new Promise((resolve, reject) => {
      if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {
        return reject(new Error('Need HDSigner to sign input'));
      }
      const results = [];
      const promises = [];
      for (const i of range(this.data.inputs.length)) {
        promises.push(
          this.signInputHDAsync(i, hdKeyPair, sighashTypes).then(
            () => {
              results.push(true);
            },
            () => {
              results.push(false);
            },
          ),
        );
      }
      return Promise.all(promises).then(() => {
        if (results.every(v => v === false)) {
          return reject(new Error('No inputs were signed'));
        }
        resolve();
      });
    });
  }
  signInputHD(
    inputIndex,
    hdKeyPair,
    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],
  ) {
    if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {
      throw new Error('Need HDSigner to sign input');
    }
    const signers = getSignersFromHD(inputIndex, this.data.inputs, hdKeyPair);
    signers.forEach(signer => this.signInput(inputIndex, signer, sighashTypes));
    return this;
  }
  signInputHDAsync(
    inputIndex,
    hdKeyPair,
    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],
  ) {
    return new Promise((resolve, reject) => {
      if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {
        return reject(new Error('Need HDSigner to sign input'));
      }
      const signers = getSignersFromHD(inputIndex, this.data.inputs, hdKeyPair);
      const promises = signers.map(signer =>
        this.signInputAsync(inputIndex, signer, sighashTypes),
      );
      return Promise.all(promises)
        .then(() => {
          resolve();
        })
        .catch(reject);
    });
  }
  signAllInputs(
    keyPair,
    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],
  ) {
    if (!keyPair || !keyPair.publicKey)
      throw new Error('Need Signer to sign input');
    // TODO: Add a pubkey/pubkeyhash cache to each input
    // as input information is added, then eventually
    // optimize this method.
    const results = [];
    for (const i of range(this.data.inputs.length)) {
      try {
        this.signInput(i, keyPair, sighashTypes);
        results.push(true);
      } catch (err) {
        results.push(false);
      }
    }
    if (results.every(v => v === false)) {
      throw new Error('No inputs were signed');
    }
    return this;
  }
  signAllInputsAsync(
    keyPair,
    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],
  ) {
    return new Promise((resolve, reject) => {
      if (!keyPair || !keyPair.publicKey)
        return reject(new Error('Need Signer to sign input'));
      // TODO: Add a pubkey/pubkeyhash cache to each input
      // as input information is added, then eventually
      // optimize this method.
      const results = [];
      const promises = [];
      for (const [i] of this.data.inputs.entries()) {
        promises.push(
          this.signInputAsync(i, keyPair, sighashTypes).then(
            () => {
              results.push(true);
            },
            () => {
              results.push(false);
            },
          ),
        );
      }
      return Promise.all(promises).then(() => {
        if (results.every(v => v === false)) {
          return reject(new Error('No inputs were signed'));
        }
        resolve();
      });
    });
  }
  signInput(
    inputIndex,
    keyPair,
    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],
  ) {
    if (!keyPair || !keyPair.publicKey)
      throw new Error('Need Signer to sign input');
    const { hash, sighashType } = getHashAndSighashType(
      this.data.inputs,
      inputIndex,
      keyPair.publicKey,
      this.__CACHE,
      sighashTypes,
    );
    const partialSig = [
      {
        pubkey: keyPair.publicKey,
        signature: bscript.signature.encode(keyPair.sign(hash), sighashType),
      },
    ];
    this.data.updateInput(inputIndex, { partialSig });
    return this;
  }
  signInputAsync(
    inputIndex,
    keyPair,
    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],
  ) {
    return Promise.resolve().then(() => {
      if (!keyPair || !keyPair.publicKey)
        throw new Error('Need Signer to sign input');
      const { hash, sighashType } = getHashAndSighashType(
        this.data.inputs,
        inputIndex,
        keyPair.publicKey,
        this.__CACHE,
        sighashTypes,
      );
      return Promise.resolve(keyPair.sign(hash)).then(signature => {
        const partialSig = [
          {
            pubkey: keyPair.publicKey,
            signature: bscript.signature.encode(signature, sighashType),
          },
        ];
        this.data.updateInput(inputIndex, { partialSig });
      });
    });
  }
  toBuffer() {
    checkCache(this.__CACHE);
    return this.data.toBuffer();
  }
  toHex() {
    checkCache(this.__CACHE);
    return this.data.toHex();
  }
  toBase64() {
    checkCache(this.__CACHE);
    return this.data.toBase64();
  }
  updateGlobal(updateData) {
    this.data.updateGlobal(updateData);
    return this;
  }
  updateInput(inputIndex, updateData) {
    if (updateData.witnessUtxo) {
      const { witnessUtxo } = updateData;
      const script = Buffer.isBuffer(witnessUtxo.script)
        ? witnessUtxo.script
        : Buffer.from(witnessUtxo.script, 'hex');
      const value = Buffer.isBuffer(witnessUtxo.value)
        ? witnessUtxo.value
        : typeof witnessUtxo.value === 'string'
        ? Buffer.from(witnessUtxo.value, 'hex')
        : confidential.satoshiToConfidentialValue(witnessUtxo.value);
      // if the asset is a string, by checking the first byte we can determine if
      // it's an asset commitment, in this case we decode the hex string as buffer,
      // or if it's an asset hash, in this case we put the unconf prefix in front of the reversed the buffer
      const asset = Buffer.isBuffer(witnessUtxo.asset)
        ? witnessUtxo.asset
        : witnessUtxo.asset.startsWith('0a') ||
          witnessUtxo.asset.startsWith('0b')
        ? Buffer.from(witnessUtxo.asset, 'hex')
        : Buffer.concat([
            Buffer.alloc(1, 1),
            (0, bufferutils_1.reverseBuffer)(
              Buffer.from(witnessUtxo.asset, 'hex'),
            ),
          ]);
      const nonce = witnessUtxo.nonce
        ? Buffer.isBuffer(witnessUtxo.nonce)
          ? witnessUtxo.nonce
          : Buffer.from(witnessUtxo.nonce, 'hex')
        : Buffer.alloc(1, 0);
      const rangeProof = witnessUtxo.rangeProof
        ? Buffer.isBuffer(witnessUtxo.rangeProof)
          ? witnessUtxo.rangeProof
          : Buffer.from(witnessUtxo.rangeProof, 'hex')
        : undefined;
      const surjectionProof = witnessUtxo.surjectionProof
        ? Buffer.isBuffer(witnessUtxo.surjectionProof)
          ? witnessUtxo.surjectionProof
          : Buffer.from(witnessUtxo.surjectionProof, 'hex')
        : undefined;
      updateData = Object.assign(updateData, {
        witnessUtxo: {
          script,
          value,
          asset,
          nonce,
          rangeProof,
          surjectionProof,
        },
      });
    }
    if (updateData.witnessScript) checkInvalidP2WSH(updateData.witnessScript);
    this.data.updateInput(inputIndex, updateData);
    if (updateData.nonWitnessUtxo) {
      addNonWitnessTxCache(
        this.__CACHE,
        this.data.inputs[inputIndex],
        inputIndex,
      );
    }
    return this;
  }
  updateOutput(outputIndex, updateData) {
    this.data.updateOutput(outputIndex, updateData);
    return this;
  }
  static ECCKeysGenerator(ecc) {
    return opts => {
      const privateKey = randomBytes(opts);
      const publicKey = (0, ecpair_1.ECPairFactory)(ecc).fromPrivateKey(
        privateKey,
      ).publicKey;
      return {
        privateKey,
        publicKey,
      };
    };
  }
  blindOutputs(keysGenerator, blindingDataLike, blindingPubkeys, opts) {
    return this.rawBlindOutputs(
      blindingDataLike,
      blindingPubkeys,
      undefined,
      keysGenerator,
      undefined,
      opts,
    );
  }
  blindOutputsByIndex(
    keysGenerator,
    inputsBlindingData,
    outputsBlindingPubKeys,
    issuancesBlindingKeys,
    opts,
  ) {
    const blindingPrivKeysArgs = range(this.__CACHE.__TX.ins.length).map(
      inputIndex => inputsBlindingData.get(inputIndex),
    );
    const blindingPrivKeysIssuancesArgs = issuancesBlindingKeys
      ? range(this.__CACHE.__TX.ins.length).map(inputIndex =>
          issuancesBlindingKeys.get(inputIndex),
        )
      : [];
    const outputIndexes = [];
    const blindingPublicKey = [];
    for (const [outputIndex, pubBlindingKey] of outputsBlindingPubKeys) {
      outputIndexes.push(outputIndex);
      blindingPublicKey.push(pubBlindingKey);
    }
    return this.rawBlindOutputs(
      blindingPrivKeysArgs,
      blindingPublicKey,
      blindingPrivKeysIssuancesArgs,
      keysGenerator,
      outputIndexes,
      opts,
    );
  }
  addUnknownKeyValToGlobal(keyVal) {
    this.data.addUnknownKeyValToGlobal(keyVal);
    return this;
  }
  addUnknownKeyValToInput(inputIndex, keyVal) {
    this.data.addUnknownKeyValToInput(inputIndex, keyVal);
    return this;
  }
  addUnknownKeyValToOutput(outputIndex, keyVal) {
    this.data.addUnknownKeyValToOutput(outputIndex, keyVal);
    return this;
  }
  clearFinalizedInput(inputIndex) {
    this.data.clearFinalizedInput(inputIndex);
    return this;
  }
  searchInputIndexForIssuance(inputIndex) {
    if (inputIndex && !this.data.inputs[inputIndex]) {
      throw new Error(`The input ${inputIndex} does not exist.`);
      // check if the input is available for issuance.
    } else {
      // verify if there is at least one input available.
      if (this.__CACHE.__TX.ins.filter(i => !i.issuance).length === 0)
        throw new Error(
          'transaction needs at least one input without issuance data.',
        );
      // search and extract the input index.
      inputIndex = this.__CACHE.__TX.ins.findIndex(i => !i.issuance);
    }
    if (this.__CACHE.__TX.ins[inputIndex].issuance)
      throw new Error(`The input ${inputIndex} already has issuance data.`);
    return inputIndex;
  }
  unblindInputsToIssuanceBlindingData(issuanceBlindingPrivKeys = []) {
    const pseudoBlindingDataFromIssuances = [];
    let inputIndex = 0;
    for (const input of this.__CACHE.__TX.ins) {
      if (input.issuance) {
        const isConfidentialIssuance =
          issuanceBlindingPrivKeys && issuanceBlindingPrivKeys[inputIndex]
            ? true
            : false;
        const entropy = (0, issuance_1.issuanceEntropyFromInput)(input);
        // if (hasAssetAmount(input.issuance)) {
        const asset = (0, issuance_1.calculateAsset)(entropy);
        const value = input.issuance.assetAmount.equals(Buffer.of(0x00))
          ? '0'
          : confidential
              .confidentialValueToSatoshi(input.issuance.assetAmount)
              .toString(10);
        const assetBlindingData = {
          value,
          asset,
          assetBlindingFactor: transaction_1.ZERO,
          valueBlindingFactor: isConfidentialIssuance
            ? randomBytes()
            : transaction_1.ZERO,
        };
        pseudoBlindingDataFromIssuances.push(assetBlindingData);
        // }
        if (
          !(0, issuance_1.isReissuance)(input.issuance) &&
          (0, issuance_1.hasTokenAmount)(input.issuance)
        ) {
          const token = (0, issuance_1.calculateReissuanceToken)(
            entropy,
            isConfidentialIssuance,
          );
          const tokenValue = confidential
            .confidentialValueToSatoshi(input.issuance.tokenAmount)
            .toString(10);
          const tokenBlindingData = {
            value: tokenValue,
            asset: token,
            assetBlindingFactor: transaction_1.ZERO,
            valueBlindingFactor: isConfidentialIssuance
              ? randomBytes()
              : transaction_1.ZERO,
          };
          pseudoBlindingDataFromIssuances.push(tokenBlindingData);
        }
      }
      inputIndex++;
    }
    return pseudoBlindingDataFromIssuances;
  }
  async blindInputs(blindingData, issuanceBlindingPrivKeys = []) {
    if (!issuanceBlindingPrivKeys || issuanceBlindingPrivKeys.length === 0)
      return this; // skip if no issuance blind keys
    function getBlindingFactors(asset) {
      for (const blindData of blindingData) {
        if (asset.equals(blindData.asset)) {
          return blindData;
        }
      }
      throw new Error(
        'no blinding factors generated for pseudo issuance inputs',
      );
    }
    // loop over inputs and create blindingData object in case of issuance
    let inputIndex = 0;
    for (const input of this.__CACHE.__TX.ins) {
      if (input.issuance) {
        if (!issuanceBlindingPrivKeys[inputIndex]) {
          // check if the user has provided blinding key
          inputIndex++;
          continue;
        }
        const entropy = (0, issuance_1.issuanceEntropyFromInput)(input);
        const issuedAsset = (0, issuance_1.calculateAsset)(entropy);
        const blindingFactorsAsset = getBlindingFactors(issuedAsset);
        const assetCommitment = await confidential.assetCommitment(
          blindingFactorsAsset.asset,
          blindingFactorsAsset.assetBlindingFactor,
        );
        const valueCommitment = await confidential.valueCommitment(
          blindingFactorsAsset.value,
          assetCommitment,
          blindingFactorsAsset.valueBlindingFactor,
        );
        const assetBlindingPrivateKey = issuanceBlindingPrivKeys[inputIndex]
          ? issuanceBlindingPrivKeys[inputIndex].assetKey
          : undefined;
        if (!assetBlindingPrivateKey) {
          throw new Error(
            `missing asset blinding private key for issuance #${inputIndex}`,
          );
        }
        const issuanceRangeProof = await confidential.rangeProof(
          blindingFactorsAsset.value,
          assetBlindingPrivateKey,
          blindingFactorsAsset.asset,
          blindingFactorsAsset.assetBlindingFactor,
          blindingFactorsAsset.valueBlindingFactor,
          valueCommitment,
          Buffer.alloc(0),
          '0',
          0,
          52,
        );
        this.__CACHE.__TX.ins[
          inputIndex
        ].issuanceRangeProof = issuanceRangeProof;
        this.__CACHE.__TX.ins[
          inputIndex
        ].issuance.assetAmount = valueCommitment;
        if (
          !(0, issuance_1.isReissuance)(input.issuance) &&
          (0, issuance_1.hasTokenAmount)(input.issuance)
        ) {
          const token = (0, issuance_1.calculateReissuanceToken)(entropy, true);
          const blindingFactorsToken = getBlindingFactors(token);
          const issuedTokenCommitment = await confidential.assetCommitment(
            token,
            blindingFactorsToken.assetBlindingFactor,
          );
          const tokenValueCommitment = await confidential.valueCommitment(
            blindingFactorsToken.value,
            issuedTokenCommitment,
            blindingFactorsToken.valueBlindingFactor,
          );
          if (!issuanceBlindingPrivKeys[inputIndex].tokenKey) {
            throw new Error(
              'you must specify tokenKey in order to blind the token issuance',
            );
          }
          const inflationRangeProof = await confidential.rangeProof(
            blindingFactorsToken.value,
            issuanceBlindingPrivKeys[inputIndex].tokenKey,
            token,
            blindingFactorsToken.assetBlindingFactor,
            blindingFactorsToken.valueBlindingFactor,
            tokenValueCommitment,
            Buffer.alloc(0),
            '1',
            0,
            52,
          );
          this.__CACHE.__TX.ins[
            inputIndex
          ].inflationRangeProof = inflationRangeProof;
          this.__CACHE.__TX.ins[
            inputIndex
          ].issuance.tokenAmount = tokenValueCommitment;
        }
      }
      inputIndex++;
    }
    return this;
  }
  async blindOutputsRaw(
    blindingData,
    blindingPubkeys,
    outputIndexes,
    keysGenerator,
    opts,
  ) {
    // get data (satoshis & asset) outputs to blind
    const outputsData = outputIndexes.map(index => {
      const output = this.__CACHE.__TX.outs[index];
      // prevent blinding the fee output
      if (output.script.length === 0)
        throw new Error("cant't blind the fee output");
      const value = confidential
        .confidentialValueToSatoshi(output.value)
        .toString(10);
      return [value, output.asset.slice(1)];
    });
    // compute the outputs blinders
    const outputsBlindingData = await computeOutputsBlindingData(
      blindingData,
      outputsData,
    );
    // use blinders to compute proofs & commitments
    let indexInArray = 0;
    for (const outputIndex of outputIndexes) {
      const randomSeed = randomBytes(opts);
      const ephemeralKeys = keysGenerator(opts);
      const outputNonce = ephemeralKeys.publicKey;
      const outputBlindingData = outputsBlindingData[indexInArray];
      // commitments
      const assetCommitment = await confidential.assetCommitment(
        outputBlindingData.asset,
        outputBlindingData.assetBlindingFactor,
      );
      const valueCommitment = await confidential.valueCommitment(
        outputBlindingData.value,
        assetCommitment,
        outputBlindingData.valueBlindingFactor,
      );
      // proofs
      const rangeProof = await confidential.rangeProofWithNonceHash(
        outputBlindingData.value,
        blindingPubkeys[indexInArray],
        ephemeralKeys.privateKey,
        outputBlindingData.asset,
        outputBlindingData.assetBlindingFactor,
        outputBlindingData.valueBlindingFactor,
        valueCommitment,
        this.__CACHE.__TX.outs[outputIndex].script,
      );
      const surjectionProof = await confidential.surjectionProof(
        outputBlindingData.asset,
        outputBlindingData.assetBlindingFactor,
        blindingData.map(({ asset }) => asset),
        blindingData.map(({ assetBlindingFactor }) => assetBlindingFactor),
        randomSeed,
      );
      // set commitments & proofs & nonce
      this.__CACHE.__TX.outs[outputIndex].asset = assetCommitment;
      this.__CACHE.__TX.outs[outputIndex].value = valueCommitment;
      this.__CACHE.__TX.setOutputNonce(outputIndex, outputNonce);
      this.__CACHE.__TX.setOutputRangeProof(outputIndex, rangeProof);
      this.__CACHE.__TX.setOutputSurjectionProof(outputIndex, surjectionProof);
      indexInArray++;
    }
    return this;
  }
  async rawBlindOutputs(
    blindingDataLike,
    blindingPubkeys,
    issuanceBlindingPrivKeys = [],
    keysGenerator,
    outputIndexes,
    opts,
  ) {
    if (this.data.inputs.some(v => !v.nonWitnessUtxo && !v.witnessUtxo))
      throw new Error(
        'All inputs must contain a non witness utxo or a witness utxo',
      );
    if (this.__CACHE.__TX.ins.length !== blindingDataLike.length) {
      throw new Error(
        'blindingDataLike length does not match the number of inputs (undefined for unconfidential utxo)',
      );
    }
    if (!outputIndexes) {
      outputIndexes = [];
      // fill the outputIndexes array with all the output index (except the fee output)
      this.__CACHE.__TX.outs.forEach((out, index) => {
        if (out.script.length > 0) outputIndexes.push(index);
      });
    }
    if (outputIndexes.length !== blindingPubkeys.length)
      throw new Error(
        'not enough blinding public keys to blind the requested outputs',
      );
    const witnesses = this.data.inputs.map((input, index) => {
      if (input.nonWitnessUtxo) {
        const prevTx = nonWitnessUtxoTxFromCache(this.__CACHE, input, index);
        const prevoutIndex = this.__CACHE.__TX.ins[index].index;
        return prevTx.outs[prevoutIndex];
      }
      if (input.witnessUtxo) {
        return input.witnessUtxo;
      }
      throw new Error('input data needs witness utxo or nonwitness utxo');
    });
    const inputsBlindingData = await Promise.all(
      blindingDataLike.map((data, i) => toBlindingData(data, witnesses[i])),
    );
    const pseudoInputsBlindingData = this.unblindInputsToIssuanceBlindingData(
      issuanceBlindingPrivKeys,
    );
    const totalBlindingData = inputsBlindingData.concat(
      pseudoInputsBlindingData,
    );
    await this.blindOutputsRaw(
      totalBlindingData,
      blindingPubkeys,
      outputIndexes,
      keysGenerator,
      opts,
    );
    await this.blindInputs(totalBlindingData, issuanceBlindingPrivKeys);
    this.__CACHE.__FEE = undefined;
    this.__CACHE.__FEE_RATE = undefined;
    this.__CACHE.__EXTRACTED_TX = undefined;
    return this;
  }
}
exports.Psbt = Psbt;
/**
 * This function is needed to pass to the bip174 base class's fromBuffer.
 * It takes the "transaction buffer" portion of the psbt buffer and returns a
 * Transaction (From the bip174 library) interface.
 */
const transactionFromBuffer = buffer => new PsbtTransaction(buffer);
/**
 * This class implements the Transaction interface from bip174 library.
 * It contains a liquidjs-lib Transaction object.
 */
class PsbtTransaction {
  constructor(buffer = Buffer.from([2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])) {
    this.tx = transaction_1.Transaction.fromBuffer(buffer);
    checkTxEmpty(this.tx);
    Object.defineProperty(this, 'tx', {
      enumerable: false,
      writable: true,
    });
  }
  getInputOutputCounts() {
    return {
      inputCount: this.tx.ins.length,
      outputCount: this.tx.outs.length,
    };
  }
  addInput(input) {
    if (
      input.hash === undefined ||
      input.index === undefined ||
      (!Buffer.isBuffer(input.hash) && typeof input.hash !== 'string') ||
      typeof input.index !== 'number'
    ) {
      throw new Error('Error adding input.');
    }
    const hash =
      typeof input.hash === 'string'
        ? (0, bufferutils_1.reverseBuffer)(Buffer.from(input.hash, 'hex'))
        : input.hash;
    this.tx.addInput(hash, input.index, input.sequence);
  }
  addOutput(output) {
    if (
      output.script === undefined ||
      (!Buffer.isBuffer(output.script) && typeof output.script !== 'string') ||
      output.value === undefined ||
      (!Buffer.isBuffer(output.value) && typeof output.value !== 'number') ||
      output.asset === undefined ||
      (!Buffer.isBuffer(output.asset) && typeof output.asset !== 'string')
    ) {
      throw new Error('Error adding output.');
    }
    const nonce = Buffer.alloc(1, 0);
    const script = Buffer.isBuffer(output.script)
      ? output.script
      : Buffer.from(output.script, 'hex');
    const value = Buffer.isBuffer(output.value)
      ? output.value
      : confidential.satoshiToConfidentialValue(output.value);
    const asset = Buffer.isBuffer(output.asset)
      ? output.asset
      : Buffer.concat([
          Buffer.alloc(1, 1),
          (0, bufferutils_1.reverseBuffer)(Buffer.from(output.asset, 'hex')),
        ]);
    this.tx.addOutput(script, value, asset, nonce);
  }
  toBuffer() {
    return this.tx.toBuffer();
  }
}
function canFinalize(input, script, scriptType) {
  switch (scriptType) {
    case 'pubkey':
    case 'pubkeyhash':
    case 'witnesspubkeyhash':
      return hasSigs(1, input.partialSig);
    case 'multisig':
      const p2ms = payments.p2ms({ output: script });
      return hasSigs(p2ms.m, input.partialSig, p2ms.pubkeys);
    case 'nonstandard':
      if (script[0] === 81) return true;
    default:
      return false;
  }
}
function checkCache(cache) {
  if (cache.__UNSAFE_SIGN_NONSEGWIT !== false) {
    throw new Error('Not BIP174 compliant, can not export');
  }
}
function compressPubkey(pubkey) {
  if (pubkey.length === 65) {
    const parity = pubkey[64] & 1;
    const newKey = pubkey.slice(0, 33);
    newKey[0] = 2 | parity;
    return newKey;
  }
  return pubkey.slice();
}
function hasSigs(neededSigs, partialSig, pubkeys) {
  if (!partialSig) return false;
  let sigs;
  if (pubkeys) {
    sigs = pubkeys
      .map(pkey => {
        const pubkey = compressPubkey(pkey);
        return partialSig.find(pSig => pSig.pubkey.equals(pubkey));
      })
      .filter(v => !!v);
  } else {
    sigs = partialSig;
  }
  if (sigs.length > neededSigs) throw new Error('Too many signatures');
  return sigs.length === neededSigs;
}
function isFinalized(input) {
  return !!input.finalScriptSig || !!input.finalScriptWitness;
}
function isPaymentFactory(payment) {
  return script => {
    try {
      payment({ output: script });
      return true;
    } catch (err) {
      return false;
    }
  };
}
const isP2MS = isPaymentFactory(payments.p2ms);
const isP2PK = isPaymentFactory(payments.p2pk);
const isP2PKH = isPaymentFactory(payments.p2pkh);
const isP2WPKH = isPaymentFactory(payments.p2wpkh);
const isP2WSHScript = isPaymentFactory(payments.p2wsh);
const isP2SHScript = isPaymentFactory(payments.p2sh);
function bip32DerivationIsMine(root) {
  return d => {
    if (!d.masterFingerprint.equals(root.fingerprint)) return false;
    if (!root.derivePath(d.path).publicKey.equals(d.pubkey)) return false;
    return true;
  };
}
function check32Bit(num) {
  if (
    typeof num !== 'number' ||
    num !== Math.floor(num) ||
    num > 0xffffffff ||
    num < 0
  ) {
    throw new Error('Invalid 32 bit integer');
  }
}
function checkFees(psbt, cache, opts) {
  const feeRate = cache.__FEE_RATE || psbt.getFeeRate();
  const vsize = cache.__EXTRACTED_TX.virtualSize();
  const satoshis = feeRate * vsize;
  if (feeRate >= opts.maximumFeeRate) {
    throw new Error(
      `Warning: You are paying around ${(satoshis / 1e8).toFixed(8)} in ` +
        `fees, which is ${feeRate} satoshi per byte for a transaction ` +
        `with a VSize of ${vsize} bytes (segwit counted as 0.25 byte per ` +
        `byte). Use setMaximumFeeRate method to raise your threshold, or ` +
        `pass true to the first arg of extractTransaction.`,
    );
  }
}
function checkInputsForPartialSig(inputs, action) {
  inputs.forEach(input => {
    let throws = false;
    let pSigs = [];
    if ((input.partialSig || []).length === 0) {
      if (!input.finalScriptSig && !input.finalScriptWitness) return;
      pSigs = getPsigsFromInputFinalScripts(input);
    } else {
      pSigs = input.partialSig;
    }
    pSigs.forEach(pSig => {
      const { hashType } = bscript.signature.decode(pSig.signature);
      const whitelist = [];
      const isAnyoneCanPay =
        hashType & transaction_1.Transaction.SIGHASH_ANYONECANPAY;
      if (isAnyoneCanPay) whitelist.push('addInput');
      const hashMod = hashType & 0x1f;
      switch (hashMod) {
        case transaction_1.Transaction.SIGHASH_ALL:
          break;
        case transaction_1.Transaction.SIGHASH_SINGLE:
        case transaction_1.Transaction.SIGHASH_NONE:
          whitelist.push('addOutput');
          whitelist.push('setInputSequence');
          break;
      }
      if (whitelist.indexOf(action) === -1) {
        throws = true;
      }
    });
    if (throws) {
      throw new Error('Can not modify transaction, signatures exist.');
    }
  });
}
function checkPartialSigSighashes(input) {
  if (!input.sighashType || !input.partialSig) return;
  const { partialSig, sighashType } = input;
  partialSig.forEach(pSig => {
    const { hashType } = bscript.signature.decode(pSig.signature);
    if (sighashType !== hashType) {
      throw new Error('Signature sighash does not match input sighash type');
    }
  });
}
function checkScriptForPubkey(pubkey, script, action) {
  if (!pubkeyInScript(pubkey, script)) {
    throw new Error(
      `Can not ${action} for this input with the key ${pubkey.toString('hex')}`,
    );
  }
}
function checkTxEmpty(tx) {
  const isEmpty = tx.ins.every(
    input => input.script && input.script.length === 0,
  );
  if (!isEmpty) {
    throw new Error('Format Error: Transaction ScriptSigs are not empty');
  }
  // if (tx.flag === 1 && tx.witnessIn.length > 0) {
  //   throw new Error('Format Error: Transaction WitnessScriptSigs are not empty');
  // }
}
function checkTxForDupeIns(tx, cache) {
  tx.ins.forEach(input => {
    checkTxInputCache(cache, input);
  });
}
function checkTxInputCache(cache, input) {
  const key =
    (0, bufferutils_1.reverseBuffer)(Buffer.from(input.hash)).toString('hex') +
    ':' +
    input.index;
  if (cache.__TX_IN_CACHE[key]) throw new Error('Duplicate input detected.');
  cache.__TX_IN_CACHE[key] = 1;
}
function scriptCheckerFactory(payment, paymentScriptName) {
  return (inputIndex, scriptPubKey, redeemScript, ioType) => {
    const redeemScriptOutput = payment({
      redeem: { output: redeemScript },
    }).output;
    if (!scriptPubKey.equals(redeemScriptOutput)) {
      throw new Error(
        `${paymentScriptName} for ${ioType} #${inputIndex} doesn't match the scriptPubKey in the prevout`,
      );
    }
  };
}
const checkRedeemScript = scriptCheckerFactory(payments.p2sh, 'Redeem script');
const checkWitnessScript = scriptCheckerFactory(
  payments.p2wsh,
  'Witness script',
);
function getTxCacheValue(key, name, inputs, c) {
  if (!inputs.every(isFinalized))
    throw new Error(`PSBT must be finalized to calculate ${name}`);
  if (key === '__FEE_RATE' && c.__FEE_RATE) return c.__FEE_RATE;
  if (key === '__FEE' && c.__FEE) return c.__FEE;
  let tx;
  let mustFinalize = true;
  if (c.__EXTRACTED_TX) {
    tx = c.__EXTRACTED_TX;
    mustFinalize = false;
  } else {
    tx = c.__TX.clone();
  }
  inputFinalizeGetAmts(inputs, tx, c, mustFinalize);
  if (key === '__FEE_RATE') return c.__FEE_RATE;
  else if (key === '__FEE') return c.__FEE;
}
function getFinalScripts(inputIndex, input, script, isSegwit, isP2SH, isP2WSH) {
  const scriptType = classifyScript(script);
  if (!canFinalize(input, script, scriptType))
    throw new Error(`Can not finalize input #${inputIndex}`);
  return prepareFinalScripts(
    script,
    scriptType,
    input.partialSig,
    isSegwit,
    isP2SH,
    isP2WSH,
  );
}
function prepareFinalScripts(
  script,
  scriptType,
  partialSig,
  isSegwit,
  isP2SH,
  isP2WSH,
) {
  if (scriptType === 'nonstandard')
    return {
      finalScriptSig: undefined,
      finalScriptWitness: undefined,
    };
  let finalScriptSig;
  let finalScriptWitness;
  // Wow, the payments API is very handy
  const payment = getPayment(script, scriptType, partialSig);
  const p2wsh = !isP2WSH ? null : payments.p2wsh({ redeem: payment });
  const p2sh = !isP2SH ? null : payments.p2sh({ redeem: p2wsh || payment });
  if (isSegwit) {
    if (p2wsh) {
      finalScriptWitness = witnessStackToScriptWitness(p2wsh.witness);
    } else {
      finalScriptWitness = witnessStackToScriptWitness(payment.witness);
    }
    if (p2sh) {
      finalScriptSig = p2sh.input;
    }
  } else {
    if (p2sh) {
      finalScriptSig = p2sh.input;
    } else {
      finalScriptSig = payment.input;
    }
  }
  return {
    finalScriptSig,
    finalScriptWitness,
  };
}
function getHashAndSighashType(
  inputs,
  inputIndex,
  pubkey,
  cache,
  sighashTypes,
) {
  // const input = checkForInput(inputs, inputIndex);
  const { hash, sighashType, script } = getHashForSig(
    inputIndex,
    inputs[inputIndex],
    cache,
    false,
    sighashTypes,
  );
  checkScriptForPubkey(pubkey, script, 'sign');
  return {
    hash,
    sighashType,
  };
}
function getHashForSig(inputIndex, input, cache, forValidate, sighashTypes) {
  const unsignedTx = cache.__TX;
  const sighashType =
    input.sighashType || transaction_1.Transaction.SIGHASH_ALL;
  if (sighashTypes && sighashTypes.indexOf(sighashType) < 0) {
    const str = sighashTypeToString(sighashType);
    throw new Error(
      `Sighash type is not allowed. Retry the sign method passing the ` +
        `sighashTypes array of whitelisted types. Sighash type: ${str}`,
    );
  }
  let hash;
  let prevout;
  if (input.nonWitnessUtxo) {
    const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(
      cache,
      input,
      inputIndex,
    );
    const prevoutHash = unsignedTx.ins[inputIndex].hash;
    const utxoHash = nonWitnessUtxoTx.getHash();
    // If a non-witness UTXO is provided, its hash must match the hash specified in the prevout
    if (!prevoutHash.equals(utxoHash)) {
      throw new Error(
        `Non-witness UTXO hash for input #${inputIndex} doesn't match the hash specified in the prevout`,
      );
    }
    const prevoutIndex = unsignedTx.ins[inputIndex].index;
    prevout = nonWitnessUtxoTx.outs[prevoutIndex];
  } else if (input.witnessUtxo) {
    prevout = input.witnessUtxo;
  } else {
    throw new Error('Need a Utxo input item for signing');
  }
  const { meaningfulScript, type } = getMeaningfulScript(
    prevout.script,
    inputIndex,
    'input',
    input.redeemScript,
    input.witnessScript,
  );
  if (['p2sh-p2wsh', 'p2wsh'].indexOf(type) >= 0) {
    hash = unsignedTx.hashForWitnessV0(
      inputIndex,
      meaningfulScript,
      prevout.value,
      sighashType,
    );
  } else if (isP2WPKH(meaningfulScript)) {
    // P2WPKH uses the P2PKH template for prevoutScript when signing
    const signingScript = payments.p2pkh({ hash: meaningfulScript.slice(2) })
      .output;
    hash = unsignedTx.hashForWitnessV0(
      inputIndex,
      signingScript,
      prevout.value,
      sighashType,
    );
  } else {
    // non-segwit
    if (
      input.nonWitnessUtxo === undefined &&
      cache.__UNSAFE_SIGN_NONSEGWIT === false
    )
      throw new Error(
        `Input #${inputIndex} has witnessUtxo but non-segwit script: ` +
          `${meaningfulScript.toString('hex')}`,
      );
    if (!forValidate && cache.__UNSAFE_SIGN_NONSEGWIT !== false)
      console.warn(
        'Warning: Signing non-segwit inputs without the full parent transaction ' +
          'means there is a chance that a miner could feed you incorrect information ' +
          "to trick you into paying large fees. This behavior is the same as Psbt's predecesor " +
          '(TransactionBuilder - now removed) when signing non-segwit scripts. You are not ' +
          'able to export this Psbt with toBuffer|toBase64|toHex since it is not ' +
          'BIP174 compliant.\n*********************\nPROCEED WITH CAUTION!\n' +
          '*********************',
      );
    hash = unsignedTx.hashForSignature(
      inputIndex,
      meaningfulScript,
      sighashType,
    );
  }
  return {
    script: meaningfulScript,
    sighashType,
    hash,
  };
}
function getPayment(script, scriptType, partialSig) {
  let payment;
  switch (scriptType) {
    case 'multisig':
      const sigs = getSortedSigs(script, partialSig);
      payment = payments.p2ms({
        output: script,
        signatures: sigs,
      });
      break;
    case 'pubkey':
      payment = payments.p2pk({
        output: script,
        signature: partialSig[0].signature,
      });
      break;
    case 'pubkeyhash':
      payment = payments.p2pkh({
        output: script,
        pubkey: partialSig[0].pubkey,
        signature: partialSig[0].signature,
      });
      break;
    case 'witnesspubkeyhash':
      payment = payments.p2wpkh({
        output: script,
        pubkey: partialSig[0].pubkey,
        signature: partialSig[0].signature,
      });
      break;
  }
  return payment;
}
function getPsigsFromInputFinalScripts(input) {
  const scriptItems = !input.finalScriptSig
    ? []
    : bscript.decompile(input.finalScriptSig) || [];
  const witnessItems = !input.finalScriptWitness
    ? []
    : bscript.decompile(input.finalScriptWitness) || [];
  return scriptItems
    .concat(witnessItems)
    .filter(item => {
      return Buffer.isBuffer(item) && bscript.isCanonicalScriptSignature(item);
    })
    .map(sig => ({ signature: sig }));
}
function getScriptFromInput(inputIndex, input, cache) {
  const unsignedTx = cache.__TX;
  const res = {
    script: null,
    isSegwit: false,
    isP2SH: false,
    isP2WSH: false,
  };
  res.isP2SH = !!input.redeemScript;
  res.isP2WSH = !!input.witnessScript;
  if (input.witnessScript) {
    res.script = input.witnessScript;
  } else if (input.redeemScript) {
    res.script = input.redeemScript;
  } else {
    if (input.nonWitnessUtxo) {
      const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(
        cache,
        input,
        inputIndex,
      );
      const prevoutIndex = unsignedTx.ins[inputIndex].index;
      res.script = nonWitnessUtxoTx.outs[prevoutIndex].script;
    } else if (input.witnessUtxo) {
      res.script = input.witnessUtxo.script;
    }
  }
  if (input.witnessScript || isP2WPKH(res.script)) {
    res.isSegwit = true;
  }
  return res;
}
function getSignersFromHD(inputIndex, inputs, hdKeyPair) {
  const input = (0, utils_1.checkForInput)(inputs, inputIndex);
  if (!input.bip32Derivation || input.bip32Derivation.length === 0) {
    throw new Error('Need bip32Derivation to sign with HD');
  }
  const myDerivations = input.bip32Derivation
    .map(bipDv => {
      if (bipDv.masterFingerprint.equals(hdKeyPair.fingerprint)) {
        return bipDv;
      } else {
        return;
      }
    })
    .filter(v => !!v);
  if (myDerivations.length === 0) {
    throw new Error(
      'Need one bip32Derivation masterFingerprint to match the HDSigner fingerprint',
    );
  }
  const signers = myDerivations.map(bipDv => {
    const node = hdKeyPair.derivePath(bipDv.path);
    if (!bipDv.pubkey.equals(node.publicKey)) {
      throw new Error('pubkey did not match bip32Derivation');
    }
    return node;
  });
  return signers;
}
function getSortedSigs(script, partialSig) {
  const p2ms = payments.p2ms({ output: script });
  // for each pubkey in order of p2ms script
  return p2ms.pubkeys
    .map(pk => {
      // filter partialSig array by pubkey being equal
      return (
        partialSig.filter(ps => {
          return ps.pubkey.equals(pk);
        })[0] || {}
      ).signature;
      // Any pubkey without a match will return undefined
      // this last filter removes all the undefined items in the array.
    })
    .filter(v => !!v);
}
function scriptWitnessToWitnessStack(buffer) {
  let offset = 0;
  function readSlice(n) {
    offset += n;
    return buffer.slice(offset - n, offset);
  }
  function readVarInt() {
    const vi = varuint.decode(buffer, offset);
    offset += varuint.decode.bytes;
    return vi;
  }
  function readVarSlice() {
    return readSlice(readVarInt());
  }
  function readVector() {
    const count = readVarInt();
    const vector = [];
    for (let i = 0; i < count; i++) vector.push(readVarSlice());
    return vector;
  }
  return readVector();
}
function sighashTypeToString(sighashType) {
  let text =
    sighashType & transaction_1.Transaction.SIGHASH_ANYONECANPAY
      ? 'SIGHASH_ANYONECANPAY | '
      : '';
  const sigMod = sighashType & 0x1f;
  switch (sigMod) {
    case transaction_1.Transaction.SIGHASH_ALL:
      text += 'SIGHASH_ALL';
      break;
    case transaction_1.Transaction.SIGHASH_SINGLE:
      text += 'SIGHASH_SINGLE';
      break;
    case transaction_1.Transaction.SIGHASH_NONE:
      text += 'SIGHASH_NONE';
      break;
  }
  return text;
}
function witnessStackToScriptWitness(witness) {
  let buffer = Buffer.allocUnsafe(0);
  function writeSlice(slice) {
    buffer = Buffer.concat([buffer, Buffer.from(slice)]);
  }
  function writeVarInt(i) {
    const currentLen = buffer.length;
    const varintLen = varuint.encodingLength(i);
    buffer = Buffer.concat([buffer, Buffer.allocUnsafe(varintLen)]);
    varuint.encode(i, buffer, currentLen);
  }
  function writeVarSlice(slice) {
    writeVarInt(slice.length);
    writeSlice(slice);
  }
  function writeVector(vector) {
    writeVarInt(vector.length);
    vector.forEach(writeVarSlice);
  }
  writeVector(witness);
  return buffer;
}
exports.witnessStackToScriptWitness = witnessStackToScriptWitness;
function addNonWitnessTxCache(cache, input, inputIndex) {
  cache.__NON_WITNESS_UTXO_BUF_CACHE[inputIndex] = input.nonWitnessUtxo;
  const tx = transaction_1.Transaction.fromBuffer(input.nonWitnessUtxo);
  cache.__NON_WITNESS_UTXO_TX_CACHE[inputIndex] = tx;
  const self = cache;
  const selfIndex = inputIndex;
  delete input.nonWitnessUtxo;
  Object.defineProperty(input, 'nonWitnessUtxo', {
    enumerable: true,
    get() {
      const buf = self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex];
      const txCache = self.__NON_WITNESS_UTXO_TX_CACHE[selfIndex];
      if (buf !== undefined) {
        return buf;
      } else {
        const newBuf = txCache.toBuffer();
        self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex] = newBuf;
        return newBuf;
      }
    },
    set(data) {
      self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex] = data;
    },
  });
}
function inputFinalizeGetAmts(inputs, tx, cache, mustFinalize) {
  inputs.forEach((input, idx) => {
    if (mustFinalize && input.finalScriptSig)
      tx.ins[idx].script = input.finalScriptSig;
    if (mustFinalize && input.finalScriptWitness) {
      tx.ins[idx].witness = scriptWitnessToWitnessStack(
        input.finalScriptWitness,
      );
    }
  });
  if (tx.ins.some(x => x.witness.length !== 0)) {
    tx.flag = 1;
  }
  const bytes = tx.virtualSize();
  const fee = 2 * bytes;
  cache.__FEE = fee;
  cache.__EXTRACTED_TX = tx;
  cache.__FEE_RATE = Math.floor(fee / bytes);
}
function nonWitnessUtxoTxFromCache(cache, input, inputIndex) {
  const c = cache.__NON_WITNESS_UTXO_TX_CACHE;
  if (!c[inputIndex]) {
    addNonWitnessTxCache(cache, input, inputIndex);
  }
  return c[inputIndex];
}
function getScriptFromUtxo(inputIndex, input, cache) {
  if (input.witnessUtxo !== undefined) {
    return input.witnessUtxo.script;
  } else if (input.nonWitnessUtxo !== undefined) {
    const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(
      cache,
      input,
      inputIndex,
    );
    return nonWitnessUtxoTx.outs[cache.__TX.ins[inputIndex].index].script;
  } else {
    throw new Error("Can't find pubkey in input without Utxo data");
  }
}
function pubkeyInInput(pubkey, input, inputIndex, cache) {
  const script = getScriptFromUtxo(inputIndex, input, cache);
  const { meaningfulScript } = getMeaningfulScript(
    script,
    inputIndex,
    'input',
    input.redeemScript,
    input.witnessScript,
  );
  return pubkeyInScript(pubkey, meaningfulScript);
}
function pubkeyInOutput(pubkey, output, outputIndex, cache) {
  const script = cache.__TX.outs[outputIndex].script;
  const { meaningfulScript } = getMeaningfulScript(
    script,
    outputIndex,
    'output',
    output.redeemScript,
    output.witnessScript,
  );
  return pubkeyInScript(pubkey, meaningfulScript);
}
function redeemFromFinalScriptSig(finalScript) {
  if (!finalScript) return;
  const decomp = bscript.decompile(finalScript);
  if (!decomp) return;
  const lastItem = decomp[decomp.length - 1];
  if (
    !Buffer.isBuffer(lastItem) ||
    isPubkeyLike(lastItem) ||
    isSigLike(lastItem)
  )
    return;
  const sDecomp = bscript.decompile(lastItem);
  if (!sDecomp) return;
  return lastItem;
}
function redeemFromFinalWitnessScript(finalScript) {
  if (!finalScript) return;
  const decomp = scriptWitnessToWitnessStack(finalScript);
  const lastItem = decomp[decomp.length - 1];
  if (isPubkeyLike(lastItem)) return;
  const sDecomp = bscript.decompile(lastItem);
  if (!sDecomp) return;
  return lastItem;
}
function isPubkeyLike(buf) {
  return buf.length === 33 && bscript.isCanonicalPubKey(buf);
}
function isSigLike(buf) {
  return bscript.isCanonicalScriptSignature(buf);
}
function getMeaningfulScript(
  script,
  index,
  ioType,
  redeemScript,
  witnessScript,
) {
  const isP2SH = isP2SHScript(script);
  const isP2SHP2WSH = isP2SH && redeemScript && isP2WSHScript(redeemScript);
  const isP2WSH = isP2WSHScript(script);
  if (isP2SH && redeemScript === undefined)
    throw new Error('scriptPubkey is P2SH but redeemScript missing');
  if ((isP2WSH || isP2SHP2WSH) && witnessScript === undefined)
    throw new Error(
      'scriptPubkey or redeemScript is P2WSH but witnessScript missing',
    );
  let meaningfulScript;
  if (isP2SHP2WSH) {
    meaningfulScript = witnessScript;
    checkRedeemScript(index, script, redeemScript, ioType);
    checkWitnessScript(index, redeemScript, witnessScript, ioType);
    checkInvalidP2WSH(meaningfulScript);
  } else if (isP2WSH) {
    meaningfulScript = witnessScript;
    checkWitnessScript(index, script, witnessScript, ioType);
    checkInvalidP2WSH(meaningfulScript);
  } else if (isP2SH) {
    meaningfulScript = redeemScript;
    checkRedeemScript(index, script, redeemScript, ioType);
  } else {
    meaningfulScript = script;
  }
  return {
    meaningfulScript,
    type: isP2SHP2WSH
      ? 'p2sh-p2wsh'
      : isP2SH
      ? 'p2sh'
      : isP2WSH
      ? 'p2wsh'
      : 'raw',
  };
}
function checkInvalidP2WSH(script) {
  if (isP2WPKH(script) || isP2SHScript(script)) {
    throw new Error('P2WPKH or P2SH can not be contained within P2WSH');
  }
}
function pubkeyInScript(pubkey, script) {
  const pubkeyHash = (0, crypto_1.hash160)(pubkey);
  const decompiled = bscript.decompile(script);
  if (decompiled === null) throw new Error('Unknown script error');
  return decompiled.some(element => {
    if (typeof element === 'number') return false;
    return element.equals(pubkey) || element.equals(pubkeyHash);
  });
}
function classifyScript(script) {
  if (isP2WPKH(script)) return 'witnesspubkeyhash';
  if (isP2PKH(script)) return 'pubkeyhash';
  if (isP2MS(script)) return 'multisig';
  if (isP2PK(script)) return 'pubkey';
  return 'nonstandard';
}
function range(n) {
  return [...Array(n).keys()];
}
function randomBytes(options) {
  if (options === undefined) options = {};
  const rng = options.rng || _randomBytes;
  return rng(32);
}
/**
 * Compute outputs blinders
 * @param inputsBlindingData the transaction inputs blinding data
 * @param outputsData data = [satoshis, asset] of output to blind ([string Buffer])
 * @returns an array of BlindingData[] corresponding of blinders to blind outputs specified in outputsData
 */
async function computeOutputsBlindingData(inputsBlindingData, outputsData) {
  const outputsBlindingData = [];
  outputsData.slice(0, outputsData.length - 1).forEach(([satoshis, asset]) => {
    const blindingData = {
      value: satoshis,
      asset,
      valueBlindingFactor: randomBytes(),
      assetBlindingFactor: randomBytes(),
    };
    outputsBlindingData.push(blindingData);
  });
  const [lastOutputValue, lastOutputAsset] = outputsData[
    outputsData.length - 1
  ];
  const finalBlindingData = {
    value: lastOutputValue,
    asset: lastOutputAsset,
    assetBlindingFactor: randomBytes(),
    valueBlindingFactor: Buffer.from([]), // invalid at this step
  };
  // values
  const inputsValues = inputsBlindingData.map(({ value }) => value);
  const outputsValues = outputsData
    .map(([amount]) => amount)
    .concat(lastOutputValue);
  // asset blinders
  const inputsAssetBlinders = inputsBlindingData.map(
    ({ assetBlindingFactor }) => assetBlindingFactor,
  );
  const outputsAssetBlinders = outputsBlindingData
    .map(({ assetBlindingFactor }) => assetBlindingFactor)
    .concat(finalBlindingData.assetBlindingFactor);
  // value blinders
  const inputsAmountBlinders = inputsBlindingData.map(
    ({ valueBlindingFactor }) => valueBlindingFactor,
  );
  const outputsAmountBlinders = outputsBlindingData.map(
    ({ valueBlindingFactor }) => valueBlindingFactor,
  );
  // compute output final amount blinder
  const finalAmountBlinder = await confidential.valueBlindingFactor(
    inputsValues,
    outputsValues,
    inputsAssetBlinders,
    outputsAssetBlinders,
    inputsAmountBlinders,
    outputsAmountBlinders,
  );
  finalBlindingData.valueBlindingFactor = finalAmountBlinder;
  outputsBlindingData.push(finalBlindingData);
  return outputsBlindingData;
}
exports.computeOutputsBlindingData = computeOutputsBlindingData;
/**
 * toBlindingData convert a BlindingDataLike to UnblindOutputResult
 * @param blindDataLike blinding data "like" associated to a specific input I
 * @param witnessUtxo the prevout of the input I
 */
async function toBlindingData(blindDataLike, witnessUtxo) {
  if (!blindDataLike) {
    if (!witnessUtxo) throw new Error('need witnessUtxo');
    return getUnconfidentialWitnessUtxoBlindingData(witnessUtxo);
  }
  if (Buffer.isBuffer(blindDataLike)) {
    if (!witnessUtxo) throw new Error('need witnessUtxo');
    return confidential.unblindOutputWithKey(witnessUtxo, blindDataLike);
  }
  return blindDataLike;
}
exports.toBlindingData = toBlindingData;
function getUnconfidentialWitnessUtxoBlindingData(prevout) {
  const unblindedInputBlindingData = {
    value: confidential.confidentialValueToSatoshi(prevout.value).toString(10),
    valueBlindingFactor: transaction_1.ZERO,
    asset: prevout.asset.slice(1),
    assetBlindingFactor: transaction_1.ZERO,
  };
  return unblindedInputBlindingData;
}
function validateAddIssuanceArgs(args) {
  if (args.assetSats < 0)
    throw new Error('asset amount must be greater than zero.');
  if (args.tokenSats < 0) {
    throw new Error('token amount must be positive.');
  }
  if (args.assetSats === 0 && args.tokenSats === 0) {
    throw new Error(
      'if assetSats is 0, need to issue a least 1 token satoshi.',
    );
  }
}
exports.validateAddIssuanceArgs = validateAddIssuanceArgs;
function validateAddReissuanceArgs(args) {
  if (!args.nonWitnessUtxo && !args.witnessUtxo) {
    throw new Error('need witnessUtxo or nonWitnessUtxo');
  }
  if (args.assetSats <= 0) {
    throw new Error('asset amount must be greater than zero.');
  }
  if (args.tokenSats < 0) {
    throw new Error('token amount must be positive.');
  }
  if (args.tokenPrevout.txHash.length !== 32) {
    throw new Error('invalid token output hash');
  }
  if (args.prevoutBlinder.length !== 32) {
    throw new Error('invalid blinder');
  }
  // it's mandatory for the token prevout to be confidential. This because the
  // prevout value blinder will be used as the reissuance's blinding nonce to
  // prove that the spender actually owns and can unblind the token output.
  if (!isPrevoutConfidential(args)) {
    throw new Error('token prevout must be confidential');
  }
  if (args.entropy.length !== 32) {
    throw new Error('invalid entropy');
  }
  if (!(0, address_1.isConfidential)(args.tokenAddress)) {
    throw new Error('token address must be confidential');
  }
  if (!(0, address_1.isConfidential)(args.assetAddress)) {
    throw new Error('asset address must be confidential');
  }
}
exports.validateAddReissuanceArgs = validateAddReissuanceArgs;
function isPrevoutConfidential(args) {
  if (args.witnessUtxo && isConfidentialWitnessUtxo(args.witnessUtxo)) {
    return true;
  }
  if (
    args.nonWitnessUtxo &&
    isConfidentialWitnessUtxo(
      transaction_1.Transaction.fromBuffer(args.nonWitnessUtxo).outs[
        args.tokenPrevout.vout
      ],
    )
  ) {
    return true;
  }
  return false;
}
function isConfidentialWitnessUtxo(witnessUtxo) {
  return (
    witnessUtxo.rangeProof !== undefined &&
    witnessUtxo.surjectionProof !== undefined &&
    !witnessUtxo.nonce.equals(Buffer.of(0x00))
  );
}
function checkForOutput(outputs, outputIndex) {
  const output = outputs[outputIndex];
  if (output === undefined) throw new Error(`No output #${outputIndex}`);
  return output;
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"./address":79,"./bufferutils":83,"./confidential":84,"./crypto":85,"./issuance":87,"./networks":88,"./payments":91,"./script":101,"./transaction":105,"bip174-liquid":25,"bip174-liquid/src/lib/converter/varint":21,"bip174-liquid/src/lib/utils":27,"buffer":110,"ecpair":37,"randombytes":45}],100:[function(require,module,exports){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
exports.decode = exports.encode = exports.encodingLength = void 0;
const ops_1 = require('./ops');
function encodingLength(i) {
  return i < ops_1.OPS.OP_PUSHDATA1 ? 1 : i <= 0xff ? 2 : i <= 0xffff ? 3 : 5;
}
exports.encodingLength = encodingLength;
function encode(buffer, num, offset) {
  const size = encodingLength(num);
  // ~6 bit
  if (size === 1) {
    buffer.writeUInt8(num, offset);
    // 8 bit
  } else if (size === 2) {
    buffer.writeUInt8(ops_1.OPS.OP_PUSHDATA1, offset);
    buffer.writeUInt8(num, offset + 1);
    // 16 bit
  } else if (size === 3) {
    buffer.writeUInt8(ops_1.OPS.OP_PUSHDATA2, offset);
    buffer.writeUInt16LE(num, offset + 1);
    // 32 bit
  } else {
    buffer.writeUInt8(ops_1.OPS.OP_PUSHDATA4, offset);
    buffer.writeUInt32LE(num, offset + 1);
  }
  return size;
}
exports.encode = encode;
function decode(buffer, offset) {
  const opcode = buffer.readUInt8(offset);
  let num;
  let size;
  // ~6 bit
  if (opcode < ops_1.OPS.OP_PUSHDATA1) {
    num = opcode;
    size = 1;
    // 8 bit
  } else if (opcode === ops_1.OPS.OP_PUSHDATA1) {
    if (offset + 2 > buffer.length) return null;
    num = buffer.readUInt8(offset + 1);
    size = 2;
    // 16 bit
  } else if (opcode === ops_1.OPS.OP_PUSHDATA2) {
    if (offset + 3 > buffer.length) return null;
    num = buffer.readUInt16LE(offset + 1);
    size = 3;
    // 32 bit
  } else {
    if (offset + 5 > buffer.length) return null;
    if (opcode !== ops_1.OPS.OP_PUSHDATA4) throw new Error('Unexpected opcode');
    num = buffer.readUInt32LE(offset + 1);
    size = 5;
  }
  return {
    opcode,
    number: num,
    size,
  };
}
exports.decode = decode;

},{"./ops":89}],101:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';
var __createBinding =
  (this && this.__createBinding) ||
  (Object.create
    ? function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (
          !desc ||
          ('get' in desc ? !m.__esModule : desc.writable || desc.configurable)
        ) {
          desc = {
            enumerable: true,
            get: function() {
              return m[k];
            },
          };
        }
        Object.defineProperty(o, k2, desc);
      }
    : function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
      });
var __setModuleDefault =
  (this && this.__setModuleDefault) ||
  (Object.create
    ? function(o, v) {
        Object.defineProperty(o, 'default', { enumerable: true, value: v });
      }
    : function(o, v) {
        o['default'] = v;
      });
var __importStar =
  (this && this.__importStar) ||
  function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null)
      for (var k in mod)
        if (k !== 'default' && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
  };
Object.defineProperty(exports, '__esModule', { value: true });
exports.signature = exports.number = exports.isCanonicalScriptSignature = exports.isDefinedHashType = exports.isCanonicalPubKey = exports.toStack = exports.fromASM = exports.toASM = exports.decompile = exports.compile = exports.isPushOnly = exports.OPS = void 0;
const bip66 = __importStar(require('./bip66'));
const ops_1 = require('./ops');
Object.defineProperty(exports, 'OPS', {
  enumerable: true,
  get: function() {
    return ops_1.OPS;
  },
});
const pushdata = __importStar(require('./push_data'));
const scriptNumber = __importStar(require('./script_number'));
const scriptSignature = __importStar(require('./script_signature'));
const types = __importStar(require('./types'));
const { typeforce } = types;
const OP_INT_BASE = ops_1.OPS.OP_RESERVED; // OP_1 - 1
function isOPInt(value) {
  return (
    types.Number(value) &&
    (value === ops_1.OPS.OP_0 ||
      (value >= ops_1.OPS.OP_1 && value <= ops_1.OPS.OP_16) ||
      value === ops_1.OPS.OP_1NEGATE)
  );
}
function isPushOnlyChunk(value) {
  return types.Buffer(value) || isOPInt(value);
}
function isPushOnly(value) {
  return types.Array(value) && value.every(isPushOnlyChunk);
}
exports.isPushOnly = isPushOnly;
function asMinimalOP(buffer) {
  if (buffer.length === 0) return ops_1.OPS.OP_0;
  if (buffer.length !== 1) return;
  if (buffer[0] >= 1 && buffer[0] <= 16) return OP_INT_BASE + buffer[0];
  if (buffer[0] === 0x81) return ops_1.OPS.OP_1NEGATE;
}
function chunksIsBuffer(buf) {
  return Buffer.isBuffer(buf);
}
function chunksIsArray(buf) {
  return types.Array(buf);
}
function singleChunkIsBuffer(buf) {
  return Buffer.isBuffer(buf);
}
function compile(chunks) {
  // TODO: remove me
  if (chunksIsBuffer(chunks)) return chunks;
  typeforce(types.Array, chunks);
  const bufferSize = chunks.reduce((accum, chunk) => {
    // data chunk
    if (singleChunkIsBuffer(chunk)) {
      // adhere to BIP62.3, minimal push policy
      if (chunk.length === 1 && asMinimalOP(chunk) !== undefined) {
        return accum + 1;
      }
      return accum + pushdata.encodingLength(chunk.length) + chunk.length;
    }
    // opcode
    return accum + 1;
  }, 0.0);
  const buffer = Buffer.allocUnsafe(bufferSize);
  let offset = 0;
  chunks.forEach(chunk => {
    // data chunk
    if (singleChunkIsBuffer(chunk)) {
      // adhere to BIP62.3, minimal push policy
      const opcode = asMinimalOP(chunk);
      if (opcode !== undefined) {
        buffer.writeUInt8(opcode, offset);
        offset += 1;
        return;
      }
      offset += pushdata.encode(buffer, chunk.length, offset);
      chunk.copy(buffer, offset);
      offset += chunk.length;
      // opcode
    } else {
      buffer.writeUInt8(chunk, offset);
      offset += 1;
    }
  });
  if (offset !== buffer.length) throw new Error('Could not decode chunks');
  return buffer;
}
exports.compile = compile;
function decompile(buffer) {
  // TODO: remove me
  if (chunksIsArray(buffer)) return buffer;
  typeforce(types.Buffer, buffer);
  const chunks = [];
  let i = 0;
  while (i < buffer.length) {
    const opcode = buffer[i];
    // data chunk
    if (opcode > ops_1.OPS.OP_0 && opcode <= ops_1.OPS.OP_PUSHDATA4) {
      const d = pushdata.decode(buffer, i);
      // did reading a pushDataInt fail?
      if (d === null) return null;
      i += d.size;
      // attempt to read too much data?
      if (i + d.number > buffer.length) return null;
      const data = buffer.slice(i, i + d.number);
      i += d.number;
      // decompile minimally
      const op = asMinimalOP(data);
      if (op !== undefined) {
        chunks.push(op);
      } else {
        chunks.push(data);
      }
      // opcode
    } else {
      chunks.push(opcode);
      i += 1;
    }
  }
  return chunks;
}
exports.decompile = decompile;
function toASM(chunks) {
  if (chunksIsBuffer(chunks)) {
    chunks = decompile(chunks);
  }
  return chunks
    .map(chunk => {
      // data?
      if (singleChunkIsBuffer(chunk)) {
        const op = asMinimalOP(chunk);
        if (op === undefined) return chunk.toString('hex');
        chunk = op;
      }
      // opcode!
      return ops_1.REVERSE_OPS[chunk];
    })
    .join(' ');
}
exports.toASM = toASM;
function fromASM(asm) {
  typeforce(types.String, asm);
  return compile(
    asm.split(' ').map(chunkStr => {
      // opcode?
      if (ops_1.OPS[chunkStr] !== undefined) return ops_1.OPS[chunkStr];
      typeforce(types.Hex, chunkStr);
      // data!
      return Buffer.from(chunkStr, 'hex');
    }),
  );
}
exports.fromASM = fromASM;
function toStack(chunks) {
  chunks = decompile(chunks);
  typeforce(isPushOnly, chunks);
  return chunks.map(op => {
    if (singleChunkIsBuffer(op)) return op;
    if (op === ops_1.OPS.OP_0) return Buffer.allocUnsafe(0);
    return scriptNumber.encode(op - OP_INT_BASE);
  });
}
exports.toStack = toStack;
function isCanonicalPubKey(buffer) {
  return types.isPoint(buffer);
}
exports.isCanonicalPubKey = isCanonicalPubKey;
function isDefinedHashType(hashType) {
  const hashTypeMod = hashType & ~0x80;
  // return hashTypeMod > SIGHASH_ALL && hashTypeMod < SIGHASH_SINGLE
  return hashTypeMod > 0x00 && hashTypeMod < 0x04;
}
exports.isDefinedHashType = isDefinedHashType;
function isCanonicalScriptSignature(buffer) {
  if (!Buffer.isBuffer(buffer)) return false;
  if (!isDefinedHashType(buffer[buffer.length - 1])) return false;
  return bip66.check(buffer.slice(0, -1));
}
exports.isCanonicalScriptSignature = isCanonicalScriptSignature;
// tslint:disable-next-line variable-name
exports.number = scriptNumber;
exports.signature = scriptSignature;

}).call(this)}).call(this,require("buffer").Buffer)
},{"./bip66":82,"./ops":89,"./push_data":100,"./script_number":102,"./script_signature":103,"./types":106,"buffer":110}],102:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
exports.encode = exports.decode = void 0;
function decode(buffer, maxLength, minimal) {
  maxLength = maxLength || 4;
  minimal = minimal === undefined ? true : minimal;
  const length = buffer.length;
  if (length === 0) return 0;
  if (length > maxLength) throw new TypeError('Script number overflow');
  if (minimal) {
    if ((buffer[length - 1] & 0x7f) === 0) {
      if (length <= 1 || (buffer[length - 2] & 0x80) === 0)
        throw new Error('Non-minimally encoded script number');
    }
  }
  // 40-bit
  if (length === 5) {
    const a = buffer.readUInt32LE(0);
    const b = buffer.readUInt8(4);
    if (b & 0x80) return -((b & ~0x80) * 0x100000000 + a);
    return b * 0x100000000 + a;
  }
  // 32-bit / 24-bit / 16-bit / 8-bit
  let result = 0;
  for (let i = 0; i < length; ++i) {
    result |= buffer[i] << (8 * i);
  }
  if (buffer[length - 1] & 0x80)
    return -(result & ~(0x80 << (8 * (length - 1))));
  return result;
}
exports.decode = decode;
function scriptNumSize(i) {
  return i > 0x7fffffff
    ? 5
    : i > 0x7fffff
    ? 4
    : i > 0x7fff
    ? 3
    : i > 0x7f
    ? 2
    : i > 0x00
    ? 1
    : 0;
}
function encode(_number) {
  let value = Math.abs(_number);
  const size = scriptNumSize(value);
  const buffer = Buffer.allocUnsafe(size);
  const negative = _number < 0;
  for (let i = 0; i < size; ++i) {
    buffer.writeUInt8(value & 0xff, i);
    value >>= 8;
  }
  if (buffer[size - 1] & 0x80) {
    buffer.writeUInt8(negative ? 0x80 : 0x00, size - 1);
  } else if (negative) {
    buffer[size - 1] |= 0x80;
  }
  return buffer;
}
exports.encode = encode;

}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":110}],103:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';
var __createBinding =
  (this && this.__createBinding) ||
  (Object.create
    ? function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (
          !desc ||
          ('get' in desc ? !m.__esModule : desc.writable || desc.configurable)
        ) {
          desc = {
            enumerable: true,
            get: function() {
              return m[k];
            },
          };
        }
        Object.defineProperty(o, k2, desc);
      }
    : function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
      });
var __setModuleDefault =
  (this && this.__setModuleDefault) ||
  (Object.create
    ? function(o, v) {
        Object.defineProperty(o, 'default', { enumerable: true, value: v });
      }
    : function(o, v) {
        o['default'] = v;
      });
var __importStar =
  (this && this.__importStar) ||
  function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null)
      for (var k in mod)
        if (k !== 'default' && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
  };
Object.defineProperty(exports, '__esModule', { value: true });
exports.encode = exports.decode = void 0;
const bip66 = __importStar(require('./bip66'));
const types = __importStar(require('./types'));
const { typeforce } = types;
const ZERO = Buffer.alloc(1, 0);
function toDER(x) {
  let i = 0;
  while (x[i] === 0) ++i;
  if (i === x.length) return ZERO;
  x = x.slice(i);
  if (x[0] & 0x80) return Buffer.concat([ZERO, x], 1 + x.length);
  return x;
}
function fromDER(x) {
  if (x[0] === 0x00) x = x.slice(1);
  const buffer = Buffer.alloc(32, 0);
  const bstart = Math.max(0, 32 - x.length);
  x.copy(buffer, bstart);
  return buffer;
}
// BIP62: 1 byte hashType flag (only 0x01, 0x02, 0x03, 0x81, 0x82 and 0x83 are allowed)
function decode(buffer) {
  const hashType = buffer.readUInt8(buffer.length - 1);
  const hashTypeMod = hashType & ~0x80;
  if (hashTypeMod <= 0 || hashTypeMod >= 4)
    throw new Error('Invalid hashType ' + hashType);
  const decoded = bip66.decode(buffer.slice(0, -1));
  const r = fromDER(decoded.r);
  const s = fromDER(decoded.s);
  const signature = Buffer.concat([r, s], 64);
  return { signature, hashType };
}
exports.decode = decode;
function encode(signature, hashType) {
  typeforce(
    {
      signature: types.BufferN(64),
      hashType: types.UInt8,
    },
    { signature, hashType },
  );
  const hashTypeMod = hashType & ~0x80;
  if (hashTypeMod <= 0 || hashTypeMod >= 4)
    throw new Error('Invalid hashType ' + hashType);
  const hashTypeBuffer = Buffer.allocUnsafe(1);
  hashTypeBuffer.writeUInt8(hashType, 0);
  const r = toDER(signature.slice(0, 32));
  const s = toDER(signature.slice(32, 64));
  return Buffer.concat([bip66.encode(r, s), hashTypeBuffer]);
}
exports.encode = encode;

}).call(this)}).call(this,require("buffer").Buffer)
},{"./bip66":82,"./types":106,"buffer":110}],104:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
exports.sha256Midstate = exports.hash = exports.Hash = exports.blockSize = exports.digestLength = void 0;
// SHA-256 (+ HMAC and PBKDF2) for JavaScript.
//
// Written in 2014-2016 by Dmitry Chestnykh.
// Public domain, no warranty.
//
// Functions (accept and return Uint8Arrays):
//
//   sha256(message) -> hash
//   sha256.hmac(key, message) -> mac
//   sha256.pbkdf2(password, salt, rounds, dkLen) -> dk
//
//  Classes:
//
//   new sha256.Hash()
//   new sha256.HMAC(key)
//
exports.digestLength = 32;
exports.blockSize = 64;
// SHA-256 constants
const K = new Uint32Array([
  0x428a2f98,
  0x71374491,
  0xb5c0fbcf,
  0xe9b5dba5,
  0x3956c25b,
  0x59f111f1,
  0x923f82a4,
  0xab1c5ed5,
  0xd807aa98,
  0x12835b01,
  0x243185be,
  0x550c7dc3,
  0x72be5d74,
  0x80deb1fe,
  0x9bdc06a7,
  0xc19bf174,
  0xe49b69c1,
  0xefbe4786,
  0x0fc19dc6,
  0x240ca1cc,
  0x2de92c6f,
  0x4a7484aa,
  0x5cb0a9dc,
  0x76f988da,
  0x983e5152,
  0xa831c66d,
  0xb00327c8,
  0xbf597fc7,
  0xc6e00bf3,
  0xd5a79147,
  0x06ca6351,
  0x14292967,
  0x27b70a85,
  0x2e1b2138,
  0x4d2c6dfc,
  0x53380d13,
  0x650a7354,
  0x766a0abb,
  0x81c2c92e,
  0x92722c85,
  0xa2bfe8a1,
  0xa81a664b,
  0xc24b8b70,
  0xc76c51a3,
  0xd192e819,
  0xd6990624,
  0xf40e3585,
  0x106aa070,
  0x19a4c116,
  0x1e376c08,
  0x2748774c,
  0x34b0bcb5,
  0x391c0cb3,
  0x4ed8aa4a,
  0x5b9cca4f,
  0x682e6ff3,
  0x748f82ee,
  0x78a5636f,
  0x84c87814,
  0x8cc70208,
  0x90befffa,
  0xa4506ceb,
  0xbef9a3f7,
  0xc67178f2,
]);
function hashBlocks(w, v, p, pos, len) {
  let a;
  let b;
  let c;
  let d;
  let e;
  let f;
  let g;
  let h;
  let u;
  let i;
  let j;
  let t1;
  let t2;
  while (len >= 64) {
    a = v[0];
    b = v[1];
    c = v[2];
    d = v[3];
    e = v[4];
    f = v[5];
    g = v[6];
    h = v[7];
    for (i = 0; i < 16; i++) {
      j = pos + i * 4;
      w[i] =
        ((p[j] & 0xff) << 24) |
        ((p[j + 1] & 0xff) << 16) |
        ((p[j + 2] & 0xff) << 8) |
        (p[j + 3] & 0xff);
    }
    for (i = 16; i < 64; i++) {
      u = w[i - 2];
      t1 =
        ((u >>> 17) | (u << (32 - 17))) ^
        ((u >>> 19) | (u << (32 - 19))) ^
        (u >>> 10);
      u = w[i - 15];
      t2 =
        ((u >>> 7) | (u << (32 - 7))) ^
        ((u >>> 18) | (u << (32 - 18))) ^
        (u >>> 3);
      w[i] = ((t1 + w[i - 7]) | 0) + ((t2 + w[i - 16]) | 0);
    }
    for (i = 0; i < 64; i++) {
      t1 =
        ((((((e >>> 6) | (e << (32 - 6))) ^
          ((e >>> 11) | (e << (32 - 11))) ^
          ((e >>> 25) | (e << (32 - 25)))) +
          ((e & f) ^ (~e & g))) |
          0) +
          ((h + ((K[i] + w[i]) | 0)) | 0)) |
        0;
      t2 =
        ((((a >>> 2) | (a << (32 - 2))) ^
          ((a >>> 13) | (a << (32 - 13))) ^
          ((a >>> 22) | (a << (32 - 22)))) +
          ((a & b) ^ (a & c) ^ (b & c))) |
        0;
      h = g;
      g = f;
      f = e;
      e = (d + t1) | 0;
      d = c;
      c = b;
      b = a;
      a = (t1 + t2) | 0;
    }
    v[0] += a;
    v[1] += b;
    v[2] += c;
    v[3] += d;
    v[4] += e;
    v[5] += f;
    v[6] += g;
    v[7] += h;
    pos += 64;
    len -= 64;
  }
  return pos;
}
// Hash implements SHA256 hash algorithm.
class Hash {
  constructor() {
    this.digestLength = exports.digestLength;
    this.blockSize = exports.blockSize;
    this.finished = false; // indicates whether the hash was finalized
    // Note: Int32Array is used instead of Uint32Array for performance reasons.
    this.state = new Int32Array(8); // hash state
    this.temp = new Int32Array(64); // temporary state
    this.buffer = new Uint8Array(128); // buffer for data to hash
    this.bufferLength = 0; // number of bytes in buffer
    this.bytesHashed = 0; // number of total bytes hashed
    this.reset();
  }
  // Resets hash state making it possible
  // to re-use this instance to hash other data.
  reset() {
    this.state[0] = 0x6a09e667;
    this.state[1] = 0xbb67ae85;
    this.state[2] = 0x3c6ef372;
    this.state[3] = 0xa54ff53a;
    this.state[4] = 0x510e527f;
    this.state[5] = 0x9b05688c;
    this.state[6] = 0x1f83d9ab;
    this.state[7] = 0x5be0cd19;
    this.bufferLength = 0;
    this.bytesHashed = 0;
    this.finished = false;
    return this;
  }
  // Cleans internal buffers and re-initializes hash state.
  clean() {
    for (let i = 0; i < this.buffer.length; i++) {
      this.buffer[i] = 0;
    }
    for (let i = 0; i < this.temp.length; i++) {
      this.temp[i] = 0;
    }
    this.reset();
  }
  // Updates hash state with the given data.
  //
  // Optionally, length of the data can be specified to hash
  // fewer bytes than data.length.
  //
  // Throws error when trying to update already finalized hash:
  // instance must be reset to use it again.
  update(data, dataLength = data.length) {
    if (this.finished) {
      throw new Error("SHA256: can't update because hash was finished.");
    }
    let dataPos = 0;
    this.bytesHashed += dataLength;
    if (this.bufferLength > 0) {
      while (this.bufferLength < 64 && dataLength > 0) {
        this.buffer[this.bufferLength++] = data[dataPos++];
        dataLength--;
      }
      if (this.bufferLength === 64) {
        hashBlocks(this.temp, this.state, this.buffer, 0, 64);
        this.bufferLength = 0;
      }
    }
    if (dataLength >= 64) {
      dataPos = hashBlocks(this.temp, this.state, data, dataPos, dataLength);
      dataLength %= 64;
    }
    while (dataLength > 0) {
      this.buffer[this.bufferLength++] = data[dataPos++];
      dataLength--;
    }
    return this;
  }
  // Finalizes hash state and puts hash into out.
  //
  // If hash was already finalized, puts the same value.
  finish(out) {
    if (!this.finished) {
      const bytesHashed = this.bytesHashed;
      const left = this.bufferLength;
      const bitLenHi = (bytesHashed / 0x20000000) | 0;
      const bitLenLo = bytesHashed << 3;
      const padLength = bytesHashed % 64 < 56 ? 64 : 128;
      this.buffer[left] = 0x80;
      for (let i = left + 1; i < padLength - 8; i++) {
        this.buffer[i] = 0;
      }
      this.buffer[padLength - 8] = (bitLenHi >>> 24) & 0xff;
      this.buffer[padLength - 7] = (bitLenHi >>> 16) & 0xff;
      this.buffer[padLength - 6] = (bitLenHi >>> 8) & 0xff;
      this.buffer[padLength - 5] = (bitLenHi >>> 0) & 0xff;
      this.buffer[padLength - 4] = (bitLenLo >>> 24) & 0xff;
      this.buffer[padLength - 3] = (bitLenLo >>> 16) & 0xff;
      this.buffer[padLength - 2] = (bitLenLo >>> 8) & 0xff;
      this.buffer[padLength - 1] = (bitLenLo >>> 0) & 0xff;
      hashBlocks(this.temp, this.state, this.buffer, 0, padLength);
      this.finished = true;
    }
    for (let i = 0; i < 8; i++) {
      out[i * 4 + 0] = (this.state[i] >>> 24) & 0xff;
      out[i * 4 + 1] = (this.state[i] >>> 16) & 0xff;
      out[i * 4 + 2] = (this.state[i] >>> 8) & 0xff;
      out[i * 4 + 3] = (this.state[i] >>> 0) & 0xff;
    }
    return this;
  }
  // Returns the final hash digest.
  digest() {
    const out = new Uint8Array(this.digestLength);
    this.finish(out);
    return out;
  }
  // Internal function for use in HMAC for optimization.
  _saveState(out) {
    for (let i = 0; i < this.state.length; i++) {
      out[i] = this.state[i];
    }
  }
  // Internal function for use in HMAC for optimization.
  _restoreState(from, bytesHashed) {
    for (let i = 0; i < this.state.length; i++) {
      this.state[i] = from[i];
    }
    this.bytesHashed = bytesHashed;
    this.finished = false;
    this.bufferLength = 0;
  }
}
exports.Hash = Hash;
// Returns SHA256 hash of data.
function hash(data) {
  const h = new Hash().update(data);
  const digest = h.digest();
  h.clean();
  return digest;
}
exports.hash = hash;
function sha256Midstate(data) {
  let d = data;
  if (data.length > exports.blockSize) {
    d = data.slice(0, exports.blockSize);
  }
  const h = new Hash();
  h.reset();
  h.update(Uint8Array.from(d));
  const midstate = Buffer.alloc(exports.digestLength);
  for (let i = 0; i < 8; i++) {
    midstate[i * 4 + 0] = (h.state[i] >>> 24) & 0xff;
    midstate[i * 4 + 1] = (h.state[i] >>> 16) & 0xff;
    midstate[i * 4 + 2] = (h.state[i] >>> 8) & 0xff;
    midstate[i * 4 + 3] = (h.state[i] >>> 0) & 0xff;
  }
  return midstate;
}
exports.sha256Midstate = sha256Midstate;

}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":110}],105:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';
var __createBinding =
  (this && this.__createBinding) ||
  (Object.create
    ? function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (
          !desc ||
          ('get' in desc ? !m.__esModule : desc.writable || desc.configurable)
        ) {
          desc = {
            enumerable: true,
            get: function() {
              return m[k];
            },
          };
        }
        Object.defineProperty(o, k2, desc);
      }
    : function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
      });
var __setModuleDefault =
  (this && this.__setModuleDefault) ||
  (Object.create
    ? function(o, v) {
        Object.defineProperty(o, 'default', { enumerable: true, value: v });
      }
    : function(o, v) {
        o['default'] = v;
      });
var __importStar =
  (this && this.__importStar) ||
  function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null)
      for (var k in mod)
        if (k !== 'default' && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
  };
Object.defineProperty(exports, '__esModule', { value: true });
exports.Transaction = exports.ZERO = void 0;
const bufferutils_1 = require('./bufferutils');
const bcrypto = __importStar(require('./crypto'));
const bscript = __importStar(require('./script'));
const script_1 = require('./script');
const types = __importStar(require('./types'));
const { typeforce } = types;
const EMPTY_BUFFER = Buffer.allocUnsafe(0);
const EMPTY_WITNESS = [];
exports.ZERO = Buffer.from(
  '0000000000000000000000000000000000000000000000000000000000000000',
  'hex',
);
const ONE = Buffer.from(
  '0000000000000000000000000000000000000000000000000000000000000001',
  'hex',
);
const WITNESS_SCALE_FACTOR = 4;
const OUTPOINT_ISSUANCE_FLAG = (1 << 31) >>> 0;
const OUTPOINT_PEGIN_FLAG = (1 << 30) >>> 0;
const OUTPOINT_INDEX_MASK = 0x3fffffff;
const MINUS_1 = 4294967295;
const VALUE_UINT64_MAX = Buffer.from('ffffffffffffffff', 'hex');
const BLANK_OUTPUT = {
  script: EMPTY_BUFFER,
  asset: exports.ZERO,
  nonce: exports.ZERO,
  valueBuffer: VALUE_UINT64_MAX,
};
class Transaction {
  constructor() {
    this.version = 1;
    this.locktime = 0;
    this.flag = 0;
    this.ins = [];
    this.outs = [];
  }
  static fromBuffer(buffer, _NO_STRICT) {
    const bufferReader = new bufferutils_1.BufferReader(buffer);
    const tx = new Transaction();
    tx.version = bufferReader.readInt32();
    tx.flag = bufferReader.readUInt8();
    let hasWitnesses = false;
    if (tx.flag & Transaction.ADVANCED_TRANSACTION_FLAG) {
      hasWitnesses = true;
    }
    const vinLen = bufferReader.readVarInt();
    for (let i = 0; i < vinLen; ++i) {
      const inHash = bufferReader.readSlice(32);
      let inIndex = bufferReader.readUInt32();
      const inScript = bufferReader.readVarSlice();
      const inSequence = bufferReader.readUInt32();
      let inIsPegin = false;
      let inIssuance;
      if (inIndex !== MINUS_1) {
        if (inIndex & OUTPOINT_ISSUANCE_FLAG) {
          inIssuance = bufferReader.readIssuance();
        }
        if (inIndex & OUTPOINT_PEGIN_FLAG) {
          inIsPegin = true;
        }
        inIndex &= OUTPOINT_INDEX_MASK;
      }
      tx.ins.push({
        hash: inHash,
        index: inIndex,
        script: inScript,
        sequence: inSequence,
        witness: EMPTY_WITNESS,
        isPegin: inIsPegin,
        issuance: inIssuance,
        peginWitness: EMPTY_WITNESS,
        issuanceRangeProof: EMPTY_BUFFER,
        inflationRangeProof: EMPTY_BUFFER,
      });
    }
    const voutLen = bufferReader.readVarInt();
    for (let i = 0; i < voutLen; ++i) {
      const asset = bufferReader.readConfidentialAsset();
      const value = bufferReader.readConfidentialValue();
      const nonce = bufferReader.readConfidentialNonce();
      const script = bufferReader.readVarSlice();
      tx.outs.push({
        asset,
        value,
        nonce,
        script,
        rangeProof: EMPTY_BUFFER,
        surjectionProof: EMPTY_BUFFER,
      });
    }
    tx.locktime = bufferReader.readUInt32();
    if (hasWitnesses) {
      for (let i = 0; i < vinLen; ++i) {
        const {
          witness,
          peginWitness,
          issuanceRangeProof,
          inflationRangeProof,
        } = bufferReader.readConfidentialInFields();
        tx.ins[i].witness = witness;
        tx.ins[i].peginWitness = peginWitness;
        tx.ins[i].issuanceRangeProof = issuanceRangeProof;
        tx.ins[i].inflationRangeProof = inflationRangeProof;
      }
      for (let i = 0; i < voutLen; ++i) {
        const {
          rangeProof,
          surjectionProof,
        } = bufferReader.readConfidentialOutFields();
        tx.outs[i].rangeProof = rangeProof;
        tx.outs[i].surjectionProof = surjectionProof;
      }
    }
    if (_NO_STRICT) return tx;
    if (bufferReader.offset !== buffer.length)
      throw new Error('Transaction has unexpected data');
    return tx;
  }
  static fromHex(hex) {
    return Transaction.fromBuffer(Buffer.from(hex, 'hex'), false);
  }
  static isCoinbaseHash(buffer) {
    typeforce(types.Hash256bit, buffer);
    for (let i = 0; i < 32; ++i) {
      if (buffer[i] !== 0) return false;
    }
    return true;
  }
  isCoinbase() {
    return (
      this.ins.length === 1 && Transaction.isCoinbaseHash(this.ins[0].hash)
    );
  }
  // A quick and reliable way to validate that all the buffers are of correct type and length
  validateIssuance(assetBlindingNonce, assetEntropy, assetAmount, tokenAmount) {
    typeforce(types.Hash256bit, assetBlindingNonce);
    typeforce(types.Hash256bit, assetEntropy);
    typeforce(
      types.oneOf(
        types.ConfidentialValue,
        types.ConfidentialCommitment,
        types.BufferOne,
      ),
      assetAmount,
    );
    typeforce(
      types.oneOf(
        types.ConfidentialValue,
        types.ConfidentialCommitment,
        types.BufferOne,
      ),
      tokenAmount,
    );
    return true;
  }
  addInput(hash, index, sequence, scriptSig, issuance) {
    typeforce(
      types.tuple(
        types.Hash256bit,
        types.UInt32,
        types.maybe(types.UInt32),
        types.maybe(types.Buffer),
        types.maybe(types.Object),
      ),
      arguments,
    );
    let isPegin = false;
    if (index !== MINUS_1) {
      if (index & OUTPOINT_ISSUANCE_FLAG) {
        if (!issuance) {
          throw new Error(
            'Issuance flag has been set but the Issuance object is not defined or invalid',
          );
        } else
          this.validateIssuance(
            issuance.assetBlindingNonce,
            issuance.assetEntropy,
            issuance.assetAmount,
            issuance.tokenAmount,
          );
      }
      if (index & OUTPOINT_PEGIN_FLAG) {
        isPegin = true;
      }
      index &= OUTPOINT_INDEX_MASK;
    }
    // Add the input and return the input's index
    return (
      this.ins.push({
        hash,
        index,
        isPegin,
        issuance,
        script: scriptSig || EMPTY_BUFFER,
        witness: EMPTY_WITNESS,
        peginWitness: EMPTY_WITNESS,
        issuanceRangeProof: EMPTY_BUFFER,
        inflationRangeProof: EMPTY_BUFFER,
        sequence: sequence || Transaction.DEFAULT_SEQUENCE,
      }) - 1
    );
  }
  addOutput(scriptPubKey, value, asset, nonce, rangeProof, surjectionProof) {
    typeforce(
      types.tuple(
        types.Buffer,
        types.oneOf(types.ConfidentialValue, types.ConfidentialCommitment),
        types.AssetBufferWithFlag,
        types.oneOf(types.ConfidentialCommitment, types.BufferOne),
        types.maybe(types.Buffer),
        types.maybe(types.Buffer),
      ),
      arguments,
    );
    // Add the output and return the output's index
    return (
      this.outs.push({
        script: scriptPubKey,
        value,
        asset,
        nonce: nonce || EMPTY_BUFFER,
        rangeProof: rangeProof || EMPTY_BUFFER,
        surjectionProof: surjectionProof || EMPTY_BUFFER,
      }) - 1
    );
  }
  hasWitnesses() {
    return (
      this.flag === 1 ||
      this.ins.some(x => {
        return x.witness.length !== 0;
      }) ||
      this.outs.some(x => {
        return x.rangeProof.length !== 0 && x.surjectionProof.length !== 0;
      })
    );
  }
  weight() {
    const base = this.__byteLength(false);
    const total = this.__byteLength(true);
    return base * (WITNESS_SCALE_FACTOR - 1) + total;
  }
  virtualSize() {
    const vsize =
      (this.weight() + WITNESS_SCALE_FACTOR - 1) / WITNESS_SCALE_FACTOR;
    return Math.floor(vsize);
  }
  byteLength(_ALLOW_WITNESS) {
    return this.__byteLength(_ALLOW_WITNESS || true);
  }
  clone() {
    const newTx = new Transaction();
    newTx.version = this.version;
    newTx.locktime = this.locktime;
    newTx.flag = this.flag;
    newTx.ins = this.ins.map(txIn => {
      return {
        hash: txIn.hash,
        index: txIn.index,
        script: txIn.script,
        sequence: txIn.sequence,
        witness: txIn.witness,
        isPegin: txIn.isPegin,
        issuance: txIn.issuance,
        peginWitness: txIn.peginWitness,
        issuanceRangeProof: txIn.issuanceRangeProof,
        inflationRangeProof: txIn.inflationRangeProof,
      };
    });
    newTx.outs = this.outs.map(txOut => {
      return {
        script: txOut.script,
        value: txOut.value,
        asset: txOut.asset,
        nonce: txOut.nonce,
        rangeProof: txOut.rangeProof,
        surjectionProof: txOut.surjectionProof,
      };
    });
    return newTx;
  }
  /**
   * Hash transaction for signing a specific input.
   *
   * Bitcoin uses a different hash for each signed transaction input.
   * This method copies the transaction, makes the necessary changes based on the
   * hashType, and then hashes the result.
   * This hash can then be used to sign the provided transaction input.
   */
  hashForSignature(inIndex, prevOutScript, hashType) {
    typeforce(
      types.tuple(types.UInt32, types.Buffer, /* types.UInt8 */ types.Number),
      arguments,
    );
    // https://github.com/bitcoin/bitcoin/blob/master/src/test/sighash_tests.cpp#L29
    if (inIndex >= this.ins.length) return ONE;
    // ignore OP_CODESEPARATOR
    const ourScript = bscript.compile(
      bscript.decompile(prevOutScript).filter(x => {
        return x !== script_1.OPS.OP_CODESEPARATOR;
      }),
    );
    const txTmp = this.clone();
    // SIGHASH_NONE: ignore all outputs? (wildcard payee)
    if ((hashType & 0x1f) === Transaction.SIGHASH_NONE) {
      txTmp.outs = [];
      // ignore sequence numbers (except at inIndex)
      txTmp.ins.forEach((input, i) => {
        if (i === inIndex) return;
        input.sequence = 0;
      });
      // SIGHASH_SINGLE: ignore all outputs, except at the same index?
    } else if ((hashType & 0x1f) === Transaction.SIGHASH_SINGLE) {
      // https://github.com/bitcoin/bitcoin/blob/master/src/test/sighash_tests.cpp#L60
      if (inIndex >= this.outs.length) return ONE;
      // truncate outputs after
      txTmp.outs.length = inIndex + 1;
      // "blank" outputs before
      for (let i = 0; i < inIndex; i++) {
        txTmp.outs[i] = BLANK_OUTPUT;
      }
      // ignore sequence numbers (except at inIndex)
      txTmp.ins.forEach((input, y) => {
        if (y === inIndex) return;
        input.sequence = 0;
      });
    }
    // SIGHASH_ANYONECANPAY: ignore inputs entirely?
    if (hashType & Transaction.SIGHASH_ANYONECANPAY) {
      txTmp.ins = [txTmp.ins[inIndex]];
      txTmp.ins[0].script = ourScript;
      // SIGHASH_ALL: only ignore input scripts
    } else {
      // "blank" others input scripts
      txTmp.ins.forEach(input => {
        input.script = EMPTY_BUFFER;
      });
      txTmp.ins[inIndex].script = ourScript;
    }
    // serialize and hash
    const buffer = Buffer.allocUnsafe(txTmp.__byteLength(false, true) + 4);
    buffer.writeInt32LE(hashType, buffer.length - 4);
    txTmp.__toBuffer(buffer, 0, false, true, true);
    return bcrypto.hash256(buffer);
  }
  // differs from bitcoin core
  // https://github.com/ElementsProject/elements/blob/84b3f7b0045b50a585d60e56e77e8914b6cf6040/doc/taproot-sighash.mediawiki
  hashForWitnessV1(
    inIndex,
    prevOutScripts,
    prevoutAssetsValues,
    hashType,
    genesisBlockHash,
    leafHash,
    annex,
  ) {
    typeforce(
      types.tuple(
        types.UInt32,
        typeforce.arrayOf(types.Buffer),
        typeforce.arrayOf(types.Object),
        types.UInt32,
      ),
      arguments,
    );
    if (prevOutScripts.length !== this.ins.length) {
      throw new Error('Must supply prevout script and value for all inputs');
    }
    const outputType =
      hashType === Transaction.SIGHASH_DEFAULT
        ? Transaction.SIGHASH_ALL
        : hashType & Transaction.SIGHASH_OUTPUT_MASK;
    const inputType = hashType & Transaction.SIGHASH_INPUT_MASK;
    const isAnyoneCanPay = inputType === Transaction.SIGHASH_ANYONECANPAY;
    const isNone = outputType === Transaction.SIGHASH_NONE;
    const isSingle = outputType === Transaction.SIGHASH_SINGLE;
    let hashPrevouts = EMPTY_BUFFER;
    let hashSequences = EMPTY_BUFFER;
    let hashOutputs = EMPTY_BUFFER;
    let hashIssuances = EMPTY_BUFFER;
    let hashScriptPubKeys = EMPTY_BUFFER;
    // elements new hashes for witness  v1
    let hashOutpointsFlags = EMPTY_BUFFER;
    let hashIssuancesProofs = EMPTY_BUFFER;
    let hashOutputsWitnesses = EMPTY_BUFFER;
    let hashSpentAssetsAmounts = EMPTY_BUFFER;
    if (!isAnyoneCanPay) {
      hashPrevouts = getPrevoutsSHA256(this.ins);
      hashOutpointsFlags = getOutpointFlagsSHA256(this.ins);
      hashSpentAssetsAmounts = getSpentAssetsAmountsSHA256(prevoutAssetsValues);
      hashIssuancesProofs = getIssuanceProofsSHA256(this.ins);
      hashScriptPubKeys = getPrevoutScriptsSHA256(prevOutScripts);
      hashSequences = getSequenceSHA256(this.ins);
      hashIssuances = getIssuanceSHA256(this.ins);
    }
    if (!(isNone || isSingle)) {
      hashOutputs = getOutputsSHA256(this.outs);
      hashOutputsWitnesses = getOutputWitnessesSHA256(this.outs);
    } else if (isSingle && inIndex < this.outs.length) {
      const output = this.outs[inIndex];
      hashOutputs = getOutputsSHA256([output]);
      hashOutputsWitnesses = getOutputWitnessesSHA256([output]);
    }
    // key-path spent or a tapscript (annex is for future update)
    const spendType = (leafHash ? 2 : 0) + (annex ? 1 : 0);
    // Length calculation from:
    // https://github.com/ElementsProject/elements/blob/84b3f7b0045b50a585d60e56e77e8914b6cf6040/doc/taproot-sighash.mediawiki
    const inputPartSize = isAnyoneCanPay
      ? 1 +
        32 +
        4 +
        prevoutAssetsValues[inIndex].asset.length +
        prevoutAssetsValues[inIndex].value.length +
        (0, bufferutils_1.varSliceSize)(prevOutScripts[inIndex]) +
        4 +
        (this.ins[inIndex].issuance ? getIssuanceSize(this.ins[inIndex]) : 1)
      : 4;
    const fullMsgSize = 32 * 2 + 1 + 4 + 4 + 1 + inputPartSize;
    const sigMsgSize =
      fullMsgSize +
      (!isAnyoneCanPay ? 7 * 32 : 0) +
      (!(isNone || isSingle) ? 32 + 32 : 0) +
      (annex ? 32 : 0) +
      (isSingle ? 32 + 32 : 0) +
      (leafHash ? 37 : 0);
    const sigMsgWriter = bufferutils_1.BufferWriter.withCapacity(sigMsgSize);
    // this is "blockchain rationale", only used in elements
    // it prevents signatures to be reused accross different Elements instance
    sigMsgWriter.writeSlice(genesisBlockHash);
    sigMsgWriter.writeSlice(genesisBlockHash);
    sigMsgWriter.writeUInt8(hashType);
    // Transaction
    sigMsgWriter.writeInt32(this.version);
    sigMsgWriter.writeUInt32(this.locktime);
    if (!isAnyoneCanPay) {
      sigMsgWriter.writeSlice(hashOutpointsFlags);
      sigMsgWriter.writeSlice(hashPrevouts);
      sigMsgWriter.writeSlice(hashSpentAssetsAmounts);
      sigMsgWriter.writeSlice(hashScriptPubKeys);
      sigMsgWriter.writeSlice(hashSequences);
      sigMsgWriter.writeSlice(hashIssuances);
      sigMsgWriter.writeSlice(hashIssuancesProofs);
    }
    if (!(isNone || isSingle)) {
      sigMsgWriter.writeSlice(hashOutputs);
      sigMsgWriter.writeSlice(hashOutputsWitnesses);
    }
    // Input
    sigMsgWriter.writeUInt8(spendType);
    if (isAnyoneCanPay) {
      const input = this.ins[inIndex];
      sigMsgWriter.writeUInt8(getInputFlag(input));
      sigMsgWriter.writeSlice(input.hash);
      sigMsgWriter.writeUInt32(input.index);
      sigMsgWriter.writeSlice(prevoutAssetsValues[inIndex].asset);
      sigMsgWriter.writeSlice(prevoutAssetsValues[inIndex].value);
      sigMsgWriter.writeVarSlice(prevOutScripts[inIndex]);
      sigMsgWriter.writeUInt32(input.sequence);
      if (input.issuance) {
        sigMsgWriter.writeSlice(input.issuance.assetBlindingNonce);
        sigMsgWriter.writeSlice(input.issuance.assetEntropy);
        sigMsgWriter.writeSlice(input.issuance.assetAmount);
        sigMsgWriter.writeSlice(input.issuance.tokenAmount);
        const bufferWriter = bufferutils_1.BufferWriter.withCapacity(
          (0, bufferutils_1.varSliceSize)(input.issuanceRangeProof) +
            (0, bufferutils_1.varSliceSize)(input.inflationRangeProof),
        );
        bufferWriter.writeVarSlice(input.issuanceRangeProof || Buffer.of(0x00));
        bufferWriter.writeVarSlice(
          input.inflationRangeProof || Buffer.of(0x00),
        );
        const hashIssuance = bcrypto.sha256(bufferWriter.end());
        sigMsgWriter.writeSlice(hashIssuance);
      } else {
        sigMsgWriter.writeSlice(Buffer.of(0x00));
      }
    } else {
      sigMsgWriter.writeUInt32(inIndex);
    }
    if (annex) {
      const bufferWriter = bufferutils_1.BufferWriter.withCapacity(
        (0, bufferutils_1.varSliceSize)(annex),
      );
      bufferWriter.writeVarSlice(annex);
      sigMsgWriter.writeSlice(bcrypto.sha256(bufferWriter.end()));
    }
    if (isSingle) {
      sigMsgWriter.writeSlice(hashOutputs);
      sigMsgWriter.writeSlice(hashOutputsWitnesses);
    }
    // BIP342 extension
    if (leafHash) {
      sigMsgWriter.writeSlice(leafHash);
      sigMsgWriter.writeUInt8(0);
      sigMsgWriter.writeUInt32(0xffffffff);
    }
    return bcrypto.taggedHash('TapSighash/elements', sigMsgWriter.end());
  }
  hashForWitnessV0(inIndex, prevOutScript, value, hashType) {
    typeforce(
      types.tuple(types.UInt32, types.Buffer, types.Buffer, types.UInt32),
      arguments,
    );
    let hashOutputs = exports.ZERO;
    let hashPrevouts = exports.ZERO;
    let hashSequence = exports.ZERO;
    let hashIssuances = exports.ZERO;
    // Inputs
    if (!(hashType & Transaction.SIGHASH_ANYONECANPAY)) {
      const prevoutsHashWriter = bufferutils_1.BufferWriter.withCapacity(
        (32 + 4) * this.ins.length,
      );
      this.ins.forEach(txIn => {
        prevoutsHashWriter.writeSlice(txIn.hash);
        prevoutsHashWriter.writeUInt32(txIn.index);
      });
      hashPrevouts = bcrypto.hash256(prevoutsHashWriter.end());
    }
    // Sequences
    if (
      !(hashType & Transaction.SIGHASH_ANYONECANPAY) &&
      (hashType & 0x1f) !== Transaction.SIGHASH_SINGLE &&
      (hashType & 0x1f) !== Transaction.SIGHASH_NONE
    ) {
      const sequenceHashWriter = bufferutils_1.BufferWriter.withCapacity(
        4 * this.ins.length,
      );
      this.ins.forEach(txIn => {
        sequenceHashWriter.writeUInt32(txIn.sequence);
      });
      hashSequence = bcrypto.hash256(sequenceHashWriter.end());
    }
    // Issuances
    if (!(hashType & Transaction.SIGHASH_ANYONECANPAY)) {
      const sizeOfIssuances = this.ins.reduce(
        (sum, txIn) => (txIn.issuance ? sum + getIssuanceSize(txIn) : sum + 1),
        0,
      );
      const size = sizeOfIssuances === 0 ? this.ins.length : sizeOfIssuances;
      const issuancesHashWriter = bufferutils_1.BufferWriter.withCapacity(size);
      this.ins.forEach(txIn => {
        if (txIn.issuance) {
          issuancesHashWriter.writeSlice(txIn.issuance.assetBlindingNonce);
          issuancesHashWriter.writeSlice(txIn.issuance.assetEntropy);
          issuancesHashWriter.writeSlice(txIn.issuance.assetAmount);
          issuancesHashWriter.writeSlice(txIn.issuance.tokenAmount);
        } else {
          issuancesHashWriter.writeSlice(Buffer.of(0x00));
        }
      });
      hashIssuances = bcrypto.hash256(issuancesHashWriter.end());
    }
    // Outputs
    if (
      (hashType & 0x1f) !== Transaction.SIGHASH_SINGLE &&
      (hashType & 0x1f) !== Transaction.SIGHASH_NONE
    ) {
      const txOutsSize = this.outs.reduce(
        (sum, output) =>
          sum +
          output.asset.length +
          output.value.length +
          output.nonce.length +
          (0, bufferutils_1.varSliceSize)(output.script),
        0,
      );
      const outputsHashWriter = bufferutils_1.BufferWriter.withCapacity(
        txOutsSize,
      );
      this.outs.forEach(out => {
        outputsHashWriter.writeSlice(out.asset);
        outputsHashWriter.writeSlice(out.value);
        outputsHashWriter.writeSlice(out.nonce);
        outputsHashWriter.writeVarSlice(out.script);
      });
      hashOutputs = bcrypto.hash256(outputsHashWriter.end());
    } else if (
      (hashType & 0x1f) === Transaction.SIGHASH_SINGLE &&
      inIndex < this.outs.length
    ) {
      const output = this.outs[inIndex];
      const size =
        output.asset.length +
        output.value.length +
        output.nonce.length +
        (0, bufferutils_1.varSliceSize)(output.script);
      const outputsHashWriter = bufferutils_1.BufferWriter.withCapacity(size);
      outputsHashWriter.writeSlice(output.asset);
      outputsHashWriter.writeSlice(output.value);
      outputsHashWriter.writeSlice(output.nonce);
      outputsHashWriter.writeVarSlice(output.script);
      hashOutputs = bcrypto.hash256(outputsHashWriter.end());
    }
    const input = this.ins[inIndex];
    const hasIssuance = input.issuance !== undefined;
    const bufferSize =
      4 + // version
      hashPrevouts.length +
      hashSequence.length +
      hashIssuances.length +
      input.hash.length +
      4 + // input.index
      (0, bufferutils_1.varSliceSize)(prevOutScript) +
      value.length +
      4 + // input.sequence
      hashOutputs.length +
      getIssuanceSize(input) +
      4 + // locktime
      4; // hashType
    const sigWriter = bufferutils_1.BufferWriter.withCapacity(bufferSize);
    sigWriter.writeUInt32(this.version);
    sigWriter.writeSlice(hashPrevouts);
    sigWriter.writeSlice(hashSequence);
    sigWriter.writeSlice(hashIssuances);
    sigWriter.writeSlice(input.hash);
    sigWriter.writeUInt32(input.index);
    sigWriter.writeVarSlice(prevOutScript);
    sigWriter.writeSlice(value);
    sigWriter.writeUInt32(input.sequence);
    if (hasIssuance) {
      sigWriter.writeSlice(input.issuance.assetBlindingNonce);
      sigWriter.writeSlice(input.issuance.assetEntropy);
      sigWriter.writeSlice(input.issuance.assetAmount);
      sigWriter.writeSlice(input.issuance.tokenAmount);
    }
    sigWriter.writeSlice(hashOutputs);
    sigWriter.writeUInt32(this.locktime);
    sigWriter.writeUInt32(hashType);
    return bcrypto.hash256(sigWriter.end());
  }
  getHash(forWitness) {
    // wtxid for coinbase is always 32 bytes of 0x00
    if (forWitness && this.isCoinbase()) return Buffer.alloc(32, 0);
    return bcrypto.hash256(
      this.__toBuffer(undefined, undefined, forWitness, true),
    );
  }
  getId() {
    // transaction hash's are displayed in reverse order
    return (0, bufferutils_1.reverseBuffer)(this.getHash(false)).toString(
      'hex',
    );
  }
  toBuffer(buffer, initialOffset) {
    return this.__toBuffer(buffer, initialOffset, true, false);
  }
  toHex() {
    return this.toBuffer(undefined, undefined).toString('hex');
  }
  setInputScript(index, scriptSig) {
    typeforce(types.tuple(types.Number, types.Buffer), arguments);
    this.ins[index].script = scriptSig;
  }
  setWitness(index, witness) {
    typeforce(types.tuple(types.Number, [types.Buffer]), arguments);
    this.ins[index].witness = witness;
  }
  setPeginWitness(index, peginWitness) {
    typeforce(types.tuple(types.Number, [types.Buffer]), arguments);
    this.ins[index].peginWitness = peginWitness;
  }
  setInputIssuanceRangeProof(index, issuanceRangeProof) {
    typeforce(types.tuple(types.Buffer), arguments);
    if (this.ins[index].issuance === undefined)
      throw new Error('Issuance not set for input #' + index);
    this.ins[index].issuanceRangeProof = issuanceRangeProof;
  }
  setInputInflationRangeProof(index, inflationRangeProof) {
    typeforce(types.tuple(types.Buffer), arguments);
    if (this.ins[index].issuance === undefined)
      throw new Error('Issuance not set for input #' + index);
    this.ins[index].inflationRangeProof = inflationRangeProof;
  }
  setOutputNonce(index, nonce) {
    typeforce(types.tuple(types.Number, types.Buffer), arguments);
    this.outs[index].nonce = nonce;
  }
  setOutputRangeProof(index, proof) {
    typeforce(types.tuple(types.Number, types.Buffer), arguments);
    this.outs[index].rangeProof = proof;
  }
  setOutputSurjectionProof(index, proof) {
    typeforce(types.tuple(types.Number, types.Buffer), arguments);
    this.outs[index].surjectionProof = proof;
  }
  __byteLength(_ALLOW_WITNESS, forSignature) {
    const extraByte = forSignature ? 0 : 1;
    let size =
      8 +
      extraByte +
      bufferutils_1.varuint.encodingLength(this.ins.length) +
      bufferutils_1.varuint.encodingLength(this.outs.length);
    for (const txIn of this.ins) {
      size += 40 + (0, bufferutils_1.varSliceSize)(txIn.script);
      if (txIn.issuance) {
        size +=
          64 +
          txIn.issuance.assetAmount.length +
          txIn.issuance.tokenAmount.length;
      }
    }
    for (const txOut of this.outs) {
      size +=
        txOut.asset.length +
        txOut.value.length +
        txOut.nonce.length +
        (0, bufferutils_1.varSliceSize)(txOut.script);
    }
    if (_ALLOW_WITNESS && this.hasWitnesses()) {
      for (const txIn of this.ins) {
        size += (0, bufferutils_1.varSliceSize)(txIn.issuanceRangeProof);
        size += (0, bufferutils_1.varSliceSize)(txIn.inflationRangeProof);
        size += bufferutils_1.varuint.encodingLength(txIn.witness.length);
        for (const wit of txIn.witness) {
          size += (0, bufferutils_1.varSliceSize)(wit);
        }
        size += bufferutils_1.varuint.encodingLength(
          (txIn.peginWitness || []).length,
        );
        for (const wit of txIn.peginWitness || []) {
          size += (0, bufferutils_1.varSliceSize)(wit);
        }
      }
      for (const txOut of this.outs) {
        size += (0, bufferutils_1.varSliceSize)(txOut.surjectionProof);
        size += (0, bufferutils_1.varSliceSize)(txOut.rangeProof);
      }
    }
    return size;
  }
  __toBuffer(
    buffer,
    initialOffset,
    _ALLOW_WITNESS,
    forceZeroFlag,
    forSignature,
  ) {
    if (!buffer)
      buffer = Buffer.allocUnsafe(
        this.__byteLength(_ALLOW_WITNESS, forSignature),
      );
    const bufferWriter = new bufferutils_1.BufferWriter(
      buffer,
      initialOffset || 0,
    );
    bufferWriter.writeInt32(this.version);
    const hasWitnesses = _ALLOW_WITNESS && this.hasWitnesses();
    if (!forSignature) {
      let flags = 0;
      if (hasWitnesses && !forceZeroFlag) {
        flags |= Transaction.ADVANCED_TRANSACTION_FLAG;
      }
      bufferWriter.writeUInt8(flags);
    }
    bufferWriter.writeVarInt(this.ins.length);
    this.ins.forEach(txIn => {
      bufferWriter.writeSlice(txIn.hash);
      let prevIndex = txIn.index;
      if (txIn.issuance) {
        prevIndex = (prevIndex | OUTPOINT_ISSUANCE_FLAG) >>> 0;
      }
      if (txIn.isPegin) {
        prevIndex = (prevIndex | OUTPOINT_PEGIN_FLAG) >>> 0;
      }
      bufferWriter.writeUInt32(prevIndex);
      bufferWriter.writeVarSlice(txIn.script);
      bufferWriter.writeUInt32(txIn.sequence);
      if (txIn.issuance) {
        bufferWriter.writeSlice(txIn.issuance.assetBlindingNonce);
        bufferWriter.writeSlice(txIn.issuance.assetEntropy);
        bufferWriter.writeSlice(txIn.issuance.assetAmount);
        bufferWriter.writeSlice(txIn.issuance.tokenAmount);
      }
    });
    bufferWriter.writeVarInt(this.outs.length);
    this.outs.forEach(txOut => {
      // if we are serializing a confidential output for producing a signature,
      // we must exclude the confidential value from the serialization and
      // use the satoshi 0 value instead, as done for typical bitcoin witness signatures.
      const val = forSignature && hasWitnesses ? Buffer.alloc(1) : txOut.value;
      bufferWriter.writeSlice(txOut.asset);
      bufferWriter.writeSlice(val);
      bufferWriter.writeSlice(txOut.nonce);
      if (forSignature && hasWitnesses) bufferWriter.writeUInt64(0);
      bufferWriter.writeVarSlice(txOut.script);
    });
    bufferWriter.writeUInt32(this.locktime);
    if (!forSignature && hasWitnesses) {
      this.ins.forEach(input => {
        bufferWriter.writeConfidentialInFields(input);
      });
      this.outs.forEach(output => {
        bufferWriter.writeConfidentialOutFields(output);
      });
    }
    // avoid slicing unless necessary
    if (initialOffset !== undefined)
      return buffer.slice(initialOffset, bufferWriter.offset);
    return buffer;
  }
}
exports.Transaction = Transaction;
Transaction.DEFAULT_SEQUENCE = 0xffffffff;
Transaction.SIGHASH_DEFAULT = 0x00;
Transaction.SIGHASH_ALL = 0x01;
Transaction.SIGHASH_NONE = 0x02;
Transaction.SIGHASH_SINGLE = 0x03;
Transaction.SIGHASH_ANYONECANPAY = 0x80;
Transaction.SIGHASH_OUTPUT_MASK = 0x03;
Transaction.SIGHASH_INPUT_MASK = 0x80;
Transaction.ADVANCED_TRANSACTION_FLAG = 0x01;
function getOutputWitnessesSHA256(outs) {
  const outProofsSize = o =>
    (0, bufferutils_1.varSliceSize)(o.rangeProof || Buffer.alloc(0)) +
    (0, bufferutils_1.varSliceSize)(o.surjectionProof || Buffer.alloc(0));
  const size = outs.reduce((sum, o) => sum + outProofsSize(o), 0);
  const bufferWriter = bufferutils_1.BufferWriter.withCapacity(size);
  for (const out of outs) {
    bufferWriter.writeVarSlice(out.surjectionProof || Buffer.of(0x00));
    bufferWriter.writeVarSlice(out.rangeProof || Buffer.of(0x00));
  }
  return bcrypto.sha256(bufferWriter.end());
}
function getIssuanceProofsSHA256(ins) {
  const inProofsSize = i =>
    (0, bufferutils_1.varSliceSize)(i.issuanceRangeProof || Buffer.alloc(1)) +
    (0, bufferutils_1.varSliceSize)(i.inflationRangeProof || Buffer.alloc(1));
  const size = ins.reduce((sum, i) => sum + inProofsSize(i), 0);
  const bufferWriter = bufferutils_1.BufferWriter.withCapacity(size);
  for (const input of ins) {
    bufferWriter.writeVarSlice(input.issuanceRangeProof || Buffer.of(0x00));
    bufferWriter.writeVarSlice(input.inflationRangeProof || Buffer.of(0x00));
  }
  return bcrypto.sha256(bufferWriter.end());
}
function getSpentAssetsAmountsSHA256(outs) {
  const size = outs.reduce(
    (sum, o) => sum + o.asset.length + o.value.length,
    0,
  );
  const bufferWriter = bufferutils_1.BufferWriter.withCapacity(size);
  for (const out of outs) {
    bufferWriter.writeSlice(out.asset);
    bufferWriter.writeSlice(out.value);
  }
  return bcrypto.sha256(bufferWriter.end());
}
function getInputFlag(input) {
  const hasIssuance = input.issuance !== undefined;
  return (
    (hasIssuance ? OUTPOINT_ISSUANCE_FLAG >>> 24 : 0) |
    (input.isPegin ? OUTPOINT_PEGIN_FLAG >>> 24 : 0)
  );
}
function getOutpointFlagsSHA256(ins) {
  const bufferWriter = bufferutils_1.BufferWriter.withCapacity(ins.length);
  for (const input of ins) {
    bufferWriter.writeUInt8(getInputFlag(input));
  }
  return bcrypto.sha256(bufferWriter.end());
}
function getIssuanceSize(txIn) {
  if (txIn.issuance) {
    return (
      txIn.issuance.assetBlindingNonce.length +
      txIn.issuance.assetEntropy.length +
      txIn.issuance.assetAmount.length +
      txIn.issuance.tokenAmount.length
    );
  }
  return 0;
}
function getPrevoutsSHA256(inputs) {
  const bufferWriter = bufferutils_1.BufferWriter.withCapacity(
    inputs.length * (32 + 4),
  );
  for (const i of inputs) {
    bufferWriter.writeSlice(i.hash);
    bufferWriter.writeUInt32(i.index);
  }
  return bcrypto.sha256(bufferWriter.end());
}
function getPrevoutScriptsSHA256(scripts) {
  const bufferWriter = bufferutils_1.BufferWriter.withCapacity(
    scripts.map(bufferutils_1.varSliceSize).reduce((a, b) => a + b),
  );
  scripts.forEach(prevOutScript => bufferWriter.writeVarSlice(prevOutScript));
  return bcrypto.sha256(bufferWriter.end());
}
function getSequenceSHA256(inputs) {
  const bufferWriter = bufferutils_1.BufferWriter.withCapacity(
    4 * inputs.length,
  );
  inputs.forEach(txIn => bufferWriter.writeUInt32(txIn.sequence));
  return bcrypto.sha256(bufferWriter.end());
}
function getIssuanceSHA256(inputs) {
  const sizeOfIssuances = inputs.reduce(
    (sum, txIn) => (txIn.issuance ? sum + getIssuanceSize(txIn) : sum + 1),
    0,
  );
  const size = sizeOfIssuances === 0 ? inputs.length : sizeOfIssuances;
  const writer = bufferutils_1.BufferWriter.withCapacity(size);
  inputs.forEach(txIn => {
    if (txIn.issuance) {
      writer.writeSlice(txIn.issuance.assetBlindingNonce);
      writer.writeSlice(txIn.issuance.assetEntropy);
      writer.writeSlice(txIn.issuance.assetAmount);
      writer.writeSlice(txIn.issuance.tokenAmount);
    } else {
      writer.writeSlice(Buffer.of(0x00));
    }
  });
  return bcrypto.sha256(writer.end());
}
function getOutputsSHA256(outputs) {
  const txOutsSize = outputs.reduce(
    (sum, output) =>
      sum +
      output.asset.length +
      output.value.length +
      output.nonce.length +
      (0, bufferutils_1.varSliceSize)(output.script),
    0,
  );
  const bufferWriter = bufferutils_1.BufferWriter.withCapacity(txOutsSize);
  outputs.forEach(out => {
    bufferWriter.writeSlice(out.asset);
    bufferWriter.writeSlice(out.value);
    bufferWriter.writeSlice(out.nonce);
    bufferWriter.writeVarSlice(out.script);
  });
  return bcrypto.sha256(bufferWriter.end());
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"./bufferutils":83,"./crypto":85,"./script":101,"./types":106,"buffer":110}],106:[function(require,module,exports){
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
exports.oneOf = exports.Null = exports.BufferN = exports.Function = exports.UInt32 = exports.UInt8 = exports.tuple = exports.maybe = exports.Object = exports.Hex = exports.Buffer = exports.String = exports.Boolean = exports.Array = exports.Number = exports.BufferOne = exports.ConfidentialValue = exports.AssetBuffer = exports.AssetBufferWithFlag = exports.ConfidentialCommitment = exports.Hash256bit = exports.Hash160bit = exports.Buffer256bit = exports.Network = exports.ECPoint = exports.Signer = exports.BIP32Path = exports.UInt31 = exports.isPoint = exports.typeforce = void 0;
const buffer_1 = require('buffer');
exports.typeforce = require('typeforce');
const ZERO32 = buffer_1.Buffer.alloc(32, 0);
const EC_P = buffer_1.Buffer.from(
  'fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f',
  'hex',
);
function isPoint(p) {
  if (!buffer_1.Buffer.isBuffer(p)) return false;
  if (p.length < 33) return false;
  const t = p[0];
  const x = p.slice(1, 33);
  if (x.compare(ZERO32) === 0) return false;
  if (x.compare(EC_P) >= 0) return false;
  if ((t === 0x02 || t === 0x03) && p.length === 33) {
    return true;
  }
  const y = p.slice(33);
  if (y.compare(ZERO32) === 0) return false;
  if (y.compare(EC_P) >= 0) return false;
  if (t === 0x04 && p.length === 65) return true;
  return false;
}
exports.isPoint = isPoint;
const UINT31_MAX = Math.pow(2, 31) - 1;
function UInt31(value) {
  return exports.typeforce.UInt32(value) && value <= UINT31_MAX;
}
exports.UInt31 = UInt31;
function BIP32Path(value) {
  return (
    exports.typeforce.String(value) && !!value.match(/^(m\/)?(\d+'?\/)*\d+'?$/)
  );
}
exports.BIP32Path = BIP32Path;
BIP32Path.toJSON = () => {
  return 'BIP32 derivation path';
};
function Signer(obj) {
  return (
    (exports.typeforce.Buffer(obj.publicKey) ||
      typeof obj.getPublicKey === 'function') &&
    typeof obj.sign === 'function'
  );
}
exports.Signer = Signer;
// external dependent types
exports.ECPoint = exports.typeforce.quacksLike('Point');
// exposed, external API
exports.Network = exports.typeforce.compile({
  messagePrefix: exports.typeforce.oneOf(
    exports.typeforce.Buffer,
    exports.typeforce.String,
  ),
  bip32: {
    public: exports.typeforce.UInt32,
    private: exports.typeforce.UInt32,
  },
  pubKeyHash: exports.typeforce.UInt8,
  scriptHash: exports.typeforce.UInt8,
  wif: exports.typeforce.UInt8,
  assetHash: exports.typeforce.String,
  confidentialPrefix: exports.typeforce.UInt8,
});
exports.Buffer256bit = exports.typeforce.BufferN(32);
exports.Hash160bit = exports.typeforce.BufferN(20);
exports.Hash256bit = exports.typeforce.BufferN(32);
exports.ConfidentialCommitment = exports.typeforce.BufferN(33);
exports.AssetBufferWithFlag = exports.typeforce.BufferN(33);
exports.AssetBuffer = exports.typeforce.BufferN(32);
exports.ConfidentialValue = exports.typeforce.BufferN(9);
exports.BufferOne = exports.typeforce.BufferN(1);
exports.Number = exports.typeforce.Number; // tslint:disable-line variable-name
exports.Array = exports.typeforce.Array;
exports.Boolean = exports.typeforce.Boolean; // tslint:disable-line variable-name
exports.String = exports.typeforce.String; // tslint:disable-line variable-name
exports.Buffer = exports.typeforce.Buffer;
exports.Hex = exports.typeforce.Hex;
exports.Object = exports.typeforce.Object;
exports.maybe = exports.typeforce.maybe;
exports.tuple = exports.typeforce.tuple;
exports.UInt8 = exports.typeforce.UInt8;
exports.UInt32 = exports.typeforce.UInt32;
exports.Function = exports.typeforce.Function;
exports.BufferN = exports.typeforce.BufferN;
exports.Null = exports.typeforce.Null;
exports.oneOf = exports.typeforce.oneOf;

},{"buffer":110,"typeforce":74}],107:[function(require,module,exports){

},{}],108:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],109:[function(require,module,exports){
arguments[4][107][0].apply(exports,arguments)
},{"dup":107}],110:[function(require,module,exports){
(function (Buffer){(function (){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species != null &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value)
  }

  if (value == null) {
    throw TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
          : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"base64-js":108,"buffer":110,"ieee754":112}],111:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }

    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    };

    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}

function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}

function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}

},{}],112:[function(require,module,exports){
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],113:[function(require,module,exports){
arguments[4][42][0].apply(exports,arguments)
},{"dup":42}],114:[function(require,module,exports){
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
}

function isBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
}

},{}],115:[function(require,module,exports){
(function (process){(function (){
// 'path' module extracted from Node.js v8.11.1 (only the posix part)
// transplited with Babel

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

function assertPath(path) {
  if (typeof path !== 'string') {
    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));
  }
}

// Resolves . and .. elements in a path with directory names
function normalizeStringPosix(path, allowAboveRoot) {
  var res = '';
  var lastSegmentLength = 0;
  var lastSlash = -1;
  var dots = 0;
  var code;
  for (var i = 0; i <= path.length; ++i) {
    if (i < path.length)
      code = path.charCodeAt(i);
    else if (code === 47 /*/*/)
      break;
    else
      code = 47 /*/*/;
    if (code === 47 /*/*/) {
      if (lastSlash === i - 1 || dots === 1) {
        // NOOP
      } else if (lastSlash !== i - 1 && dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {
          if (res.length > 2) {
            var lastSlashIndex = res.lastIndexOf('/');
            if (lastSlashIndex !== res.length - 1) {
              if (lastSlashIndex === -1) {
                res = '';
                lastSegmentLength = 0;
              } else {
                res = res.slice(0, lastSlashIndex);
                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');
              }
              lastSlash = i;
              dots = 0;
              continue;
            }
          } else if (res.length === 2 || res.length === 1) {
            res = '';
            lastSegmentLength = 0;
            lastSlash = i;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          if (res.length > 0)
            res += '/..';
          else
            res = '..';
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0)
          res += '/' + path.slice(lastSlash + 1, i);
        else
          res = path.slice(lastSlash + 1, i);
        lastSegmentLength = i - lastSlash - 1;
      }
      lastSlash = i;
      dots = 0;
    } else if (code === 46 /*.*/ && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}

function _format(sep, pathObject) {
  var dir = pathObject.dir || pathObject.root;
  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');
  if (!dir) {
    return base;
  }
  if (dir === pathObject.root) {
    return dir + base;
  }
  return dir + sep + base;
}

var posix = {
  // path.resolve([from ...], to)
  resolve: function resolve() {
    var resolvedPath = '';
    var resolvedAbsolute = false;
    var cwd;

    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
      var path;
      if (i >= 0)
        path = arguments[i];
      else {
        if (cwd === undefined)
          cwd = process.cwd();
        path = cwd;
      }

      assertPath(path);

      // Skip empty entries
      if (path.length === 0) {
        continue;
      }

      resolvedPath = path + '/' + resolvedPath;
      resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;
    }

    // At this point the path should be resolved to a full absolute path, but
    // handle relative paths to be safe (might happen when process.cwd() fails)

    // Normalize the path
    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);

    if (resolvedAbsolute) {
      if (resolvedPath.length > 0)
        return '/' + resolvedPath;
      else
        return '/';
    } else if (resolvedPath.length > 0) {
      return resolvedPath;
    } else {
      return '.';
    }
  },

  normalize: function normalize(path) {
    assertPath(path);

    if (path.length === 0) return '.';

    var isAbsolute = path.charCodeAt(0) === 47 /*/*/;
    var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;

    // Normalize the path
    path = normalizeStringPosix(path, !isAbsolute);

    if (path.length === 0 && !isAbsolute) path = '.';
    if (path.length > 0 && trailingSeparator) path += '/';

    if (isAbsolute) return '/' + path;
    return path;
  },

  isAbsolute: function isAbsolute(path) {
    assertPath(path);
    return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;
  },

  join: function join() {
    if (arguments.length === 0)
      return '.';
    var joined;
    for (var i = 0; i < arguments.length; ++i) {
      var arg = arguments[i];
      assertPath(arg);
      if (arg.length > 0) {
        if (joined === undefined)
          joined = arg;
        else
          joined += '/' + arg;
      }
    }
    if (joined === undefined)
      return '.';
    return posix.normalize(joined);
  },

  relative: function relative(from, to) {
    assertPath(from);
    assertPath(to);

    if (from === to) return '';

    from = posix.resolve(from);
    to = posix.resolve(to);

    if (from === to) return '';

    // Trim any leading backslashes
    var fromStart = 1;
    for (; fromStart < from.length; ++fromStart) {
      if (from.charCodeAt(fromStart) !== 47 /*/*/)
        break;
    }
    var fromEnd = from.length;
    var fromLen = fromEnd - fromStart;

    // Trim any leading backslashes
    var toStart = 1;
    for (; toStart < to.length; ++toStart) {
      if (to.charCodeAt(toStart) !== 47 /*/*/)
        break;
    }
    var toEnd = to.length;
    var toLen = toEnd - toStart;

    // Compare paths to find the longest common path from root
    var length = fromLen < toLen ? fromLen : toLen;
    var lastCommonSep = -1;
    var i = 0;
    for (; i <= length; ++i) {
      if (i === length) {
        if (toLen > length) {
          if (to.charCodeAt(toStart + i) === 47 /*/*/) {
            // We get here if `from` is the exact base path for `to`.
            // For example: from='/foo/bar'; to='/foo/bar/baz'
            return to.slice(toStart + i + 1);
          } else if (i === 0) {
            // We get here if `from` is the root
            // For example: from='/'; to='/foo'
            return to.slice(toStart + i);
          }
        } else if (fromLen > length) {
          if (from.charCodeAt(fromStart + i) === 47 /*/*/) {
            // We get here if `to` is the exact base path for `from`.
            // For example: from='/foo/bar/baz'; to='/foo/bar'
            lastCommonSep = i;
          } else if (i === 0) {
            // We get here if `to` is the root.
            // For example: from='/foo'; to='/'
            lastCommonSep = 0;
          }
        }
        break;
      }
      var fromCode = from.charCodeAt(fromStart + i);
      var toCode = to.charCodeAt(toStart + i);
      if (fromCode !== toCode)
        break;
      else if (fromCode === 47 /*/*/)
        lastCommonSep = i;
    }

    var out = '';
    // Generate the relative path based on the path difference between `to`
    // and `from`
    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
      if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {
        if (out.length === 0)
          out += '..';
        else
          out += '/..';
      }
    }

    // Lastly, append the rest of the destination (`to`) path that comes after
    // the common path parts
    if (out.length > 0)
      return out + to.slice(toStart + lastCommonSep);
    else {
      toStart += lastCommonSep;
      if (to.charCodeAt(toStart) === 47 /*/*/)
        ++toStart;
      return to.slice(toStart);
    }
  },

  _makeLong: function _makeLong(path) {
    return path;
  },

  dirname: function dirname(path) {
    assertPath(path);
    if (path.length === 0) return '.';
    var code = path.charCodeAt(0);
    var hasRoot = code === 47 /*/*/;
    var end = -1;
    var matchedSlash = true;
    for (var i = path.length - 1; i >= 1; --i) {
      code = path.charCodeAt(i);
      if (code === 47 /*/*/) {
          if (!matchedSlash) {
            end = i;
            break;
          }
        } else {
        // We saw the first non-path separator
        matchedSlash = false;
      }
    }

    if (end === -1) return hasRoot ? '/' : '.';
    if (hasRoot && end === 1) return '//';
    return path.slice(0, end);
  },

  basename: function basename(path, ext) {
    if (ext !== undefined && typeof ext !== 'string') throw new TypeError('"ext" argument must be a string');
    assertPath(path);

    var start = 0;
    var end = -1;
    var matchedSlash = true;
    var i;

    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
      if (ext.length === path.length && ext === path) return '';
      var extIdx = ext.length - 1;
      var firstNonSlashEnd = -1;
      for (i = path.length - 1; i >= 0; --i) {
        var code = path.charCodeAt(i);
        if (code === 47 /*/*/) {
            // If we reached a path separator that was not part of a set of path
            // separators at the end of the string, stop now
            if (!matchedSlash) {
              start = i + 1;
              break;
            }
          } else {
          if (firstNonSlashEnd === -1) {
            // We saw the first non-path separator, remember this index in case
            // we need it if the extension ends up not matching
            matchedSlash = false;
            firstNonSlashEnd = i + 1;
          }
          if (extIdx >= 0) {
            // Try to match the explicit extension
            if (code === ext.charCodeAt(extIdx)) {
              if (--extIdx === -1) {
                // We matched the extension, so mark this as the end of our path
                // component
                end = i;
              }
            } else {
              // Extension does not match, so our result is the entire path
              // component
              extIdx = -1;
              end = firstNonSlashEnd;
            }
          }
        }
      }

      if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;
      return path.slice(start, end);
    } else {
      for (i = path.length - 1; i >= 0; --i) {
        if (path.charCodeAt(i) === 47 /*/*/) {
            // If we reached a path separator that was not part of a set of path
            // separators at the end of the string, stop now
            if (!matchedSlash) {
              start = i + 1;
              break;
            }
          } else if (end === -1) {
          // We saw the first non-path separator, mark this as the end of our
          // path component
          matchedSlash = false;
          end = i + 1;
        }
      }

      if (end === -1) return '';
      return path.slice(start, end);
    }
  },

  extname: function extname(path) {
    assertPath(path);
    var startDot = -1;
    var startPart = 0;
    var end = -1;
    var matchedSlash = true;
    // Track the state of characters (if any) we see before our first dot and
    // after any path separator we find
    var preDotState = 0;
    for (var i = path.length - 1; i >= 0; --i) {
      var code = path.charCodeAt(i);
      if (code === 47 /*/*/) {
          // If we reached a path separator that was not part of a set of path
          // separators at the end of the string, stop now
          if (!matchedSlash) {
            startPart = i + 1;
            break;
          }
          continue;
        }
      if (end === -1) {
        // We saw the first non-path separator, mark this as the end of our
        // extension
        matchedSlash = false;
        end = i + 1;
      }
      if (code === 46 /*.*/) {
          // If this is our first dot, mark it as the start of our extension
          if (startDot === -1)
            startDot = i;
          else if (preDotState !== 1)
            preDotState = 1;
      } else if (startDot !== -1) {
        // We saw a non-dot and non-path separator before our dot, so we should
        // have a good chance at having a non-empty extension
        preDotState = -1;
      }
    }

    if (startDot === -1 || end === -1 ||
        // We saw a non-dot character immediately before the dot
        preDotState === 0 ||
        // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      return '';
    }
    return path.slice(startDot, end);
  },

  format: function format(pathObject) {
    if (pathObject === null || typeof pathObject !== 'object') {
      throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
    }
    return _format('/', pathObject);
  },

  parse: function parse(path) {
    assertPath(path);

    var ret = { root: '', dir: '', base: '', ext: '', name: '' };
    if (path.length === 0) return ret;
    var code = path.charCodeAt(0);
    var isAbsolute = code === 47 /*/*/;
    var start;
    if (isAbsolute) {
      ret.root = '/';
      start = 1;
    } else {
      start = 0;
    }
    var startDot = -1;
    var startPart = 0;
    var end = -1;
    var matchedSlash = true;
    var i = path.length - 1;

    // Track the state of characters (if any) we see before our first dot and
    // after any path separator we find
    var preDotState = 0;

    // Get non-dir info
    for (; i >= start; --i) {
      code = path.charCodeAt(i);
      if (code === 47 /*/*/) {
          // If we reached a path separator that was not part of a set of path
          // separators at the end of the string, stop now
          if (!matchedSlash) {
            startPart = i + 1;
            break;
          }
          continue;
        }
      if (end === -1) {
        // We saw the first non-path separator, mark this as the end of our
        // extension
        matchedSlash = false;
        end = i + 1;
      }
      if (code === 46 /*.*/) {
          // If this is our first dot, mark it as the start of our extension
          if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
        // We saw a non-dot and non-path separator before our dot, so we should
        // have a good chance at having a non-empty extension
        preDotState = -1;
      }
    }

    if (startDot === -1 || end === -1 ||
    // We saw a non-dot character immediately before the dot
    preDotState === 0 ||
    // The (right-most) trimmed path component is exactly '..'
    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      if (end !== -1) {
        if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);
      }
    } else {
      if (startPart === 0 && isAbsolute) {
        ret.name = path.slice(1, startDot);
        ret.base = path.slice(1, end);
      } else {
        ret.name = path.slice(startPart, startDot);
        ret.base = path.slice(startPart, end);
      }
      ret.ext = path.slice(startDot, end);
    }

    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';

    return ret;
  },

  sep: '/',
  delimiter: ':',
  win32: null,
  posix: null
};

posix.posix = posix;

module.exports = posix;

}).call(this)}).call(this,require('_process'))
},{"_process":116}],116:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],117:[function(require,module,exports){
arguments[4][62][0].apply(exports,arguments)
},{"buffer":110,"dup":62}],118:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = require('events').EventEmitter;
var inherits = require('inherits');

inherits(Stream, EE);
Stream.Readable = require('readable-stream/lib/_stream_readable.js');
Stream.Writable = require('readable-stream/lib/_stream_writable.js');
Stream.Duplex = require('readable-stream/lib/_stream_duplex.js');
Stream.Transform = require('readable-stream/lib/_stream_transform.js');
Stream.PassThrough = require('readable-stream/lib/_stream_passthrough.js');
Stream.finished = require('readable-stream/lib/internal/streams/end-of-stream.js')
Stream.pipeline = require('readable-stream/lib/internal/streams/pipeline.js')

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

},{"events":111,"inherits":113,"readable-stream/lib/_stream_duplex.js":120,"readable-stream/lib/_stream_passthrough.js":121,"readable-stream/lib/_stream_readable.js":122,"readable-stream/lib/_stream_transform.js":123,"readable-stream/lib/_stream_writable.js":124,"readable-stream/lib/internal/streams/end-of-stream.js":128,"readable-stream/lib/internal/streams/pipeline.js":130}],119:[function(require,module,exports){
arguments[4][46][0].apply(exports,arguments)
},{"dup":46}],120:[function(require,module,exports){
arguments[4][47][0].apply(exports,arguments)
},{"./_stream_readable":122,"./_stream_writable":124,"_process":116,"dup":47,"inherits":113}],121:[function(require,module,exports){
arguments[4][48][0].apply(exports,arguments)
},{"./_stream_transform":123,"dup":48,"inherits":113}],122:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"../errors":119,"./_stream_duplex":120,"./internal/streams/async_iterator":125,"./internal/streams/buffer_list":126,"./internal/streams/destroy":127,"./internal/streams/from":129,"./internal/streams/state":131,"./internal/streams/stream":132,"_process":116,"buffer":110,"dup":49,"events":111,"inherits":113,"string_decoder/":133,"util":109}],123:[function(require,module,exports){
arguments[4][50][0].apply(exports,arguments)
},{"../errors":119,"./_stream_duplex":120,"dup":50,"inherits":113}],124:[function(require,module,exports){
arguments[4][51][0].apply(exports,arguments)
},{"../errors":119,"./_stream_duplex":120,"./internal/streams/destroy":127,"./internal/streams/state":131,"./internal/streams/stream":132,"_process":116,"buffer":110,"dup":51,"inherits":113,"util-deprecate":134}],125:[function(require,module,exports){
arguments[4][52][0].apply(exports,arguments)
},{"./end-of-stream":128,"_process":116,"dup":52}],126:[function(require,module,exports){
arguments[4][53][0].apply(exports,arguments)
},{"buffer":110,"dup":53,"util":109}],127:[function(require,module,exports){
arguments[4][54][0].apply(exports,arguments)
},{"_process":116,"dup":54}],128:[function(require,module,exports){
arguments[4][55][0].apply(exports,arguments)
},{"../../../errors":119,"dup":55}],129:[function(require,module,exports){
arguments[4][56][0].apply(exports,arguments)
},{"dup":56}],130:[function(require,module,exports){
arguments[4][57][0].apply(exports,arguments)
},{"../../../errors":119,"./end-of-stream":128,"dup":57}],131:[function(require,module,exports){
arguments[4][58][0].apply(exports,arguments)
},{"../../../errors":119,"dup":58}],132:[function(require,module,exports){
arguments[4][59][0].apply(exports,arguments)
},{"dup":59,"events":111}],133:[function(require,module,exports){
arguments[4][71][0].apply(exports,arguments)
},{"dup":71,"safe-buffer":117}],134:[function(require,module,exports){
arguments[4][76][0].apply(exports,arguments)
},{"dup":76}]},{},[86])(86)
});
